<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Artify - Canva Style Editor</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
        }

        /* Main Layout */
        .canva-layout {
            display: grid;
            grid-template-areas:
                "header header header"
                "sidebar canvas properties";
            grid-template-columns: 80px 1fr 320px;
            grid-template-rows: 60px 1fr;
            height: 100vh;
            background: #f0f0f0;
        }

        /* Header */
        .canva-header {
            grid-area: header;
            background: white;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .project-name {
            font-size: 14px;
            color: #666;
        }

        .header-center {
            display: flex;
            gap: 10px;
        }

        .header-btn {
            padding: 8px 16px;
            border: 1px solid #e0e0e0;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .header-btn:hover {
            background: #f5f5f5;
        }

        .header-btn.primary {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .header-btn.primary:hover {
            background: #5568d3;
        }

        /* Left Sidebar - Tool Palette */
        .left-sidebar {
            grid-area: sidebar;
            background: white;
            border-right: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px 0;
            gap: 10px;
        }

        .tool-item {
            width: 60px;
            height: 60px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s;
            font-size: 24px;
            position: relative;
        }

        .tool-item:hover {
            background: #f5f5f5;
        }

        .tool-item.active {
            background: #e8eaff;
            color: #667eea;
        }

        .tool-label {
            font-size: 10px;
            margin-top: 4px;
        }

        /* Canvas Area */
        .canvas-container {
            grid-area: canvas;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
            overflow: auto;
            background: #e5e5e5;
        }

        .canvas-wrapper {
            position: relative;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }

        #mainCanvas {
            background: white;
            cursor: crosshair;
        }

        /* Right Properties Panel */
        .properties-panel {
            grid-area: properties;
            background: white;
            border-left: 1px solid #e0e0e0;
            overflow-y: auto;
            padding: 20px;
        }

        .panel-section {
            margin-bottom: 30px;
        }

        .panel-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #333;
        }

        .panel-group {
            margin-bottom: 15px;
        }

        .panel-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 6px;
            display: block;
        }

        .panel-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            font-size: 14px;
        }

        .panel-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .color-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
            margin-top: 10px;
        }

        .color-swatch {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .color-swatch:hover {
            transform: scale(1.1);
        }

        .color-swatch.active {
            border-color: #667eea;
            box-shadow: 0 0 0 2px white, 0 0 0 4px #667eea;
        }

        .slider-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .slider-group input[type="range"] {
            flex: 1;
        }

        .slider-value {
            min-width: 40px;
            text-align: right;
            font-size: 12px;
            color: #666;
        }

        /* Layers Panel */
        .layers-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
        }

        .layer-item {
            padding: 10px;
            border-bottom: 1px solid #e0e0e0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: all 0.2s;
        }

        .layer-item:hover {
            background: #f5f5f5;
        }

        .layer-item.active {
            background: #e8eaff;
            border-left: 3px solid #667eea;
        }

        .layer-icon {
            margin-right: 8px;
        }

        .layer-actions {
            display: flex;
            gap: 5px;
        }

        .layer-btn {
            padding: 4px 8px;
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 12px;
            border-radius: 4px;
        }

        .layer-btn:hover {
            background: #e0e0e0;
        }

        /* AI Panel */
        .ai-panel {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            border-radius: 12px;
            color: white;
            margin-bottom: 20px;
        }

        .ai-panel textarea {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 6px;
            resize: vertical;
            min-height: 80px;
            margin-bottom: 10px;
        }

        .ai-panel select {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 6px;
            margin-bottom: 10px;
        }

        .ai-btn {
            width: 100%;
            padding: 12px;
            background: white;
            color: #667eea;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .ai-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .ai-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Button Groups */
        .btn-group {
            display: flex;
            gap: 8px;
        }

        .btn-icon {
            padding: 8px 12px;
            border: 1px solid #e0e0e0;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-icon:hover {
            background: #f5f5f5;
        }

        .btn-icon:active {
            background: #e8eaff;
        }

        /* Font Selector */
        .font-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .font-option {
            padding: 8px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }

        .font-option:hover {
            background: #f5f5f5;
        }

        .font-option.active {
            background: #e8eaff;
            border-color: #667eea;
        }

        /* Messages */
        .message {
            padding: 12px;
            border-radius: 6px;
            margin-top: 10px;
            font-size: 14px;
            text-align: center;
        }

        .message.success {
            background: #d4edda;
            color: #155724;
        }

        .message.error {
            background: #f8d7da;
            color: #721c24;
        }

        .message.loading {
            background: #d1ecf1;
            color: #0c5460;
        }

        /* Image Upload */
        .upload-area {
            border: 2px dashed #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .upload-area:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .upload-area input {
            display: none;
        }

        /* Export Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 12px;
            width: 450px;
            max-width: 90%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-title {
            font-size: 20px;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
            padding: 0;
            width: 30px;
            height: 30px;
        }

        .modal-close:hover {
            color: #000;
        }

        .export-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .export-format-group {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .export-format-btn {
            padding: 15px;
            border: 2px solid #e0e0e0;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            font-weight: 500;
        }

        .export-format-btn:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .export-format-btn.active {
            border-color: #667eea;
            background: #e8eaff;
            color: #667eea;
        }

        .export-resolution-group {
            display: flex;
            gap: 10px;
        }

        .export-resolution-btn {
            flex: 1;
            padding: 10px;
            border: 2px solid #e0e0e0;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }

        .export-resolution-btn:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .export-resolution-btn.active {
            border-color: #667eea;
            background: #e8eaff;
            color: #667eea;
        }

        .export-quality-slider {
            width: 100%;
        }

        .export-btn-primary {
            width: 100%;
            padding: 15px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .export-btn-primary:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .export-btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Inline Text Editor */
        .inline-text-editor {
            position: absolute;
            display: none;
            background: transparent;
            border: 2px solid #667eea;
            outline: none;
            padding: 4px;
            font-family: inherit;
            font-size: inherit;
            color: inherit;
            resize: none;
            overflow: hidden;
            z-index: 100;
            min-width: 50px;
            min-height: 30px;
        }

        .inline-text-editor:focus {
            border-color: #5568d3;
        }

        /* Template Modal */
        .template-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-top: 15px;
        }

        .template-card {
            padding: 20px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .template-card:hover {
            border-color: #667eea;
            background: #f8f9ff;
            transform: translateY(-2px);
        }

        .template-card.active {
            border-color: #667eea;
            background: #e8eaff;
        }

        .template-icon {
            font-size: 32px;
            margin-bottom: 8px;
        }

        .template-name {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 4px;
            color: #333;
        }

        .template-size {
            font-size: 12px;
            color: #666;
        }

        .custom-size-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        /* Crop Mode */
        .crop-overlay {
            position: absolute;
            border: 2px dashed #667eea;
            background: rgba(102, 126, 234, 0.1);
            cursor: move;
            display: none;
            z-index: 50;
        }

        .crop-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #667eea;
            border: 2px solid white;
            border-radius: 50%;
            cursor: pointer;
        }

        .crop-handle.nw { top: -6px; left: -6px; cursor: nw-resize; }
        .crop-handle.ne { top: -6px; right: -6px; cursor: ne-resize; }
        .crop-handle.sw { bottom: -6px; left: -6px; cursor: sw-resize; }
        .crop-handle.se { bottom: -6px; right: -6px; cursor: se-resize; }

        .crop-actions {
            position: absolute;
            bottom: -45px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            background: white;
            padding: 8px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .crop-actions button {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }

        .crop-actions .apply {
            background: #667eea;
            color: white;
        }

        .crop-actions .cancel {
            background: #e0e0e0;
            color: #333;
        }
    </style>
</head>
<body>
    <div class="canva-layout">
        <!-- Header -->
        <div class="canva-header">
            <div class="header-left">
                <div class="logo">Artify</div>
                <div class="project-name" id="projectName">ìƒˆ í”„ë¡œì íŠ¸</div>
            </div>
            <div class="header-center">
                <button class="header-btn" onclick="undo()" id="undoBtn" disabled aria-label="ì‹¤í–‰ ì·¨ì†Œ" title="ì‹¤í–‰ ì·¨ì†Œ (Ctrl+Z)">
                    â†¶ ì‹¤í–‰ ì·¨ì†Œ
                </button>
                <button class="header-btn" onclick="redo()" id="redoBtn" disabled aria-label="ë‹¤ì‹œ ì‹¤í–‰" title="ë‹¤ì‹œ ì‹¤í–‰ (Ctrl+Y)">
                    â†· ë‹¤ì‹œ ì‹¤í–‰
                </button>
            </div>
            <div class="header-right">
                <button class="header-btn" onclick="location.href='index.html'" aria-label="í”„ë¡œì íŠ¸ ëª©ë¡ìœ¼ë¡œ ëŒì•„ê°€ê¸°">â† ëª©ë¡</button>
                <button class="header-btn" onclick="showCollaborateModal()" aria-label="í˜‘ì—…">ğŸ‘¥ í˜‘ì—…</button>
                <button class="header-btn" onclick="showTemplateModal()" aria-label="ìº”ë²„ìŠ¤ í¬ê¸° ë³€ê²½">ğŸ“ ìº”ë²„ìŠ¤ í¬ê¸°</button>
                <button class="header-btn" onclick="showExportModal()" aria-label="ë‹¤ìš´ë¡œë“œ">ğŸ“¥ ë‹¤ìš´ë¡œë“œ</button>
                <button class="header-btn primary" onclick="saveProject()" aria-label="í”„ë¡œì íŠ¸ ì €ì¥">ğŸ’¾ ì €ì¥</button>
                <button class="header-btn" onclick="handleLogout()" aria-label="ë¡œê·¸ì•„ì›ƒ">ë¡œê·¸ì•„ì›ƒ</button>
            </div>
        </div>

        <!-- Left Sidebar - Tools -->
        <div class="left-sidebar" role="toolbar" aria-label="ë„êµ¬ ëª¨ìŒ">
            <div class="tool-item active" onclick="setTool('select')" data-tool="select" role="button" aria-label="ì„ íƒ ë„êµ¬" tabindex="0">
                <div>â¬œ</div>
                <div class="tool-label">ì„ íƒ</div>
            </div>
            <div class="tool-item" onclick="setTool('text')" data-tool="text" role="button" aria-label="í…ìŠ¤íŠ¸ ë„êµ¬" tabindex="0">
                <div>T</div>
                <div class="tool-label">í…ìŠ¤íŠ¸</div>
            </div>
            <div class="tool-item" onclick="setTool('rect')" data-tool="rect" role="button" aria-label="ì‚¬ê°í˜• ë„êµ¬" tabindex="0">
                <div>â–¢</div>
                <div class="tool-label">ì‚¬ê°í˜•</div>
            </div>
            <div class="tool-item" onclick="setTool('circle')" data-tool="circle" role="button" aria-label="ì› ë„êµ¬" tabindex="0">
                <div>â—‹</div>
                <div class="tool-label">ì›</div>
            </div>
            <div class="tool-item" onclick="setTool('triangle')" data-tool="triangle" role="button" aria-label="ì‚¼ê°í˜• ë„êµ¬" tabindex="0">
                <div>â–³</div>
                <div class="tool-label">ì‚¼ê°í˜•</div>
            </div>
            <div class="tool-item" onclick="setTool('star')" data-tool="star" role="button" aria-label="ë³„ ë„êµ¬" tabindex="0">
                <div>â˜…</div>
                <div class="tool-label">ë³„</div>
            </div>
            <div class="tool-item" onclick="setTool('diamond')" data-tool="diamond" role="button" aria-label="ë‹¤ì´ì•„ëª¬ë“œ ë„êµ¬" tabindex="0">
                <div>â—†</div>
                <div class="tool-label">ë‹¤ì´ì•„ëª¬ë“œ</div>
            </div>
            <div class="tool-item" onclick="setTool('hexagon')" data-tool="hexagon" role="button" aria-label="ìœ¡ê°í˜• ë„êµ¬" tabindex="0">
                <div>â¬¢</div>
                <div class="tool-label">ìœ¡ê°í˜•</div>
            </div>
            <div class="tool-item" onclick="setTool('speech-bubble')" data-tool="speech-bubble" role="button" aria-label="ë§í’ì„  ë„êµ¬" tabindex="0">
                <div>ğŸ’¬</div>
                <div class="tool-label">ë§í’ì„ </div>
            </div>
            <div class="tool-item" onclick="setTool('cloud')" data-tool="cloud" role="button" aria-label="êµ¬ë¦„ ë„êµ¬" tabindex="0">
                <div>â˜ï¸</div>
                <div class="tool-label">êµ¬ë¦„</div>
            </div>
            <div class="tool-item" onclick="setTool('line')" data-tool="line" role="button" aria-label="ì„  ë„êµ¬" tabindex="0">
                <div>â”€</div>
                <div class="tool-label">ì„ </div>
            </div>
            <div class="tool-item" onclick="setTool('arrow')" data-tool="arrow" role="button" aria-label="í™”ì‚´í‘œ ë„êµ¬" tabindex="0">
                <div>â†’</div>
                <div class="tool-label">í™”ì‚´í‘œ</div>
            </div>
            <div class="tool-item" onclick="setTool('pencil')" data-tool="pencil" role="button" aria-label="íœ ë„êµ¬" tabindex="0">
                <div>âœï¸</div>
                <div class="tool-label">íœ</div>
            </div>
            <div class="tool-item" onclick="document.getElementById('imageUpload').click()" role="button" aria-label="ì´ë¯¸ì§€ ì—…ë¡œë“œ" tabindex="0">
                <div>ğŸ–¼ï¸</div>
                <div class="tool-label">ì´ë¯¸ì§€</div>
            </div>
            <input type="file" id="imageUpload" accept="image/*" style="display:none" onchange="handleImageUpload(event)" aria-label="ì´ë¯¸ì§€ íŒŒì¼ ì„ íƒ">
        </div>

        <!-- Canvas Area -->
        <div class="canvas-container">
            <div class="canvas-wrapper">
                <canvas id="mainCanvas" width="1200" height="800" role="img" aria-label="ë””ìì¸ ìº”ë²„ìŠ¤"></canvas>
                <textarea id="inlineTextEditor" class="inline-text-editor"></textarea>
                <div id="cropOverlay" class="crop-overlay">
                    <div class="crop-handle nw"></div>
                    <div class="crop-handle ne"></div>
                    <div class="crop-handle sw"></div>
                    <div class="crop-handle se"></div>
                    <div class="crop-actions">
                        <button class="apply" onclick="applyCrop()">âœ“ ì ìš©</button>
                        <button class="cancel" onclick="cancelCrop()">âœ• ì·¨ì†Œ</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Properties Panel -->
        <div class="properties-panel">
            <!-- AI Generation -->
            <div class="ai-panel">
                <div class="panel-title" style="color: white; margin-bottom: 10px;">ğŸ¤– AI ì´ë¯¸ì§€ ìƒì„±</div>
                <textarea id="aiPrompt" placeholder="ì›í•˜ëŠ” ì´ë¯¸ì§€ë¥¼ ì„¤ëª…í•˜ì„¸ìš”..."></textarea>
                <select id="aiSize">
                    <option value="1024x1024">ì •ì‚¬ê°í˜• (1024x1024)</option>
                    <option value="1792x1024">ê°€ë¡œí˜• (1792x1024)</option>
                    <option value="1024x1792">ì„¸ë¡œí˜• (1024x1792)</option>
                </select>
                <button class="ai-btn" onclick="generateAIImage()" id="aiBtn">ì´ë¯¸ì§€ ìƒì„±</button>
                <div id="aiMessage"></div>
            </div>

            <!-- Element Properties -->
            <div class="panel-section" id="elementProps" style="display:none;">
                <div class="panel-title">ìš”ì†Œ ì†ì„±</div>

                <div class="panel-group">
                    <label class="panel-label">ìœ„ì¹˜ X</label>
                    <input type="number" class="panel-input" id="propX" oninput="updateElementProp('x', this.value)">
                </div>

                <div class="panel-group">
                    <label class="panel-label">ìœ„ì¹˜ Y</label>
                    <input type="number" class="panel-input" id="propY" oninput="updateElementProp('y', this.value)">
                </div>

                <div class="panel-group">
                    <label class="panel-label">ë„ˆë¹„</label>
                    <input type="number" class="panel-input" id="propWidth" oninput="updateElementProp('width', this.value)">
                </div>

                <div class="panel-group">
                    <label class="panel-label">ë†’ì´</label>
                    <input type="number" class="panel-input" id="propHeight" oninput="updateElementProp('height', this.value)">
                </div>

                <div class="panel-group">
                    <label class="panel-label">íšŒì „ (ë„)</label>
                    <div class="slider-group">
                        <input type="range" min="0" max="360" value="0" id="propRotation" oninput="updateElementProp('rotation', this.value)">
                        <span class="slider-value" id="rotationValue">0Â°</span>
                    </div>
                </div>

                <div class="panel-group">
                    <label class="panel-label">ë¶ˆíˆ¬ëª…ë„</label>
                    <div class="slider-group">
                        <input type="range" min="0" max="100" value="100" id="propOpacity" oninput="updateElementProp('opacity', this.value)">
                        <span class="slider-value" id="opacityValue">100%</span>
                    </div>
                </div>
            </div>

            <!-- Text Properties -->
            <div class="panel-section" id="textProps" style="display:none;">
                <div class="panel-title">í…ìŠ¤íŠ¸ ì†ì„±</div>

                <div class="panel-group">
                    <label class="panel-label">ë‚´ìš©</label>
                    <input type="text" class="panel-input" id="propText" oninput="updateElementProp('text', this.value)">
                </div>

                <div class="panel-group">
                    <label class="panel-label">í°íŠ¸</label>
                    <select class="panel-input" id="propFont" onchange="updateElementProp('fontFamily', this.value)">
                        <option value="Arial">Arial</option>
                        <option value="Georgia">Georgia</option>
                        <option value="Times New Roman">Times New Roman</option>
                        <option value="Courier New">Courier New</option>
                        <option value="Verdana">Verdana</option>
                        <option value="Comic Sans MS">Comic Sans MS</option>
                    </select>
                </div>

                <div class="panel-group">
                    <label class="panel-label">í¬ê¸°</label>
                    <div class="slider-group">
                        <input type="range" min="8" max="120" value="24" id="propFontSize" oninput="updateElementProp('fontSize', this.value)">
                        <span class="slider-value" id="fontSizeValue">24px</span>
                    </div>
                </div>

                <div class="panel-group">
                    <label class="panel-label">ìŠ¤íƒ€ì¼</label>
                    <div class="btn-group">
                        <button class="btn-icon" onclick="toggleTextStyle('bold')" id="btnBold">
                            <strong>B</strong>
                        </button>
                        <button class="btn-icon" onclick="toggleTextStyle('italic')" id="btnItalic">
                            <em>I</em>
                        </button>
                        <button class="btn-icon" onclick="toggleTextStyle('underline')" id="btnUnderline">
                            <u>U</u>
                        </button>
                    </div>
                </div>

                <div class="panel-group">
                    <label class="panel-label">ì •ë ¬</label>
                    <div class="btn-group">
                        <button class="btn-icon" onclick="updateElementProp('textAlign', 'left')">â¬…ï¸</button>
                        <button class="btn-icon" onclick="updateElementProp('textAlign', 'center')">â†”ï¸</button>
                        <button class="btn-icon" onclick="updateElementProp('textAlign', 'right')">â¡ï¸</button>
                    </div>
                </div>

                <div class="panel-group">
                    <label class="panel-label">
                        <input type="checkbox" id="textShadowEnabled" onchange="toggleTextShadow(this.checked)">
                        í…ìŠ¤íŠ¸ ê·¸ë¦¼ì
                    </label>
                </div>

                <div id="textShadowControls" style="display:none;">
                    <div class="panel-group">
                        <label class="panel-label">X ì˜¤í”„ì…‹</label>
                        <div class="slider-group">
                            <input type="range" min="-20" max="20" value="2" id="shadowOffsetX" oninput="updateTextShadow('offsetX', this.value)">
                            <span class="slider-value" id="shadowXValue">2px</span>
                        </div>
                    </div>

                    <div class="panel-group">
                        <label class="panel-label">Y ì˜¤í”„ì…‹</label>
                        <div class="slider-group">
                            <input type="range" min="-20" max="20" value="2" id="shadowOffsetY" oninput="updateTextShadow('offsetY', this.value)">
                            <span class="slider-value" id="shadowYValue">2px</span>
                        </div>
                    </div>

                    <div class="panel-group">
                        <label class="panel-label">ë¸”ëŸ¬ ë°˜ê²½</label>
                        <div class="slider-group">
                            <input type="range" min="0" max="20" value="4" id="shadowBlur" oninput="updateTextShadow('blur', this.value)">
                            <span class="slider-value" id="shadowBlurValue">4px</span>
                        </div>
                    </div>

                    <div class="panel-group">
                        <label class="panel-label">ê·¸ë¦¼ì ìƒ‰ìƒ</label>
                        <input type="color" class="panel-input" id="shadowColor" value="#000000" onchange="updateTextShadow('color', this.value)">
                    </div>
                </div>
            </div>

            <!-- Image Filter Properties -->
            <div class="panel-section" id="imageProps" style="display:none;">
                <div class="panel-title">ì´ë¯¸ì§€ í•„í„°</div>

                <div class="panel-group">
                    <label class="panel-label">Grayscale</label>
                    <div class="slider-group">
                        <input type="range" min="0" max="100" value="0" id="filterGrayscale" oninput="updateImageFilter('grayscale', this.value)">
                        <span class="slider-value" id="grayscaleValue">0%</span>
                    </div>
                </div>

                <div class="panel-group">
                    <label class="panel-label">Sepia</label>
                    <div class="slider-group">
                        <input type="range" min="0" max="100" value="0" id="filterSepia" oninput="updateImageFilter('sepia', this.value)">
                        <span class="slider-value" id="sepiaValue">0%</span>
                    </div>
                </div>

                <div class="panel-group">
                    <label class="panel-label">Blur</label>
                    <div class="slider-group">
                        <input type="range" min="0" max="10" value="0" id="filterBlur" oninput="updateImageFilter('blur', this.value)">
                        <span class="slider-value" id="blurValue">0px</span>
                    </div>
                </div>

                <div class="panel-group">
                    <label class="panel-label">Brightness</label>
                    <div class="slider-group">
                        <input type="range" min="0" max="200" value="100" id="filterBrightness" oninput="updateImageFilter('brightness', this.value)">
                        <span class="slider-value" id="brightnessValue">100%</span>
                    </div>
                </div>

                <div class="btn-group" style="margin-top: 10px;">
                    <button class="btn-icon" onclick="resetImageFilters()" style="flex: 1;">í•„í„° ì´ˆê¸°í™”</button>
                    <button class="btn-icon" onclick="startCropMode()" style="flex: 1;" id="cropBtn">âœ‚ï¸ í¬ë¡­</button>
                </div>
            </div>

            <!-- Color Properties -->
            <div class="panel-section">
                <div class="panel-title">ìƒ‰ìƒ</div>

                <div class="panel-group">
                    <label class="panel-label">ì±„ìš°ê¸°</label>
                    <input type="color" class="panel-input" id="propFill" value="#667eea" onchange="updateElementProp('fill', this.value)">
                </div>

                <div class="color-grid">
                    <div class="color-swatch" style="background: #667eea" onclick="setColor('#667eea')"></div>
                    <div class="color-swatch" style="background: #764ba2" onclick="setColor('#764ba2')"></div>
                    <div class="color-swatch" style="background: #f093fb" onclick="setColor('#f093fb')"></div>
                    <div class="color-swatch" style="background: #4facfe" onclick="setColor('#4facfe')"></div>
                    <div class="color-swatch" style="background: #43e97b" onclick="setColor('#43e97b')"></div>
                    <div class="color-swatch" style="background: #fa709a" onclick="setColor('#fa709a')"></div>
                    <div class="color-swatch" style="background: #fee140" onclick="setColor('#fee140')"></div>
                    <div class="color-swatch" style="background: #30cfd0" onclick="setColor('#30cfd0')"></div>
                    <div class="color-swatch" style="background: #ff6b6b" onclick="setColor('#ff6b6b')"></div>
                    <div class="color-swatch" style="background: #4ecdc4" onclick="setColor('#4ecdc4')"></div>
                    <div class="color-swatch" style="background: #45b7d1" onclick="setColor('#45b7d1')"></div>
                    <div class="color-swatch" style="background: #96ceb4" onclick="setColor('#96ceb4')"></div>
                </div>

                <div class="panel-group" style="margin-top: 15px;">
                    <label class="panel-label">í…Œë‘ë¦¬ ìƒ‰ìƒ</label>
                    <input type="color" class="panel-input" id="propStroke" value="#000000" onchange="updateElementProp('stroke', this.value)">
                </div>

                <div class="panel-group">
                    <label class="panel-label">í…Œë‘ë¦¬ ë‘ê»˜</label>
                    <div class="slider-group">
                        <input type="range" min="0" max="20" value="2" id="propStrokeWidth" oninput="updateElementProp('strokeWidth', this.value)">
                        <span class="slider-value" id="strokeValue">2px</span>
                    </div>
                </div>

                <div class="panel-group" id="gradientSection" style="display:none;">
                    <label class="panel-label">
                        <input type="checkbox" id="gradientEnabled" onchange="toggleGradient(this.checked)">
                        ê·¸ë¼ë°ì´ì…˜ ì±„ìš°ê¸°
                    </label>
                </div>

                <div id="gradientControls" style="display:none;">
                    <div class="panel-group">
                        <label class="panel-label">ì‹œì‘ ìƒ‰ìƒ</label>
                        <input type="color" class="panel-input" id="gradientColor1" value="#667eea" onchange="updateGradient('color1', this.value)">
                    </div>

                    <div class="panel-group">
                        <label class="panel-label">ë ìƒ‰ìƒ</label>
                        <input type="color" class="panel-input" id="gradientColor2" value="#764ba2" onchange="updateGradient('color2', this.value)">
                    </div>

                    <div class="panel-group">
                        <label class="panel-label">ê°ë„</label>
                        <div class="slider-group">
                            <input type="range" min="0" max="360" value="0" id="gradientAngle" oninput="updateGradient('angle', this.value)">
                            <span class="slider-value" id="angleValue">0Â°</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Layers -->
            <div class="panel-section">
                <div class="panel-title">ë ˆì´ì–´</div>
                <div class="layers-list" id="layersList">
                    <div style="padding: 20px; text-align: center; color: #999;">
                        ìš”ì†Œë¥¼ ì¶”ê°€í•˜ì„¸ìš”
                    </div>
                </div>
                <div class="btn-group" style="margin-top: 10px;">
                    <button class="btn-icon" onclick="moveLayer('up')" style="flex:1">â†‘ ìœ„ë¡œ</button>
                    <button class="btn-icon" onclick="moveLayer('down')" style="flex:1">â†“ ì•„ë˜ë¡œ</button>
                    <button class="btn-icon" onclick="deleteSelected()" style="flex:1">ğŸ—‘ï¸ ì‚­ì œ</button>
                </div>
            </div>

            <!-- Alignment Tools -->
            <div class="panel-section">
                <div class="panel-title">ì •ë ¬</div>
                <div class="btn-group">
                    <button class="btn-icon" onclick="alignElements('left')" title="ì™¼ìª½ ì •ë ¬">â¬…ï¸</button>
                    <button class="btn-icon" onclick="alignElements('center')" title="ì¤‘ì•™ ì •ë ¬">â†”ï¸</button>
                    <button class="btn-icon" onclick="alignElements('right')" title="ì˜¤ë¥¸ìª½ ì •ë ¬">â¡ï¸</button>
                </div>
                <div class="btn-group" style="margin-top: 8px;">
                    <button class="btn-icon" onclick="alignElements('top')" title="ìœ„ìª½ ì •ë ¬">â¬†ï¸</button>
                    <button class="btn-icon" onclick="alignElements('middle')" title="ì¤‘ê°„ ì •ë ¬">â†•ï¸</button>
                    <button class="btn-icon" onclick="alignElements('bottom')" title="ì•„ë˜ìª½ ì •ë ¬">â¬‡ï¸</button>
                </div>
            </div>

            <div id="saveMessage"></div>
        </div>
    </div>

    <!-- Export Modal -->
    <div class="modal-overlay" id="exportModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">í”„ë¡œì íŠ¸ ë‚´ë³´ë‚´ê¸°</h2>
                <button class="modal-close" onclick="closeExportModal()">Ã—</button>
            </div>

            <div class="export-options">
                <div class="panel-group">
                    <label class="panel-label">íŒŒì¼ ì´ë¦„</label>
                    <input type="text" class="panel-input" id="exportFileName" value="artify-design">
                </div>

                <div class="panel-group">
                    <label class="panel-label">í¬ë§· ì„ íƒ</label>
                    <div class="export-format-group">
                        <button class="export-format-btn active" onclick="selectExportFormat('png')" id="formatPng">
                            PNG
                        </button>
                        <button class="export-format-btn" onclick="selectExportFormat('jpg')" id="formatJpg">
                            JPG
                        </button>
                        <button class="export-format-btn" onclick="selectExportFormat('svg')" id="formatSvg">
                            SVG
                        </button>
                    </div>
                </div>

                <div class="panel-group" id="resolutionGroup">
                    <label class="panel-label">í•´ìƒë„</label>
                    <div class="export-resolution-group">
                        <button class="export-resolution-btn active" onclick="selectExportResolution(1)" id="res1x">
                            1x<br><small>í‘œì¤€</small>
                        </button>
                        <button class="export-resolution-btn" onclick="selectExportResolution(2)" id="res2x">
                            2x<br><small>ë ˆí‹°ë‚˜</small>
                        </button>
                        <button class="export-resolution-btn" onclick="selectExportResolution(3)" id="res3x">
                            3x<br><small>ê³ í•´ìƒë„</small>
                        </button>
                    </div>
                </div>

                <div class="panel-group" id="qualityGroup" style="display:none;">
                    <label class="panel-label">í’ˆì§ˆ <span id="qualityValue">90%</span></label>
                    <input type="range" min="10" max="100" value="90" class="export-quality-slider" id="exportQuality" oninput="updateQualityLabel(this.value)">
                </div>

                <button class="export-btn-primary" onclick="executeExport()">
                    ë‹¤ìš´ë¡œë“œ
                </button>
            </div>
        </div>
    </div>

    <!-- Template Modal -->
    <div class="modal-overlay" id="templateModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">ìº”ë²„ìŠ¤ í¬ê¸° ì„ íƒ</h2>
                <button class="modal-close" onclick="closeTemplateModal()">Ã—</button>
            </div>

            <div class="export-options">
                <div class="template-grid">
                    <div class="template-card" onclick="selectTemplate('instagram-post')">
                        <div class="template-icon">ğŸ“·</div>
                        <div class="template-name">Instagram í¬ìŠ¤íŠ¸</div>
                        <div class="template-size">1080 Ã— 1080</div>
                    </div>

                    <div class="template-card" onclick="selectTemplate('instagram-story')">
                        <div class="template-icon">ğŸ“±</div>
                        <div class="template-name">Instagram ìŠ¤í† ë¦¬</div>
                        <div class="template-size">1080 Ã— 1920</div>
                    </div>

                    <div class="template-card" onclick="selectTemplate('facebook-post')">
                        <div class="template-icon">ğŸ‘¥</div>
                        <div class="template-name">Facebook í¬ìŠ¤íŠ¸</div>
                        <div class="template-size">1200 Ã— 630</div>
                    </div>

                    <div class="template-card" onclick="selectTemplate('twitter-post')">
                        <div class="template-icon">ğŸ¦</div>
                        <div class="template-name">Twitter í¬ìŠ¤íŠ¸</div>
                        <div class="template-size">1024 Ã— 512</div>
                    </div>

                    <div class="template-card" onclick="selectTemplate('linkedin-post')">
                        <div class="template-icon">ğŸ’¼</div>
                        <div class="template-name">LinkedIn í¬ìŠ¤íŠ¸</div>
                        <div class="template-size">1200 Ã— 627</div>
                    </div>

                    <div class="template-card" onclick="selectTemplate('youtube-thumbnail')">
                        <div class="template-icon">â–¶ï¸</div>
                        <div class="template-name">YouTube ì¸ë„¤ì¼</div>
                        <div class="template-size">1280 Ã— 720</div>
                    </div>

                    <div class="template-card" onclick="selectTemplate('presentation')">
                        <div class="template-icon">ğŸ“Š</div>
                        <div class="template-name">í”„ë ˆì  í…Œì´ì…˜</div>
                        <div class="template-size">1920 Ã— 1080</div>
                    </div>

                    <div class="template-card" onclick="selectTemplate('a4-portrait')">
                        <div class="template-icon">ğŸ“„</div>
                        <div class="template-name">A4 ì„¸ë¡œ</div>
                        <div class="template-size">2480 Ã— 3508</div>
                    </div>
                </div>

                <div class="panel-group" style="margin-top: 20px;">
                    <label class="panel-label">ì»¤ìŠ¤í…€ í¬ê¸°</label>
                    <div class="custom-size-inputs">
                        <div>
                            <input type="number" class="panel-input" id="customWidth" placeholder="ë„ˆë¹„" value="1200">
                        </div>
                        <div>
                            <input type="number" class="panel-input" id="customHeight" placeholder="ë†’ì´" value="800">
                        </div>
                    </div>
                </div>

                <button class="export-btn-primary" onclick="applyTemplate()">
                    ì ìš©
                </button>
            </div>
        </div>
    </div>

    <!-- Collaborate Modal (P11) -->
    <div class="modal-overlay" id="collaborateModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">í”„ë¡œì íŠ¸ í˜‘ì—…</h2>
                <button class="modal-close" onclick="closeCollaborateModal()">Ã—</button>
            </div>

            <div class="export-options">
                <div class="panel-group">
                    <label class="panel-label">ê³µìœ  ë§í¬</label>
                    <div style="display: flex; gap: 8px;">
                        <input type="text" class="panel-input" id="shareLink" readonly value="ë§í¬ ìƒì„± ì¤‘...">
                        <button class="btn-icon" onclick="copyShareLink()" style="width: auto; padding: 8px 16px;">ë³µì‚¬</button>
                    </div>
                </div>

                <div class="panel-group">
                    <label class="panel-label">í˜‘ì—…ì ê¶Œí•œ</label>
                    <select class="panel-input" id="sharePermission">
                        <option value="view">ë³´ê¸°ë§Œ ê°€ëŠ¥</option>
                        <option value="edit">í¸ì§‘ ê°€ëŠ¥</option>
                    </select>
                </div>

                <button class="export-btn-primary" onclick="generateShareLink()">
                    ê³µìœ  ë§í¬ ìƒì„±
                </button>

                <div style="margin-top: 20px; padding: 12px; background: #f8f9ff; border-radius: 8px; font-size: 13px; color: #666;">
                    ğŸ’¡ ìƒì„±ëœ ë§í¬ë¥¼ í˜‘ì—…ìì—ê²Œ ì „ë‹¬í•˜ì—¬ í•¨ê»˜ í¸ì§‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
                </div>
            </div>
        </div>
    </div>

    <script src="config.js"></script>
    <script>
        // Global State
        let canvas, ctx;
        let elements = [];
        let selectedElement = null;
        let selectedElements = [];
        let currentTool = 'select';
        let isDrawing = false;
        let isDragging = false;
        let isResizing = false;
        let dragStart = {x: 0, y: 0};
        let resizeHandle = null;
        let history = [];
        let historyIndex = -1;
        let currentProjectId = null;
        let gridEnabled = true;
        let snapEnabled = true;
        let nextGroupId = 1;
        let imageCache = new Map();
        let clipboard = null;
        let autoSaveInterval = null;
        let lastSaveTime = null;
        let isDirty = true;
        let renderScheduled = false;
        let exportFormat = 'png';
        let exportResolution = 1;
        let exportQuality = 0.9;
        let isEditingText = false;
        let editingElement = null;
        let selectedTemplate = null;
        let isCropMode = false;
        let cropElement = null;
        let cropRect = { x: 0, y: 0, width: 0, height: 0 };
        let cropDragStart = null;
        let cropResizeHandle = null;

        // Template presets
        const templates = {
            'instagram-post': { width: 1080, height: 1080 },
            'instagram-story': { width: 1080, height: 1920 },
            'facebook-post': { width: 1200, height: 630 },
            'twitter-post': { width: 1024, height: 512 },
            'linkedin-post': { width: 1200, height: 627 },
            'youtube-thumbnail': { width: 1280, height: 720 },
            'presentation': { width: 1920, height: 1080 },
            'a4-portrait': { width: 2480, height: 3508 }
        };

        // Element class
        class Element {
            constructor(type, x, y, width, height) {
                this.id = Date.now() + Math.random();
                this.type = type;
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.rotation = 0;
                this.fill = '#667eea';
                this.stroke = '#000000';
                this.strokeWidth = 2;
                this.opacity = 1;
                this.visible = true;
                this.locked = false;
                this.groupId = null;
                this.gradient = {
                    enabled: false,
                    type: 'linear',
                    color1: '#667eea',
                    color2: '#764ba2',
                    angle: 0
                };

                // Text specific
                if (type === 'text') {
                    this.text = 'í…ìŠ¤íŠ¸ ì…ë ¥';
                    this.fontSize = 24;
                    this.fontFamily = 'Arial';
                    this.textAlign = 'left';
                    this.bold = false;
                    this.italic = false;
                    this.underline = false;
                    this.textShadow = {
                        enabled: false,
                        offsetX: 2,
                        offsetY: 2,
                        blur: 4,
                        color: '#000000'
                    };
                }

                // Image specific
                if (type === 'image') {
                    this.imageData = null;
                    this.filters = {
                        grayscale: 0,
                        sepia: 0,
                        blur: 0,
                        brightness: 100
                    };
                }

                // Drawing path specific
                if (type === 'pencil') {
                    this.points = [];
                }
            }

            draw(context) {
                if (!this.visible) return;

                context.save();
                context.globalAlpha = this.opacity;
                context.translate(this.x + this.width / 2, this.y + this.height / 2);
                context.rotate(this.rotation * Math.PI / 180);
                context.translate(-(this.x + this.width / 2), -(this.y + this.height / 2));

                switch (this.type) {
                    case 'rect':
                        // Apply gradient or solid fill
                        if (this.gradient && this.gradient.enabled) {
                            const angle = this.gradient.angle * Math.PI / 180;
                            const x0 = this.x + this.width / 2 - Math.cos(angle) * this.width / 2;
                            const y0 = this.y + this.height / 2 - Math.sin(angle) * this.height / 2;
                            const x1 = this.x + this.width / 2 + Math.cos(angle) * this.width / 2;
                            const y1 = this.y + this.height / 2 + Math.sin(angle) * this.height / 2;
                            const gradient = context.createLinearGradient(x0, y0, x1, y1);
                            gradient.addColorStop(0, this.gradient.color1);
                            gradient.addColorStop(1, this.gradient.color2);
                            context.fillStyle = gradient;
                        } else {
                            context.fillStyle = this.fill;
                        }
                        context.strokeStyle = this.stroke;
                        context.lineWidth = this.strokeWidth;
                        context.fillRect(this.x, this.y, this.width, this.height);
                        if (this.strokeWidth > 0) {
                            context.strokeRect(this.x, this.y, this.width, this.height);
                        }
                        break;

                    case 'circle':
                        // Apply gradient or solid fill
                        if (this.gradient && this.gradient.enabled) {
                            const angle = this.gradient.angle * Math.PI / 180;
                            const radiusX = this.width / 2;
                            const radiusY = this.height / 2;
                            const cx = this.x + radiusX;
                            const cy = this.y + radiusY;
                            const x0 = cx - Math.cos(angle) * radiusX;
                            const y0 = cy - Math.sin(angle) * radiusY;
                            const x1 = cx + Math.cos(angle) * radiusX;
                            const y1 = cy + Math.sin(angle) * radiusY;
                            const gradient = context.createLinearGradient(x0, y0, x1, y1);
                            gradient.addColorStop(0, this.gradient.color1);
                            gradient.addColorStop(1, this.gradient.color2);
                            context.fillStyle = gradient;
                        } else {
                            context.fillStyle = this.fill;
                        }
                        context.strokeStyle = this.stroke;
                        context.lineWidth = this.strokeWidth;
                        context.beginPath();
                        const radiusX = this.width / 2;
                        const radiusY = this.height / 2;
                        context.ellipse(this.x + radiusX, this.y + radiusY, radiusX, radiusY, 0, 0, 2 * Math.PI);
                        context.fill();
                        if (this.strokeWidth > 0) {
                            context.stroke();
                        }
                        break;

                    case 'triangle':
                        context.fillStyle = this.fill;
                        context.strokeStyle = this.stroke;
                        context.lineWidth = this.strokeWidth;
                        context.beginPath();
                        context.moveTo(this.x + this.width / 2, this.y);
                        context.lineTo(this.x + this.width, this.y + this.height);
                        context.lineTo(this.x, this.y + this.height);
                        context.closePath();
                        context.fill();
                        if (this.strokeWidth > 0) {
                            context.stroke();
                        }
                        break;

                    case 'star':
                        this.drawStar(context);
                        break;

                    case 'diamond':
                        this.drawDiamond(context);
                        break;

                    case 'hexagon':
                        this.drawHexagon(context);
                        break;

                    case 'speech-bubble':
                        this.drawSpeechBubble(context);
                        break;

                    case 'cloud':
                        this.drawCloud(context);
                        break;

                    case 'line':
                        context.strokeStyle = this.stroke;
                        context.lineWidth = this.strokeWidth;
                        context.beginPath();
                        context.moveTo(this.x, this.y);
                        context.lineTo(this.x + this.width, this.y + this.height);
                        context.stroke();
                        break;

                    case 'arrow':
                        this.drawArrow(context);
                        break;

                    case 'text':
                        context.fillStyle = this.fill;
                        let fontStyle = '';
                        if (this.italic) fontStyle += 'italic ';
                        if (this.bold) fontStyle += 'bold ';
                        context.font = `${fontStyle}${this.fontSize}px ${this.fontFamily}`;
                        context.textAlign = this.textAlign;
                        context.textBaseline = 'top';

                        // Apply text shadow if enabled
                        if (this.textShadow && this.textShadow.enabled) {
                            context.shadowOffsetX = this.textShadow.offsetX;
                            context.shadowOffsetY = this.textShadow.offsetY;
                            context.shadowBlur = this.textShadow.blur;
                            context.shadowColor = this.textShadow.color;
                        }

                        let textX = this.x;
                        if (this.textAlign === 'center') textX += this.width / 2;
                        else if (this.textAlign === 'right') textX += this.width;

                        context.fillText(this.text, textX, this.y);

                        // Reset shadow
                        context.shadowOffsetX = 0;
                        context.shadowOffsetY = 0;
                        context.shadowBlur = 0;
                        context.shadowColor = 'transparent';

                        if (this.underline) {
                            const metrics = context.measureText(this.text);
                            context.beginPath();
                            context.moveTo(textX, this.y + this.fontSize + 2);
                            context.lineTo(textX + metrics.width, this.y + this.fontSize + 2);
                            context.strokeStyle = this.fill;
                            context.lineWidth = 1;
                            context.stroke();
                        }
                        break;

                    case 'image':
                        if (this.imageData) {
                            // Apply filters
                            if (this.filters) {
                                const filterParts = [];
                                if (this.filters.grayscale > 0) filterParts.push(`grayscale(${this.filters.grayscale}%)`);
                                if (this.filters.sepia > 0) filterParts.push(`sepia(${this.filters.sepia}%)`);
                                if (this.filters.blur > 0) filterParts.push(`blur(${this.filters.blur}px)`);
                                if (this.filters.brightness !== 100) filterParts.push(`brightness(${this.filters.brightness}%)`);
                                context.filter = filterParts.length > 0 ? filterParts.join(' ') : 'none';
                            }
                            context.drawImage(this.imageData, this.x, this.y, this.width, this.height);
                            context.filter = 'none';
                        }
                        break;

                    case 'pencil':
                        if (this.points.length > 0) {
                            context.strokeStyle = this.stroke;
                            context.lineWidth = this.strokeWidth;
                            context.lineCap = 'round';
                            context.lineJoin = 'round';
                            context.beginPath();
                            context.moveTo(this.points[0].x, this.points[0].y);
                            for (let i = 1; i < this.points.length; i++) {
                                context.lineTo(this.points[i].x, this.points[i].y);
                            }
                            context.stroke();
                        }
                        break;
                }

                context.restore();
            }

            drawStar(context) {
                const cx = this.x + this.width / 2;
                const cy = this.y + this.height / 2;
                const outerRadius = Math.min(this.width, this.height) / 2;
                const innerRadius = outerRadius / 2;
                const points = 5;

                context.fillStyle = this.fill;
                context.strokeStyle = this.stroke;
                context.lineWidth = this.strokeWidth;
                context.beginPath();

                for (let i = 0; i < points * 2; i++) {
                    const radius = i % 2 === 0 ? outerRadius : innerRadius;
                    const angle = (i * Math.PI) / points - Math.PI / 2;
                    const x = cx + radius * Math.cos(angle);
                    const y = cy + radius * Math.sin(angle);
                    if (i === 0) context.moveTo(x, y);
                    else context.lineTo(x, y);
                }

                context.closePath();
                context.fill();
                if (this.strokeWidth > 0) {
                    context.stroke();
                }
            }

            drawArrow(context) {
                const headLength = 20;
                const dx = this.width;
                const dy = this.height;
                const angle = Math.atan2(dy, dx);

                context.strokeStyle = this.stroke;
                context.fillStyle = this.stroke;
                context.lineWidth = this.strokeWidth;

                // Line
                context.beginPath();
                context.moveTo(this.x, this.y);
                context.lineTo(this.x + dx, this.y + dy);
                context.stroke();

                // Arrowhead
                context.beginPath();
                context.moveTo(this.x + dx, this.y + dy);
                context.lineTo(
                    this.x + dx - headLength * Math.cos(angle - Math.PI / 6),
                    this.y + dy - headLength * Math.sin(angle - Math.PI / 6)
                );
                context.lineTo(
                    this.x + dx - headLength * Math.cos(angle + Math.PI / 6),
                    this.y + dy - headLength * Math.sin(angle + Math.PI / 6)
                );
                context.closePath();
                context.fill();
            }

            drawDiamond(context) {
                context.fillStyle = this.fill;
                context.strokeStyle = this.stroke;
                context.lineWidth = this.strokeWidth;
                context.beginPath();

                // Diamond is rotated square
                const cx = this.x + this.width / 2;
                const cy = this.y + this.height / 2;

                context.moveTo(cx, this.y); // Top
                context.lineTo(this.x + this.width, cy); // Right
                context.lineTo(cx, this.y + this.height); // Bottom
                context.lineTo(this.x, cy); // Left

                context.closePath();
                context.fill();
                if (this.strokeWidth > 0) {
                    context.stroke();
                }
            }

            drawHexagon(context) {
                context.fillStyle = this.fill;
                context.strokeStyle = this.stroke;
                context.lineWidth = this.strokeWidth;
                context.beginPath();

                const cx = this.x + this.width / 2;
                const cy = this.y + this.height / 2;
                const angleStep = (Math.PI * 2) / 6;
                const radius = Math.min(this.width, this.height) / 2;

                for (let i = 0; i < 6; i++) {
                    const angle = angleStep * i - Math.PI / 2;
                    const px = cx + radius * Math.cos(angle);
                    const py = cy + radius * Math.sin(angle);
                    if (i === 0) {
                        context.moveTo(px, py);
                    } else {
                        context.lineTo(px, py);
                    }
                }

                context.closePath();
                context.fill();
                if (this.strokeWidth > 0) {
                    context.stroke();
                }
            }

            drawSpeechBubble(context) {
                context.fillStyle = this.fill;
                context.strokeStyle = this.stroke;
                context.lineWidth = this.strokeWidth;

                const bubbleHeight = this.height * 0.75;
                const tailHeight = this.height * 0.25;
                const radius = 10;

                context.beginPath();

                // Main bubble (rounded rectangle)
                context.moveTo(this.x + radius, this.y);
                context.lineTo(this.x + this.width - radius, this.y);
                context.arcTo(this.x + this.width, this.y, this.x + this.width, this.y + radius, radius);
                context.lineTo(this.x + this.width, this.y + bubbleHeight - radius);
                context.arcTo(this.x + this.width, this.y + bubbleHeight, this.x + this.width - radius, this.y + bubbleHeight, radius);

                // Tail (pointing down-left)
                const tailStartX = this.x + this.width * 0.2;
                context.lineTo(tailStartX + 20, this.y + bubbleHeight);
                context.lineTo(tailStartX, this.y + this.height);
                context.lineTo(tailStartX, this.y + bubbleHeight);

                context.lineTo(this.x + radius, this.y + bubbleHeight);
                context.arcTo(this.x, this.y + bubbleHeight, this.x, this.y + bubbleHeight - radius, radius);
                context.lineTo(this.x, this.y + radius);
                context.arcTo(this.x, this.y, this.x + radius, this.y, radius);

                context.closePath();
                context.fill();
                if (this.strokeWidth > 0) {
                    context.stroke();
                }
            }

            drawCloud(context) {
                context.fillStyle = this.fill;
                context.strokeStyle = this.stroke;
                context.lineWidth = this.strokeWidth;

                const cx = this.x + this.width / 2;
                const cy = this.y + this.height / 2;

                context.beginPath();

                // Cloud is made of overlapping circles
                const r1 = this.width * 0.2;
                const r2 = this.width * 0.25;
                const r3 = this.width * 0.2;
                const r4 = this.width * 0.15;
                const r5 = this.width * 0.15;

                // Bottom large circles
                context.arc(this.x + this.width * 0.25, cy + this.height * 0.1, r1, 0, Math.PI * 2);
                context.arc(cx, cy, r2, 0, Math.PI * 2);
                context.arc(this.x + this.width * 0.75, cy + this.height * 0.1, r3, 0, Math.PI * 2);

                // Top smaller circles
                context.arc(this.x + this.width * 0.4, cy - this.height * 0.15, r4, 0, Math.PI * 2);
                context.arc(this.x + this.width * 0.6, cy - this.height * 0.15, r5, 0, Math.PI * 2);

                context.fill();
                if (this.strokeWidth > 0) {
                    context.stroke();
                }
            }

            contains(x, y) {
                if (this.type === 'pencil') {
                    // Check if point is near any line segment
                    for (let i = 0; i < this.points.length - 1; i++) {
                        const dist = this.distanceToSegment(x, y, this.points[i], this.points[i + 1]);
                        if (dist < this.strokeWidth + 5) return true;
                    }
                    return false;
                }

                return x >= this.x && x <= this.x + this.width &&
                       y >= this.y && y <= this.y + this.height;
            }

            distanceToSegment(px, py, p1, p2) {
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const len = Math.sqrt(dx * dx + dy * dy);
                if (len === 0) return Math.sqrt((px - p1.x) ** 2 + (py - p1.y) ** 2);

                const t = Math.max(0, Math.min(1, ((px - p1.x) * dx + (py - p1.y) * dy) / (len * len)));
                const projX = p1.x + t * dx;
                const projY = p1.y + t * dy;
                return Math.sqrt((px - projX) ** 2 + (py - projY) ** 2);
            }

            getResizeHandle(x, y) {
                if (this.type === 'pencil') return null;

                const handles = [
                    {name: 'nw', x: this.x, y: this.y},
                    {name: 'ne', x: this.x + this.width, y: this.y},
                    {name: 'sw', x: this.x, y: this.y + this.height},
                    {name: 'se', x: this.x + this.width, y: this.y + this.height},
                ];

                for (let handle of handles) {
                    if (Math.abs(x - handle.x) < 8 && Math.abs(y - handle.y) < 8) {
                        return handle.name;
                    }
                }
                return null;
            }
        }

        // Initialize
        window.onload = function() {
            if (!checkAuth()) return;

            canvas = document.getElementById('mainCanvas');
            ctx = canvas.getContext('2d');

            const urlParams = new URLSearchParams(window.location.search);
            currentProjectId = urlParams.get('id');

            if (currentProjectId) {
                loadProject(currentProjectId);
                // Enable auto-save every 5 minutes
                autoSaveInterval = setInterval(autoSave, 5 * 60 * 1000);
            } else {
                render();
            }

            setupEventListeners();
            setupOnlineStatusListener();
        };

        function checkAuth() {
            const token = localStorage.getItem('token');
            if (!token) {
                alert('ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.');
                window.location.href = 'login.html';
                return false;
            }
            return true;
        }

        function handleLogout() {
            if (confirm('ë¡œê·¸ì•„ì›ƒ í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                localStorage.clear();
                window.location.href = 'login.html';
            }
        }

        function setupEventListeners() {
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('dblclick', handleDoubleClick);

            document.addEventListener('keydown', handleKeyDown);
        }

        function setupOnlineStatusListener() {
            window.addEventListener('online', () => {
                console.log('ì˜¨ë¼ì¸ ìƒíƒœë¡œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.');
                if (currentProjectId && elements.length > 0) {
                    autoSave();
                }
            });

            window.addEventListener('offline', () => {
                console.log('ì˜¤í”„ë¼ì¸ ìƒíƒœì…ë‹ˆë‹¤. ë³€ê²½ì‚¬í•­ì´ ì €ì¥ë˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
            });
        }

        async function fetchWithRetry(url, options, maxRetries = 3) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (response.ok || response.status === 404) {
                        return response;
                    }
                    if (i === maxRetries - 1) throw new Error('Max retries reached');
                } catch (error) {
                    if (i === maxRetries - 1) throw error;
                    await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
                }
            }
        }

        async function autoSave() {
            if (!currentProjectId || elements.length === 0) return;

            try {
                const token = localStorage.getItem('token');
                const canvasData = canvas.toDataURL('image/jpeg', 0.8);

                const projectData = {
                    image: canvasData,
                    elements: elements.map(el => ({
                        ...el,
                        imageData: el.imageData ? el.imageData.src : null
                    })),
                    prompt: document.getElementById('aiPrompt').value,
                    lastModified: new Date().toISOString()
                };

                const response = await fetchWithRetry(`${API_URL}/projects/${currentProjectId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + token
                    },
                    body: JSON.stringify({
                        data: JSON.stringify(projectData)
                    })
                });

                if (response.ok) {
                    lastSaveTime = new Date();
                    console.log('ìë™ ì €ì¥ ì™„ë£Œ:', lastSaveTime.toLocaleTimeString());
                }
            } catch (error) {
                console.error('ìë™ ì €ì¥ ì‹¤íŒ¨:', error);
            }
        }

        function handleMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (currentTool === 'select') {
                // Check for resize handle
                if (selectedElement) {
                    resizeHandle = selectedElement.getResizeHandle(x, y);
                    if (resizeHandle) {
                        isResizing = true;
                        dragStart = {x, y};
                        return;
                    }
                }

                // Check for element selection
                for (let i = elements.length - 1; i >= 0; i--) {
                    if (elements[i].contains(x, y) && !elements[i].locked) {
                        const clickedElement = elements[i];

                        // If element is part of a group, select all group members
                        if (clickedElement.groupId) {
                            selectedElements = elements.filter(el => el.groupId === clickedElement.groupId);
                            selectedElement = clickedElement;
                        } else if (e.ctrlKey || e.metaKey) {
                            // Ctrl+Click for multi-select
                            if (selectedElements.includes(clickedElement)) {
                                selectedElements = selectedElements.filter(el => el !== clickedElement);
                                selectedElement = selectedElements[0] || null;
                            } else {
                                selectedElements.push(clickedElement);
                                selectedElement = clickedElement;
                            }
                        } else {
                            // Single select
                            selectedElement = clickedElement;
                            selectedElements = [clickedElement];
                        }

                        isDragging = true;
                        dragStart = {x: x - selectedElement.x, y: y - selectedElement.y};
                        updatePropertiesPanel();
                        updateLayersList();
                        render();
                        return;
                    }
                }

                // Deselect
                selectedElement = null;
                selectedElements = [];
                updatePropertiesPanel();
                updateLayersList();
                render();
            } else if (currentTool === 'pencil') {
                isDrawing = true;
                const pencil = new Element('pencil', x, y, 0, 0);
                pencil.points.push({x, y});
                pencil.stroke = document.getElementById('propStroke').value;
                pencil.strokeWidth = parseInt(document.getElementById('propStrokeWidth').value);
                elements.push(pencil);
                selectedElement = pencil;
            } else {
                // Start drawing shape
                isDrawing = true;
                dragStart = {x, y};
            }
        }

        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (isDragging && selectedElement && !selectedElement.locked) {
                const newX = snapEnabled ? Math.round((x - dragStart.x) / 10) * 10 : x - dragStart.x;
                const newY = snapEnabled ? Math.round((y - dragStart.y) / 10) * 10 : y - dragStart.y;
                const deltaX = newX - selectedElement.x;
                const deltaY = newY - selectedElement.y;

                // Move selected element
                selectedElement.x = newX;
                selectedElement.y = newY;

                // Move other selected elements
                if (selectedElements.length > 1) {
                    selectedElements.forEach(el => {
                        if (el !== selectedElement && !el.locked) {
                            el.x += deltaX;
                            el.y += deltaY;
                        }
                    });
                }

                updatePropertiesPanel();
                render();
            } else if (isResizing && selectedElement) {
                const dx = x - dragStart.x;
                const dy = y - dragStart.y;

                switch (resizeHandle) {
                    case 'se':
                        selectedElement.width = Math.max(10, selectedElement.width + dx);
                        selectedElement.height = Math.max(10, selectedElement.height + dy);
                        break;
                    case 'sw':
                        selectedElement.width = Math.max(10, selectedElement.width - dx);
                        selectedElement.height = Math.max(10, selectedElement.height + dy);
                        selectedElement.x += dx;
                        break;
                    case 'ne':
                        selectedElement.width = Math.max(10, selectedElement.width + dx);
                        selectedElement.height = Math.max(10, selectedElement.height - dy);
                        selectedElement.y += dy;
                        break;
                    case 'nw':
                        selectedElement.width = Math.max(10, selectedElement.width - dx);
                        selectedElement.height = Math.max(10, selectedElement.height - dy);
                        selectedElement.x += dx;
                        selectedElement.y += dy;
                        break;
                }

                dragStart = {x, y};
                updatePropertiesPanel();
                render();
            } else if (isDrawing && currentTool === 'pencil' && selectedElement) {
                selectedElement.points.push({x, y});
                render();
            }
        }

        function handleMouseUp(e) {
            if (isDrawing && currentTool !== 'select' && currentTool !== 'pencil') {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const width = x - dragStart.x;
                const height = y - dragStart.y;

                if (Math.abs(width) > 10 && Math.abs(height) > 10) {
                    const element = new Element(
                        currentTool,
                        Math.min(dragStart.x, x),
                        Math.min(dragStart.y, y),
                        Math.abs(width),
                        Math.abs(height)
                    );
                    element.fill = document.getElementById('propFill').value;
                    element.stroke = document.getElementById('propStroke').value;
                    element.strokeWidth = parseInt(document.getElementById('propStrokeWidth').value);

                    elements.push(element);
                    selectedElement = element;
                    saveHistory();
                    updatePropertiesPanel();
                    updateLayersList();
                    render();
                }
            } else if (currentTool === 'pencil' && selectedElement) {
                // Calculate bounding box for pencil
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                for (let point of selectedElement.points) {
                    minX = Math.min(minX, point.x);
                    minY = Math.min(minY, point.y);
                    maxX = Math.max(maxX, point.x);
                    maxY = Math.max(maxY, point.y);
                }
                selectedElement.x = minX;
                selectedElement.y = minY;
                selectedElement.width = maxX - minX;
                selectedElement.height = maxY - minY;

                saveHistory();
                updateLayersList();
            }

            isDragging = false;
            isDrawing = false;
            isResizing = false;
            resizeHandle = null;
        }

        function handleDoubleClick(e) {
            if (currentTool === 'text' || (selectedElement && selectedElement.type === 'text')) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                if (!selectedElement || selectedElement.type !== 'text') {
                    const text = new Element('text', x, y, 200, 40);
                    text.fill = document.getElementById('propFill').value;
                    elements.push(text);
                    selectedElement = text;
                    selectedElements = [text];
                    saveHistory();
                }

                // Show inline text editor
                showInlineTextEditor(selectedElement);
            }
        }

        function showInlineTextEditor(textElement) {
            if (!textElement || textElement.type !== 'text') return;

            isEditingText = true;
            editingElement = textElement;

            const editor = document.getElementById('inlineTextEditor');
            const rect = canvas.getBoundingClientRect();
            const canvasContainer = document.querySelector('.canvas-wrapper');

            // Position the editor
            editor.style.left = (textElement.x) + 'px';
            editor.style.top = (textElement.y) + 'px';
            editor.style.width = Math.max(textElement.width, 100) + 'px';
            editor.style.minHeight = textElement.height + 'px';

            // Style the editor to match the text element
            editor.style.fontFamily = textElement.fontFamily;
            editor.style.fontSize = textElement.fontSize + 'px';
            editor.style.color = textElement.fill;
            editor.style.fontWeight = textElement.bold ? 'bold' : 'normal';
            editor.style.fontStyle = textElement.italic ? 'italic' : 'normal';
            editor.style.textDecoration = textElement.underline ? 'underline' : 'none';
            editor.style.textAlign = textElement.textAlign;

            // Set the content
            editor.value = textElement.text;
            editor.style.display = 'block';
            editor.focus();
            editor.select();

            // Auto-resize as user types
            editor.oninput = function() {
                this.style.height = 'auto';
                this.style.height = this.scrollHeight + 'px';
            };

            // Handle when user finishes editing
            editor.onblur = function() {
                finishTextEditing();
            };

            editor.onkeydown = function(e) {
                if (e.key === 'Escape') {
                    finishTextEditing();
                } else if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
                    finishTextEditing();
                }
                e.stopPropagation();
            };
        }

        function finishTextEditing() {
            if (!isEditingText || !editingElement) return;

            const editor = document.getElementById('inlineTextEditor');
            const newText = editor.value.trim();

            if (newText) {
                editingElement.text = newText;

                // Measure text width
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                let fontStyle = '';
                if (editingElement.italic) fontStyle += 'italic ';
                if (editingElement.bold) fontStyle += 'bold ';
                tempCtx.font = `${fontStyle}${editingElement.fontSize}px ${editingElement.fontFamily}`;
                const metrics = tempCtx.measureText(newText);
                editingElement.width = Math.max(metrics.width + 10, 100);
                editingElement.height = Math.max(editingElement.fontSize + 10, 40);

                saveHistory();
            } else if (elements.includes(editingElement)) {
                // Remove empty text elements
                const index = elements.indexOf(editingElement);
                elements.splice(index, 1);
                selectedElement = null;
                selectedElements = [];
            }

            editor.style.display = 'none';
            editor.value = '';
            editor.onblur = null;
            editor.onkeydown = null;
            editor.oninput = null;

            isEditingText = false;
            editingElement = null;

            updatePropertiesPanel();
            updateLayersList();
            render();
        }

        function handleKeyDown(e) {
            // Ignore keyboard shortcuts during text editing
            if (isEditingText) return;

            if (e.key === 'Delete' && selectedElement) {
                deleteSelected();
            } else if (e.ctrlKey && e.key === 'z') {
                e.preventDefault();
                undo();
            } else if (e.ctrlKey && e.key === 'y') {
                e.preventDefault();
                redo();
            } else if (e.ctrlKey && e.shiftKey && e.key === 'G') {
                e.preventDefault();
                ungroupElements();
            } else if (e.ctrlKey && e.key === 'g') {
                e.preventDefault();
                groupElements();
            } else if (e.ctrlKey && e.key === 'a') {
                e.preventDefault();
                selectAll();
            } else if (e.ctrlKey && e.key === 'c') {
                e.preventDefault();
                copySelected();
            } else if (e.ctrlKey && e.key === 'v') {
                e.preventDefault();
                pasteClipboard();
            } else if (e.ctrlKey && e.key === 'd') {
                e.preventDefault();
                duplicateSelected();
            } else if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
                moveSelectedByArrow(e.key, e.ctrlKey);
            }
        }

        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-item').forEach(item => {
                item.classList.remove('active');
            });
            document.querySelector(`[data-tool="${tool}"]`).classList.add('active');

            if (tool !== 'select') {
                selectedElement = null;
                updatePropertiesPanel();
                render();
            }
        }

        function render() {
            if (!isDirty && !renderScheduled) return;

            if (!renderScheduled) {
                renderScheduled = true;
                requestAnimationFrame(() => {
                    renderScheduled = false;
                    isDirty = false;
                    actualRender();
                });
            }
        }

        function actualRender() {
            // Clear canvas
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            if (gridEnabled) {
                ctx.strokeStyle = '#f0f0f0';
                ctx.lineWidth = 1;
                for (let i = 0; i < canvas.width; i += 50) {
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i, canvas.height);
                    ctx.stroke();
                }
                for (let i = 0; i < canvas.height; i += 50) {
                    ctx.beginPath();
                    ctx.moveTo(0, i);
                    ctx.lineTo(canvas.width, i);
                    ctx.stroke();
                }
            }

            // Draw elements
            for (let element of elements) {
                element.draw(ctx);
            }

            // Draw selection
            if (currentTool === 'select') {
                // Draw all selected elements
                if (selectedElements.length > 1) {
                    ctx.strokeStyle = '#667eea';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    selectedElements.forEach(el => {
                        ctx.strokeRect(el.x - 2, el.y - 2, el.width + 4, el.height + 4);
                    });
                    ctx.setLineDash([]);
                } else if (selectedElement) {
                    ctx.strokeStyle = '#667eea';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(selectedElement.x - 2, selectedElement.y - 2,
                                  selectedElement.width + 4, selectedElement.height + 4);
                    ctx.setLineDash([]);

                    // Draw resize handles
                    if (selectedElement.type !== 'pencil') {
                        ctx.fillStyle = '#667eea';
                        const handles = [
                            {x: selectedElement.x, y: selectedElement.y},
                            {x: selectedElement.x + selectedElement.width, y: selectedElement.y},
                            {x: selectedElement.x, y: selectedElement.y + selectedElement.height},
                            {x: selectedElement.x + selectedElement.width, y: selectedElement.y + selectedElement.height},
                        ];
                        for (let handle of handles) {
                            ctx.fillRect(handle.x - 4, handle.y - 4, 8, 8);
                        }
                    }
                }
            }
        }

        function markDirty() {
            isDirty = true;
        }

        function updatePropertiesPanel() {
            const elementProps = document.getElementById('elementProps');
            const textProps = document.getElementById('textProps');
            const imageProps = document.getElementById('imageProps');
            const gradientSection = document.getElementById('gradientSection');

            if (selectedElement) {
                elementProps.style.display = 'block';
                document.getElementById('propX').value = Math.round(selectedElement.x);
                document.getElementById('propY').value = Math.round(selectedElement.y);
                document.getElementById('propWidth').value = Math.round(selectedElement.width);
                document.getElementById('propHeight').value = Math.round(selectedElement.height);
                document.getElementById('propRotation').value = selectedElement.rotation;
                document.getElementById('rotationValue').textContent = selectedElement.rotation + 'Â°';
                document.getElementById('propOpacity').value = selectedElement.opacity * 100;
                document.getElementById('opacityValue').textContent = Math.round(selectedElement.opacity * 100) + '%';
                document.getElementById('propFill').value = selectedElement.fill;
                document.getElementById('propStroke').value = selectedElement.stroke;
                document.getElementById('propStrokeWidth').value = selectedElement.strokeWidth;
                document.getElementById('strokeValue').textContent = selectedElement.strokeWidth + 'px';

                // Show gradient section for shapes
                if (['rect', 'circle', 'triangle', 'star', 'diamond', 'hexagon'].includes(selectedElement.type)) {
                    gradientSection.style.display = 'block';
                    if (selectedElement.gradient) {
                        document.getElementById('gradientEnabled').checked = selectedElement.gradient.enabled;
                        document.getElementById('gradientControls').style.display = selectedElement.gradient.enabled ? 'block' : 'none';
                        document.getElementById('gradientColor1').value = selectedElement.gradient.color1;
                        document.getElementById('gradientColor2').value = selectedElement.gradient.color2;
                        document.getElementById('gradientAngle').value = selectedElement.gradient.angle;
                        document.getElementById('angleValue').textContent = selectedElement.gradient.angle + 'Â°';
                    }
                } else {
                    gradientSection.style.display = 'none';
                }

                if (selectedElement.type === 'text') {
                    textProps.style.display = 'block';
                    imageProps.style.display = 'none';
                    document.getElementById('propText').value = selectedElement.text;
                    document.getElementById('propFont').value = selectedElement.fontFamily;
                    document.getElementById('propFontSize').value = selectedElement.fontSize;
                    document.getElementById('fontSizeValue').textContent = selectedElement.fontSize + 'px';

                    // Update text shadow controls
                    if (selectedElement.textShadow) {
                        document.getElementById('textShadowEnabled').checked = selectedElement.textShadow.enabled;
                        document.getElementById('textShadowControls').style.display = selectedElement.textShadow.enabled ? 'block' : 'none';
                        document.getElementById('shadowOffsetX').value = selectedElement.textShadow.offsetX;
                        document.getElementById('shadowXValue').textContent = selectedElement.textShadow.offsetX + 'px';
                        document.getElementById('shadowOffsetY').value = selectedElement.textShadow.offsetY;
                        document.getElementById('shadowYValue').textContent = selectedElement.textShadow.offsetY + 'px';
                        document.getElementById('shadowBlur').value = selectedElement.textShadow.blur;
                        document.getElementById('shadowBlurValue').textContent = selectedElement.textShadow.blur + 'px';
                        document.getElementById('shadowColor').value = selectedElement.textShadow.color;
                    }
                } else if (selectedElement.type === 'image') {
                    textProps.style.display = 'none';
                    imageProps.style.display = 'block';

                    // Update image filter controls
                    if (selectedElement.filters) {
                        document.getElementById('filterGrayscale').value = selectedElement.filters.grayscale;
                        document.getElementById('grayscaleValue').textContent = selectedElement.filters.grayscale + '%';
                        document.getElementById('filterSepia').value = selectedElement.filters.sepia;
                        document.getElementById('sepiaValue').textContent = selectedElement.filters.sepia + '%';
                        document.getElementById('filterBlur').value = selectedElement.filters.blur;
                        document.getElementById('blurValue').textContent = selectedElement.filters.blur + 'px';
                        document.getElementById('filterBrightness').value = selectedElement.filters.brightness;
                        document.getElementById('brightnessValue').textContent = selectedElement.filters.brightness + '%';
                    }
                } else {
                    textProps.style.display = 'none';
                    imageProps.style.display = 'none';
                }
            } else {
                elementProps.style.display = 'none';
                textProps.style.display = 'none';
                imageProps.style.display = 'none';
            }
        }

        function updateElementProp(prop, value) {
            if (!selectedElement) return;

            switch (prop) {
                case 'x':
                case 'y':
                case 'width':
                case 'height':
                case 'fontSize':
                    selectedElement[prop] = parseFloat(value);
                    break;
                case 'rotation':
                    selectedElement[prop] = parseFloat(value);
                    document.getElementById('rotationValue').textContent = value + 'Â°';
                    break;
                case 'opacity':
                    selectedElement[prop] = parseFloat(value) / 100;
                    document.getElementById('opacityValue').textContent = value + '%';
                    break;
                case 'strokeWidth':
                    selectedElement[prop] = parseFloat(value);
                    document.getElementById('strokeValue').textContent = value + 'px';
                    break;
                default:
                    selectedElement[prop] = value;
            }

            render();
        }

        function toggleTextStyle(style) {
            if (!selectedElement || selectedElement.type !== 'text') return;

            selectedElement[style] = !selectedElement[style];
            render();
        }

        function toggleTextShadow(enabled) {
            if (!selectedElement || selectedElement.type !== 'text') return;

            if (!selectedElement.textShadow) {
                selectedElement.textShadow = {
                    enabled: false,
                    offsetX: 2,
                    offsetY: 2,
                    blur: 4,
                    color: '#000000'
                };
            }

            selectedElement.textShadow.enabled = enabled;
            document.getElementById('textShadowControls').style.display = enabled ? 'block' : 'none';
            render();
        }

        function updateTextShadow(prop, value) {
            if (!selectedElement || selectedElement.type !== 'text' || !selectedElement.textShadow) return;

            switch (prop) {
                case 'offsetX':
                    selectedElement.textShadow.offsetX = parseFloat(value);
                    document.getElementById('shadowXValue').textContent = value + 'px';
                    break;
                case 'offsetY':
                    selectedElement.textShadow.offsetY = parseFloat(value);
                    document.getElementById('shadowYValue').textContent = value + 'px';
                    break;
                case 'blur':
                    selectedElement.textShadow.blur = parseFloat(value);
                    document.getElementById('shadowBlurValue').textContent = value + 'px';
                    break;
                case 'color':
                    selectedElement.textShadow.color = value;
                    break;
            }

            render();
        }

        function setColor(color) {
            document.getElementById('propFill').value = color;
            if (selectedElement) {
                selectedElement.fill = color;
                render();
            }
        }

        function updateImageFilter(filterType, value) {
            if (!selectedElement || selectedElement.type !== 'image' || !selectedElement.filters) return;

            selectedElement.filters[filterType] = parseFloat(value);

            switch (filterType) {
                case 'grayscale':
                    document.getElementById('grayscaleValue').textContent = value + '%';
                    break;
                case 'sepia':
                    document.getElementById('sepiaValue').textContent = value + '%';
                    break;
                case 'blur':
                    document.getElementById('blurValue').textContent = value + 'px';
                    break;
                case 'brightness':
                    document.getElementById('brightnessValue').textContent = value + '%';
                    break;
            }

            render();
        }

        function resetImageFilters() {
            if (!selectedElement || selectedElement.type !== 'image') return;

            selectedElement.filters = {
                grayscale: 0,
                sepia: 0,
                blur: 0,
                brightness: 100
            };

            updatePropertiesPanel();
            render();
        }

        function toggleGradient(enabled) {
            if (!selectedElement || !selectedElement.gradient) return;

            selectedElement.gradient.enabled = enabled;
            document.getElementById('gradientControls').style.display = enabled ? 'block' : 'none';
            render();
        }

        function updateGradient(prop, value) {
            if (!selectedElement || !selectedElement.gradient) return;

            selectedElement.gradient[prop] = prop === 'angle' ? parseFloat(value) : value;

            if (prop === 'angle') {
                document.getElementById('angleValue').textContent = value + 'Â°';
            }

            render();
        }

        function updateLayersList() {
            const layersList = document.getElementById('layersList');

            if (elements.length === 0) {
                layersList.innerHTML = '<div style="padding: 20px; text-align: center; color: #999;">ìš”ì†Œë¥¼ ì¶”ê°€í•˜ì„¸ìš”</div>';
                return;
            }

            layersList.innerHTML = '';
            for (let i = elements.length - 1; i >= 0; i--) {
                const element = elements[i];
                const layer = document.createElement('div');
                layer.className = 'layer-item' + (element === selectedElement ? ' active' : '');
                layer.onclick = () => {
                    selectedElement = element;
                    updatePropertiesPanel();
                    updateLayersList();
                    render();
                };

                let icon = '';
                switch (element.type) {
                    case 'rect': icon = 'â–¢'; break;
                    case 'circle': icon = 'â—‹'; break;
                    case 'triangle': icon = 'â–³'; break;
                    case 'star': icon = 'â˜…'; break;
                    case 'diamond': icon = 'â—†'; break;
                    case 'hexagon': icon = 'â¬¢'; break;
                    case 'speech-bubble': icon = 'ğŸ’¬'; break;
                    case 'cloud': icon = 'â˜ï¸'; break;
                    case 'line': icon = 'â”€'; break;
                    case 'arrow': icon = 'â†’'; break;
                    case 'text': icon = 'T'; break;
                    case 'image': icon = 'ğŸ–¼ï¸'; break;
                    case 'pencil': icon = 'âœï¸'; break;
                }

                layer.innerHTML = `
                    <div><span class="layer-icon">${icon}</span>${element.type === 'text' ? element.text.substring(0, 15) : element.type}</div>
                    <div class="layer-actions">
                        <button class="layer-btn" onclick="event.stopPropagation(); toggleLayerVisibility(${i})">${element.visible ? 'ğŸ‘ï¸' : 'ğŸš«'}</button>
                        <button class="layer-btn" onclick="event.stopPropagation(); toggleLayerLock(${i})">${element.locked ? 'ğŸ”’' : 'ğŸ”“'}</button>
                    </div>
                `;
                layersList.appendChild(layer);
            }
        }

        function toggleLayerVisibility(index) {
            const actualIndex = elements.length - 1 - index;
            elements[actualIndex].visible = !elements[actualIndex].visible;
            updateLayersList();
            render();
        }

        function toggleLayerLock(index) {
            const actualIndex = elements.length - 1 - index;
            elements[actualIndex].locked = !elements[actualIndex].locked;
            updateLayersList();
        }

        function moveLayer(direction) {
            if (!selectedElement) return;

            const index = elements.indexOf(selectedElement);
            if (direction === 'up' && index < elements.length - 1) {
                [elements[index], elements[index + 1]] = [elements[index + 1], elements[index]];
            } else if (direction === 'down' && index > 0) {
                [elements[index], elements[index - 1]] = [elements[index - 1], elements[index]];
            }

            updateLayersList();
            render();
        }

        function deleteSelected() {
            if (!selectedElement) return;

            const index = elements.indexOf(selectedElement);
            if (index > -1) {
                elements.splice(index, 1);
                selectedElement = null;
                saveHistory();
                updatePropertiesPanel();
                updateLayersList();
                render();
            }
        }

        function groupElements() {
            if (selectedElements.length < 2) {
                alert('ê·¸ë£¹í™”í•˜ë ¤ë©´ 2ê°œ ì´ìƒì˜ ìš”ì†Œë¥¼ ì„ íƒí•˜ì„¸ìš”.');
                return;
            }

            const groupId = nextGroupId++;
            selectedElements.forEach(el => {
                el.groupId = groupId;
            });

            saveHistory();
            alert(`${selectedElements.length}ê°œì˜ ìš”ì†Œê°€ ê·¸ë£¹í™”ë˜ì—ˆìŠµë‹ˆë‹¤.`);
        }

        function ungroupElements() {
            if (!selectedElement || !selectedElement.groupId) {
                alert('ê·¸ë£¹í™”ëœ ìš”ì†Œë¥¼ ì„ íƒí•˜ì„¸ìš”.');
                return;
            }

            const groupId = selectedElement.groupId;
            elements.forEach(el => {
                if (el.groupId === groupId) {
                    el.groupId = null;
                }
            });

            saveHistory();
            alert('ê·¸ë£¹ì´ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤.');
        }

        function selectAll() {
            selectedElements = elements.filter(el => el.visible && !el.locked);
            if (selectedElements.length > 0) {
                selectedElement = selectedElements[0];
                updatePropertiesPanel();
                updateLayersList();
                render();
            }
        }

        function copySelected() {
            if (!selectedElement) return;

            clipboard = JSON.parse(JSON.stringify({
                ...selectedElement,
                imageData: null,
                imageDataId: selectedElement.type === 'image' ? selectedElement.id : null
            }));
        }

        function pasteClipboard() {
            if (!clipboard) return;

            const el = new Element(clipboard.type, clipboard.x + 20, clipboard.y + 20, clipboard.width, clipboard.height);
            Object.assign(el, clipboard);
            el.id = Date.now() + Math.random();

            // Restore image data from cache
            if (clipboard.type === 'image' && clipboard.imageDataId) {
                const cachedImage = imageCache.get(clipboard.imageDataId);
                if (cachedImage) {
                    el.imageData = cachedImage;
                    imageCache.set(el.id, cachedImage);
                }
            }

            elements.push(el);
            selectedElement = el;
            selectedElements = [el];
            saveHistory();
            updatePropertiesPanel();
            updateLayersList();
            render();
        }

        function duplicateSelected() {
            if (!selectedElement) return;

            copySelected();
            pasteClipboard();
        }

        function moveSelectedByArrow(key, ctrlKey) {
            if (!selectedElement) return;

            const step = ctrlKey ? 10 : 1;
            const elementsToMove = selectedElements.length > 1 ? selectedElements : [selectedElement];

            elementsToMove.forEach(el => {
                if (el.locked) return;

                switch (key) {
                    case 'ArrowUp':
                        el.y -= step;
                        break;
                    case 'ArrowDown':
                        el.y += step;
                        break;
                    case 'ArrowLeft':
                        el.x -= step;
                        break;
                    case 'ArrowRight':
                        el.x += step;
                        break;
                }
            });

            updatePropertiesPanel();
            render();
        }

        function alignElements(alignment) {
            if (!selectedElement) return;

            switch (alignment) {
                case 'left':
                    selectedElement.x = 0;
                    break;
                case 'center':
                    selectedElement.x = (canvas.width - selectedElement.width) / 2;
                    break;
                case 'right':
                    selectedElement.x = canvas.width - selectedElement.width;
                    break;
                case 'top':
                    selectedElement.y = 0;
                    break;
                case 'middle':
                    selectedElement.y = (canvas.height - selectedElement.height) / 2;
                    break;
                case 'bottom':
                    selectedElement.y = canvas.height - selectedElement.height;
                    break;
            }

            updatePropertiesPanel();
            render();
        }

        function saveHistory() {
            history = history.slice(0, historyIndex + 1);

            // Serialize elements without image data
            const serialized = elements.map(el => {
                const copy = {...el};
                if (el.type === 'image' && el.imageData) {
                    // Cache the image and store only the ID
                    const imageId = el.id;
                    imageCache.set(imageId, el.imageData);
                    copy.imageDataId = imageId;
                    delete copy.imageData;
                }
                return copy;
            });

            history.push(JSON.stringify(serialized));
            historyIndex++;

            document.getElementById('undoBtn').disabled = historyIndex <= 0;
            document.getElementById('redoBtn').disabled = true;

            // Limit history to 50 entries to prevent memory issues
            if (history.length > 50) {
                history.shift();
                historyIndex--;
            }
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                restoreFromHistory();

                document.getElementById('undoBtn').disabled = historyIndex <= 0;
                document.getElementById('redoBtn').disabled = false;
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                restoreFromHistory();

                document.getElementById('undoBtn').disabled = false;
                document.getElementById('redoBtn').disabled = historyIndex >= history.length - 1;
            }
        }

        function restoreFromHistory() {
            const serialized = JSON.parse(history[historyIndex]);
            elements = serialized.map(data => {
                const el = new Element(data.type, data.x, data.y, data.width, data.height);
                Object.assign(el, data);

                // Restore image data from cache
                if (data.type === 'image' && data.imageDataId) {
                    el.imageData = imageCache.get(data.imageDataId) || null;
                }

                return el;
            });

            selectedElement = null;
            selectedElements = [];
            updatePropertiesPanel();
            updateLayersList();
            render();
        }

        async function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    const element = new Element('image', 100, 100, img.width, img.height);
                    element.imageData = img;
                    elements.push(element);
                    selectedElement = element;
                    saveHistory();
                    updatePropertiesPanel();
                    updateLayersList();
                    render();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        async function generateAIImage() {
            const prompt = document.getElementById('aiPrompt').value.trim();
            if (!prompt) {
                alert('í”„ë¡¬í”„íŠ¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }

            const aiBtn = document.getElementById('aiBtn');
            const aiMessage = document.getElementById('aiMessage');

            aiBtn.disabled = true;
            aiBtn.textContent = 'ìƒì„± ì¤‘...';
            aiMessage.innerHTML = '<div class="message loading">AIê°€ ì´ë¯¸ì§€ë¥¼ ìƒì„±í•˜ê³  ìˆìŠµë‹ˆë‹¤...</div>';

            try {
                const size = document.getElementById('aiSize').value;
                const response = await fetchWithRetry(`${PYTHON_API_URL}/generate-image`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt, size, quality: 'standard' })
                });

                const data = await response.json();
                if (response.ok && data.success) {
                    const img = new Image();
                    img.onload = function() {
                        const element = new Element('image', 50, 50, 400, 400);
                        element.imageData = img;
                        elements.push(element);
                        selectedElement = element;
                        saveHistory();
                        updatePropertiesPanel();
                        updateLayersList();
                        render();

                        aiMessage.innerHTML = '<div class="message success">ì´ë¯¸ì§€ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!</div>';
                        setTimeout(() => aiMessage.innerHTML = '', 3000);
                    };
                    img.src = data.imageData;
                } else {
                    throw new Error('ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨');
                }
            } catch (error) {
                aiMessage.innerHTML = '<div class="message error">ì´ë¯¸ì§€ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.</div>';
            } finally {
                aiBtn.disabled = false;
                aiBtn.textContent = 'ì´ë¯¸ì§€ ìƒì„±';
            }
        }

        async function saveProject() {
            if (!currentProjectId) {
                alert('í”„ë¡œì íŠ¸ IDê°€ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            const saveMessage = document.getElementById('saveMessage');
            saveMessage.innerHTML = '<div class="message loading">ì €ì¥ ì¤‘...</div>';

            try {
                const token = localStorage.getItem('token');

                // Save canvas as image
                const canvasData = canvas.toDataURL('image/jpeg', 0.8);

                const projectData = {
                    image: canvasData,
                    elements: elements.map(el => ({
                        ...el,
                        imageData: el.imageData ? el.imageData.src : null
                    })),
                    prompt: document.getElementById('aiPrompt').value,
                    lastModified: new Date().toISOString()
                };

                const response = await fetchWithRetry(`${API_URL}/projects/${currentProjectId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + token
                    },
                    body: JSON.stringify({
                        data: JSON.stringify(projectData)
                    })
                });

                if (response.ok) {
                    lastSaveTime = new Date();
                    saveMessage.innerHTML = '<div class="message success">í”„ë¡œì íŠ¸ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!</div>';
                    setTimeout(() => saveMessage.innerHTML = '', 3000);
                } else {
                    throw new Error('ì €ì¥ ì‹¤íŒ¨');
                }
            } catch (error) {
                saveMessage.innerHTML = '<div class="message error">ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì¬ì‹œë„í•©ë‹ˆë‹¤...</div>';
                console.error('Save error:', error);
            }
        }

        async function loadProject(projectId) {
            try {
                const token = localStorage.getItem('token');
                const response = await fetch(`${API_URL}/projects/${projectId}`, {
                    headers: { 'Authorization': 'Bearer ' + token }
                });

                if (response.ok) {
                    const project = await response.json();
                    document.getElementById('projectName').textContent = project.name;

                    if (project.data) {
                        try {
                            const data = JSON.parse(project.data);
                            if (data.prompt) {
                                document.getElementById('aiPrompt').value = data.prompt;
                            }
                            if (data.elements) {
                                // Restore elements
                                elements = [];
                                for (let elData of data.elements) {
                                    const el = new Element(elData.type, elData.x, elData.y, elData.width, elData.height);
                                    Object.assign(el, elData);

                                    if (elData.imageData) {
                                        const img = new Image();
                                        img.onload = () => render();
                                        img.src = elData.imageData;
                                        el.imageData = img;
                                    }

                                    elements.push(el);
                                }
                                saveHistory();
                                updateLayersList();
                                render();
                            } else if (data.image) {
                                // Load legacy image
                                const img = new Image();
                                img.onload = function() {
                                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                                };
                                img.src = data.image;
                            }
                        } catch (e) {
                            console.log('No saved data');
                            render();
                        }
                    } else {
                        render();
                    }
                }
            } catch (error) {
                console.error('Load error:', error);
                render();
            }
        }

        // Export Functions
        function showExportModal() {
            document.getElementById('exportModal').classList.add('active');

            // Set default filename from project name
            const projectName = document.getElementById('projectName').textContent || 'artify-design';
            document.getElementById('exportFileName').value = projectName.replace(/\s+/g, '-');
        }

        function closeExportModal() {
            document.getElementById('exportModal').classList.remove('active');
        }

        function selectExportFormat(format) {
            exportFormat = format;

            // Update button states
            document.querySelectorAll('.export-format-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById('format' + format.charAt(0).toUpperCase() + format.slice(1)).classList.add('active');

            // Show/hide resolution options for SVG
            const resolutionGroup = document.getElementById('resolutionGroup');
            const qualityGroup = document.getElementById('qualityGroup');

            if (format === 'svg') {
                resolutionGroup.style.display = 'none';
                qualityGroup.style.display = 'none';
            } else {
                resolutionGroup.style.display = 'block';
                qualityGroup.style.display = format === 'jpg' ? 'block' : 'none';
            }
        }

        function selectExportResolution(resolution) {
            exportResolution = resolution;

            // Update button states
            document.querySelectorAll('.export-resolution-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById('res' + resolution + 'x').classList.add('active');
        }

        function updateQualityLabel(value) {
            document.getElementById('qualityValue').textContent = value + '%';
            exportQuality = value / 100;
        }

        async function executeExport() {
            const fileName = document.getElementById('exportFileName').value || 'artify-design';

            try {
                if (exportFormat === 'svg') {
                    exportAsSVG(fileName);
                } else if (exportFormat === 'png') {
                    exportAsPNG(fileName, exportResolution);
                } else if (exportFormat === 'jpg') {
                    exportAsJPG(fileName, exportResolution, exportQuality);
                }

                closeExportModal();
            } catch (error) {
                console.error('Export error:', error);
                alert('ë‚´ë³´ë‚´ê¸° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
            }
        }

        function exportAsPNG(fileName, scale) {
            // Create a temporary canvas with scaled dimensions
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width * scale;
            tempCanvas.height = canvas.height * scale;
            const tempCtx = tempCanvas.getContext('2d');

            // Scale the context
            tempCtx.scale(scale, scale);

            // Fill white background
            tempCtx.fillStyle = '#ffffff';
            tempCtx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw all elements
            for (let element of elements) {
                element.draw(tempCtx);
            }

            // Convert to blob and download
            tempCanvas.toBlob((blob) => {
                downloadBlob(blob, fileName + '.png');
            }, 'image/png');
        }

        function exportAsJPG(fileName, scale, quality) {
            // Create a temporary canvas with scaled dimensions
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width * scale;
            tempCanvas.height = canvas.height * scale;
            const tempCtx = tempCanvas.getContext('2d');

            // Scale the context
            tempCtx.scale(scale, scale);

            // Fill white background (JPEG doesn't support transparency)
            tempCtx.fillStyle = '#ffffff';
            tempCtx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw all elements
            for (let element of elements) {
                element.draw(tempCtx);
            }

            // Convert to blob and download
            tempCanvas.toBlob((blob) => {
                downloadBlob(blob, fileName + '.jpg');
            }, 'image/jpeg', quality);
        }

        function exportAsSVG(fileName) {
            // Create SVG with all elements
            let svgContent = `<svg xmlns="http://www.w3.org/2000/svg" width="${canvas.width}" height="${canvas.height}" viewBox="0 0 ${canvas.width} ${canvas.height}">`;

            // White background
            svgContent += `<rect x="0" y="0" width="${canvas.width}" height="${canvas.height}" fill="#ffffff"/>`;

            // Convert each element to SVG
            for (let element of elements) {
                if (!element.visible) continue;

                const transform = `translate(${element.x + element.width / 2}, ${element.y + element.height / 2}) rotate(${element.rotation}) translate(-${element.x + element.width / 2}, -${element.y + element.height / 2})`;

                switch (element.type) {
                    case 'rect':
                        if (element.gradient && element.gradient.enabled) {
                            const gradId = 'grad-' + element.id;
                            const angle = element.gradient.angle * Math.PI / 180;
                            const x1 = 50 - Math.cos(angle) * 50;
                            const y1 = 50 - Math.sin(angle) * 50;
                            const x2 = 50 + Math.cos(angle) * 50;
                            const y2 = 50 + Math.sin(angle) * 50;

                            svgContent += `<defs><linearGradient id="${gradId}" x1="${x1}%" y1="${y1}%" x2="${x2}%" y2="${y2}%">`;
                            svgContent += `<stop offset="0%" stop-color="${element.gradient.color1}"/>`;
                            svgContent += `<stop offset="100%" stop-color="${element.gradient.color2}"/>`;
                            svgContent += `</linearGradient></defs>`;
                            svgContent += `<rect x="${element.x}" y="${element.y}" width="${element.width}" height="${element.height}" fill="url(#${gradId})" stroke="${element.stroke}" stroke-width="${element.strokeWidth}" opacity="${element.opacity}" transform="${transform}"/>`;
                        } else {
                            svgContent += `<rect x="${element.x}" y="${element.y}" width="${element.width}" height="${element.height}" fill="${element.fill}" stroke="${element.stroke}" stroke-width="${element.strokeWidth}" opacity="${element.opacity}" transform="${transform}"/>`;
                        }
                        break;

                    case 'circle':
                        const cx = element.x + element.width / 2;
                        const cy = element.y + element.height / 2;
                        const rx = element.width / 2;
                        const ry = element.height / 2;
                        svgContent += `<ellipse cx="${cx}" cy="${cy}" rx="${rx}" ry="${ry}" fill="${element.fill}" stroke="${element.stroke}" stroke-width="${element.strokeWidth}" opacity="${element.opacity}" transform="${transform}"/>`;
                        break;

                    case 'triangle':
                        const x1 = element.x + element.width / 2;
                        const y1 = element.y;
                        const x2 = element.x + element.width;
                        const y2 = element.y + element.height;
                        const x3 = element.x;
                        const y3 = element.y + element.height;
                        svgContent += `<polygon points="${x1},${y1} ${x2},${y2} ${x3},${y3}" fill="${element.fill}" stroke="${element.stroke}" stroke-width="${element.strokeWidth}" opacity="${element.opacity}" transform="${transform}"/>`;
                        break;

                    case 'line':
                        svgContent += `<line x1="${element.x}" y1="${element.y}" x2="${element.x + element.width}" y2="${element.y + element.height}" stroke="${element.stroke}" stroke-width="${element.strokeWidth}" opacity="${element.opacity}" transform="${transform}"/>`;
                        break;

                    case 'text':
                        let fontWeight = element.bold ? 'bold' : 'normal';
                        let fontStyle = element.italic ? 'italic' : 'normal';
                        let textDecoration = element.underline ? 'underline' : 'none';
                        let textAnchor = element.textAlign === 'center' ? 'middle' : element.textAlign === 'right' ? 'end' : 'start';
                        let textX = element.x;
                        if (element.textAlign === 'center') textX += element.width / 2;
                        else if (element.textAlign === 'right') textX += element.width;

                        // Add text shadow if enabled
                        let textFilter = '';
                        if (element.textShadow && element.textShadow.enabled) {
                            const filterId = 'shadow-' + element.id;
                            svgContent += `<defs><filter id="${filterId}">`;
                            svgContent += `<feDropShadow dx="${element.textShadow.offsetX}" dy="${element.textShadow.offsetY}" stdDeviation="${element.textShadow.blur / 2}" flood-color="${element.textShadow.color}"/>`;
                            svgContent += `</filter></defs>`;
                            textFilter = ` filter="url(#${filterId})"`;
                        }

                        svgContent += `<text x="${textX}" y="${element.y}" font-family="${element.fontFamily}" font-size="${element.fontSize}" font-weight="${fontWeight}" font-style="${fontStyle}" text-decoration="${textDecoration}" text-anchor="${textAnchor}" fill="${element.fill}" opacity="${element.opacity}" transform="${transform}"${textFilter}>${escapeXml(element.text)}</text>`;
                        break;

                    case 'pencil':
                        if (element.points.length > 0) {
                            let pathData = `M ${element.points[0].x} ${element.points[0].y}`;
                            for (let i = 1; i < element.points.length; i++) {
                                pathData += ` L ${element.points[i].x} ${element.points[i].y}`;
                            }
                            svgContent += `<path d="${pathData}" stroke="${element.stroke}" stroke-width="${element.strokeWidth}" fill="none" stroke-linecap="round" stroke-linejoin="round" opacity="${element.opacity}"/>`;
                        }
                        break;
                }
            }

            svgContent += '</svg>';

            // Download SVG
            const blob = new Blob([svgContent], { type: 'image/svg+xml' });
            downloadBlob(blob, fileName + '.svg');
        }

        function escapeXml(text) {
            return text.replace(/&/g, '&amp;')
                       .replace(/</g, '&lt;')
                       .replace(/>/g, '&gt;')
                       .replace(/"/g, '&quot;')
                       .replace(/'/g, '&apos;');
        }

        function downloadBlob(blob, fileName) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Close modal when clicking outside
        document.addEventListener('click', function(e) {
            const exportModal = document.getElementById('exportModal');
            const templateModal = document.getElementById('templateModal');

            if (e.target === exportModal) {
                closeExportModal();
            }
            if (e.target === templateModal) {
                closeTemplateModal();
            }
        });

        // Template Functions
        function showTemplateModal() {
            document.getElementById('templateModal').classList.add('active');

            // Set current canvas size in custom inputs
            document.getElementById('customWidth').value = canvas.width;
            document.getElementById('customHeight').value = canvas.height;
        }

        function closeTemplateModal() {
            document.getElementById('templateModal').classList.remove('active');

            // Clear active state from all cards
            document.querySelectorAll('.template-card').forEach(card => {
                card.classList.remove('active');
            });
            selectedTemplate = null;
        }

        function selectTemplate(templateId) {
            selectedTemplate = templateId;

            // Update active state
            document.querySelectorAll('.template-card').forEach(card => {
                card.classList.remove('active');
            });
            event.target.closest('.template-card').classList.add('active');

            // Update custom inputs with template size
            const template = templates[templateId];
            if (template) {
                document.getElementById('customWidth').value = template.width;
                document.getElementById('customHeight').value = template.height;
            }
        }

        function applyTemplate() {
            const newWidth = parseInt(document.getElementById('customWidth').value);
            const newHeight = parseInt(document.getElementById('customHeight').value);

            if (!newWidth || !newHeight || newWidth < 100 || newHeight < 100) {
                alert('ìº”ë²„ìŠ¤ í¬ê¸°ëŠ” ìµœì†Œ 100x100 ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤.');
                return;
            }

            if (newWidth > 5000 || newHeight > 5000) {
                alert('ìº”ë²„ìŠ¤ í¬ê¸°ëŠ” ìµœëŒ€ 5000x5000ê¹Œì§€ ê°€ëŠ¥í•©ë‹ˆë‹¤.');
                return;
            }

            // Confirm if there are elements on the canvas
            if (elements.length > 0) {
                const confirmed = confirm('ìº”ë²„ìŠ¤ í¬ê¸°ë¥¼ ë³€ê²½í•˜ë©´ ì¼ë¶€ ìš”ì†Œê°€ ë³´ì´ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?');
                if (!confirmed) return;
            }

            // Resize canvas
            canvas.width = newWidth;
            canvas.height = newHeight;

            // Re-render
            isDirty = true;
            render();

            closeTemplateModal();

            // Show success message
            alert(`ìº”ë²„ìŠ¤ í¬ê¸°ê°€ ${newWidth}x${newHeight}ìœ¼ë¡œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.`);
        }

        // Crop Functions
        function startCropMode() {
            if (!selectedElement || selectedElement.type !== 'image') {
                alert('ì´ë¯¸ì§€ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.');
                return;
            }

            isCropMode = true;
            cropElement = selectedElement;

            // Initialize crop rect to full image size
            cropRect = {
                x: selectedElement.x,
                y: selectedElement.y,
                width: selectedElement.width,
                height: selectedElement.height
            };

            showCropOverlay();
            setupCropHandlers();
        }

        function showCropOverlay() {
            const overlay = document.getElementById('cropOverlay');
            overlay.style.display = 'block';
            overlay.style.left = cropRect.x + 'px';
            overlay.style.top = cropRect.y + 'px';
            overlay.style.width = cropRect.width + 'px';
            overlay.style.height = cropRect.height + 'px';
        }

        function setupCropHandlers() {
            const overlay = document.getElementById('cropOverlay');
            const handles = overlay.querySelectorAll('.crop-handle');

            // Drag overlay to move crop area
            overlay.addEventListener('mousedown', function(e) {
                if (e.target.classList.contains('crop-handle')) {
                    cropResizeHandle = e.target.classList[1]; // nw, ne, sw, se
                } else if (e.target === overlay) {
                    cropDragStart = { x: e.clientX, y: e.clientY };
                }
                e.stopPropagation();
            });

            document.addEventListener('mousemove', function(e) {
                if (cropDragStart) {
                    // Move crop area
                    const dx = e.clientX - cropDragStart.x;
                    const dy = e.clientY - cropDragStart.y;

                    cropRect.x = Math.max(cropElement.x, Math.min(cropElement.x + cropElement.width - cropRect.width, cropRect.x + dx));
                    cropRect.y = Math.max(cropElement.y, Math.min(cropElement.y + cropElement.height - cropRect.height, cropRect.y + dy));

                    cropDragStart = { x: e.clientX, y: e.clientY };
                    showCropOverlay();
                } else if (cropResizeHandle) {
                    // Resize crop area
                    const dx = e.clientX - (cropRect.x + cropRect.width);
                    const dy = e.clientY - (cropRect.y + cropRect.height);

                    switch (cropResizeHandle) {
                        case 'se':
                            cropRect.width = Math.min(cropElement.x + cropElement.width - cropRect.x, Math.max(50, cropRect.width + dx));
                            cropRect.height = Math.min(cropElement.y + cropElement.height - cropRect.y, Math.max(50, cropRect.height + dy));
                            break;
                        case 'sw':
                            const newX = Math.max(cropElement.x, cropRect.x + dx);
                            const newWidth = cropRect.width - (newX - cropRect.x);
                            if (newWidth >= 50) {
                                cropRect.x = newX;
                                cropRect.width = newWidth;
                            }
                            cropRect.height = Math.min(cropElement.y + cropElement.height - cropRect.y, Math.max(50, cropRect.height + dy));
                            break;
                        case 'ne':
                            cropRect.width = Math.min(cropElement.x + cropElement.width - cropRect.x, Math.max(50, cropRect.width + dx));
                            const newY = Math.max(cropElement.y, cropRect.y + dy);
                            const newHeight = cropRect.height - (newY - cropRect.y);
                            if (newHeight >= 50) {
                                cropRect.y = newY;
                                cropRect.height = newHeight;
                            }
                            break;
                        case 'nw':
                            const newX2 = Math.max(cropElement.x, cropRect.x + dx);
                            const newWidth2 = cropRect.width - (newX2 - cropRect.x);
                            if (newWidth2 >= 50) {
                                cropRect.x = newX2;
                                cropRect.width = newWidth2;
                            }
                            const newY2 = Math.max(cropElement.y, cropRect.y + dy);
                            const newHeight2 = cropRect.height - (newY2 - cropRect.y);
                            if (newHeight2 >= 50) {
                                cropRect.y = newY2;
                                cropRect.height = newHeight2;
                            }
                            break;
                    }
                    showCropOverlay();
                }
            });

            document.addEventListener('mouseup', function() {
                cropDragStart = null;
                cropResizeHandle = null;
            });
        }

        function applyCrop() {
            if (!cropElement || !isCropMode) return;

            // Calculate crop area relative to image
            const cropX = (cropRect.x - cropElement.x) / cropElement.width;
            const cropY = (cropRect.y - cropElement.y) / cropElement.height;
            const cropW = cropRect.width / cropElement.width;
            const cropH = cropRect.height / cropElement.height;

            // Create new canvas to crop the image
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');

            const sourceWidth = cropElement.imageData.width * cropW;
            const sourceHeight = cropElement.imageData.height * cropH;

            tempCanvas.width = sourceWidth;
            tempCanvas.height = sourceHeight;

            // Draw cropped image
            tempCtx.drawImage(
                cropElement.imageData,
                cropElement.imageData.width * cropX,
                cropElement.imageData.height * cropY,
                sourceWidth,
                sourceHeight,
                0, 0,
                sourceWidth,
                sourceHeight
            );

            // Create new image from cropped canvas
            const croppedImg = new Image();
            croppedImg.onload = function() {
                cropElement.imageData = croppedImg;
                cropElement.x = cropRect.x;
                cropElement.y = cropRect.y;
                cropElement.width = cropRect.width;
                cropElement.height = cropRect.height;

                saveHistory();
                cancelCrop();
                render();
            };
            croppedImg.src = tempCanvas.toDataURL();
        }

        function cancelCrop() {
            isCropMode = false;
            cropElement = null;

            const overlay = document.getElementById('cropOverlay');
            overlay.style.display = 'none';

            // Remove event listeners
            const newOverlay = overlay.cloneNode(true);
            overlay.parentNode.replaceChild(newOverlay, overlay);
        }

        // P11: Collaboration Functions
        function showCollaborateModal() {
            document.getElementById('collaborateModal').classList.add('active');
            // Auto-generate link on open
            if (currentProjectId) {
                const baseUrl = window.location.origin;
                document.getElementById('shareLink').value = `${baseUrl}/editor-canva.html?id=${currentProjectId}&share=true`;
            }
        }

        function closeCollaborateModal() {
            document.getElementById('collaborateModal').classList.remove('active');
        }

        function generateShareLink() {
            if (!currentProjectId) {
                alert('í”„ë¡œì íŠ¸ë¥¼ ë¨¼ì € ì €ì¥í•´ì£¼ì„¸ìš”.');
                return;
            }

            const permission = document.getElementById('sharePermission').value;
            const baseUrl = window.location.origin;
            const shareUrl = `${baseUrl}/editor-canva.html?id=${currentProjectId}&share=true&permission=${permission}`;

            document.getElementById('shareLink').value = shareUrl;
            alert('ê³µìœ  ë§í¬ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!');
        }

        function copyShareLink() {
            const shareLink = document.getElementById('shareLink');
            shareLink.select();
            document.execCommand('copy');
            alert('ë§í¬ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!');
        }

        // Close modals when clicking outside
        document.addEventListener('click', function(e) {
            const exportModal = document.getElementById('exportModal');
            const templateModal = document.getElementById('templateModal');
            const collaborateModal = document.getElementById('collaborateModal');

            if (e.target === exportModal) {
                closeExportModal();
            }
            if (e.target === templateModal) {
                closeTemplateModal();
            }
            if (e.target === collaborateModal) {
                closeCollaborateModal();
            }
        });
    </script>
</body>
</html>
