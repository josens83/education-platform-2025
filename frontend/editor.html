<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Artify - Canva Style Editor</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="css/auth.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
        }

        /* Main Layout */
        .canva-layout {
            display: grid;
            grid-template-areas:
                "header header header"
                "sidebar canvas properties";
            grid-template-columns: 80px 1fr 320px;
            grid-template-rows: 60px 1fr;
            height: 100vh;
            background: #f0f0f0;
        }

        /* Header */
        .canva-header {
            grid-area: header;
            background: white;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .project-name {
            font-size: 14px;
            color: #666;
        }

        .header-center {
            display: flex;
            gap: 10px;
        }

        .header-btn {
            padding: 8px 16px;
            border: 1px solid #e0e0e0;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .header-btn:hover {
            background: #f5f5f5;
        }

        .header-btn.primary {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .header-btn.primary:hover {
            background: #5568d3;
        }

        /* Left Sidebar - Tool Palette */
        .left-sidebar {
            grid-area: sidebar;
            background: white;
            border-right: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px 0;
            gap: 10px;
        }

        .tool-item {
            width: 60px;
            height: 60px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s;
            font-size: 24px;
            position: relative;
        }

        .tool-item:hover {
            background: #f5f5f5;
        }

        .tool-item.active {
            background: #e8eaff;
            color: #667eea;
        }

        .tool-label {
            font-size: 10px;
            margin-top: 4px;
        }

        /* Canvas Area */
        .canvas-container {
            grid-area: canvas;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
            overflow: auto;
            background: #e5e5e5;
        }

        .canvas-wrapper {
            position: relative;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }

        #mainCanvas {
            background: white;
            cursor: crosshair;
        }

        /* P16: Zoom Controls */
        .zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            z-index: 100;
        }

        .zoom-btn {
            width: 32px;
            height: 32px;
            border: 1px solid #e0e0e0;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            color: #333;
            transition: all 0.2s;
        }

        .zoom-btn:hover {
            background: #f5f5f5;
            border-color: #667eea;
        }

        .zoom-btn:active {
            transform: scale(0.95);
        }

        .zoom-level {
            font-size: 13px;
            font-weight: 600;
            color: #666;
            min-width: 50px;
            text-align: center;
        }

        .canvas-container.panning #mainCanvas {
            cursor: grab;
        }

        .canvas-container.panning.dragging #mainCanvas {
            cursor: grabbing;
        }

        /* P17: Filter Buttons */
        .filter-btn {
            padding: 6px 10px;
            border: 1px solid #e0e0e0;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            flex: 1;
        }

        .filter-btn:hover {
            background: #f5f5f5;
        }

        .filter-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        /* Right Properties Panel */
        .properties-panel {
            grid-area: properties;
            background: white;
            border-left: 1px solid #e0e0e0;
            overflow-y: auto;
            padding: 20px;
        }

        .panel-section {
            margin-bottom: 30px;
        }

        .panel-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #333;
        }

        .panel-group {
            margin-bottom: 15px;
        }

        .panel-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 6px;
            display: block;
        }

        .panel-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            font-size: 14px;
        }

        .panel-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .color-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
            margin-top: 10px;
        }

        .color-swatch {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .color-swatch:hover {
            transform: scale(1.1);
        }

        .color-swatch.active {
            border-color: #667eea;
            box-shadow: 0 0 0 2px white, 0 0 0 4px #667eea;
        }

        .slider-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .slider-group input[type="range"] {
            flex: 1;
        }

        .slider-value {
            min-width: 40px;
            text-align: right;
            font-size: 12px;
            color: #666;
        }

        /* Layers Panel */
        .layers-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
        }

        .layer-item {
            padding: 10px;
            border-bottom: 1px solid #e0e0e0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: all 0.2s;
        }

        .layer-item:hover {
            background: #f5f5f5;
        }

        .layer-item.active {
            background: #e8eaff;
            border-left: 3px solid #667eea;
        }

        .layer-icon {
            margin-right: 8px;
        }

        .layer-actions {
            display: flex;
            gap: 5px;
        }

        .layer-btn {
            padding: 4px 8px;
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 12px;
            border-radius: 4px;
        }

        .layer-btn:hover {
            background: #e0e0e0;
        }

        /* AI Panel */
        .ai-panel {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            border-radius: 12px;
            color: white;
            margin-bottom: 20px;
        }

        .ai-panel textarea {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 6px;
            resize: vertical;
            min-height: 80px;
            margin-bottom: 10px;
        }

        .ai-panel select {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 6px;
            margin-bottom: 10px;
        }

        .ai-btn {
            width: 100%;
            padding: 12px;
            background: white;
            color: #667eea;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .ai-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .ai-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Button Groups */
        .btn-group {
            display: flex;
            gap: 8px;
        }

        .btn-icon {
            padding: 8px 12px;
            border: 1px solid #e0e0e0;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-icon:hover {
            background: #f5f5f5;
        }

        .btn-icon:active {
            background: #e8eaff;
        }

        /* Font Selector */
        .font-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .font-option {
            padding: 8px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }

        .font-option:hover {
            background: #f5f5f5;
        }

        .font-option.active {
            background: #e8eaff;
            border-color: #667eea;
        }

        /* Messages */
        .message {
            padding: 12px;
            border-radius: 6px;
            margin-top: 10px;
            font-size: 14px;
            text-align: center;
        }

        .message.success {
            background: #d4edda;
            color: #155724;
        }

        .message.error {
            background: #f8d7da;
            color: #721c24;
        }

        .message.loading {
            background: #d1ecf1;
            color: #0c5460;
        }

        /* Image Upload */
        .upload-area {
            border: 2px dashed #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .upload-area:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .upload-area input {
            display: none;
        }

        /* Export Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 12px;
            width: 450px;
            max-width: 90%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-title {
            font-size: 20px;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
            padding: 0;
            width: 30px;
            height: 30px;
        }

        .modal-close:hover {
            color: #000;
        }

        .export-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .export-format-group {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .export-format-btn {
            padding: 15px;
            border: 2px solid #e0e0e0;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            font-weight: 500;
        }

        .export-format-btn:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .export-format-btn.active {
            border-color: #667eea;
            background: #e8eaff;
            color: #667eea;
        }

        .export-resolution-group {
            display: flex;
            gap: 10px;
        }

        .export-resolution-btn {
            flex: 1;
            padding: 10px;
            border: 2px solid #e0e0e0;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }

        .export-resolution-btn:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .export-resolution-btn.active {
            border-color: #667eea;
            background: #e8eaff;
            color: #667eea;
        }

        .export-quality-slider {
            width: 100%;
        }

        .export-btn-primary {
            width: 100%;
            padding: 15px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .export-btn-primary:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .export-btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Inline Text Editor */
        .inline-text-editor {
            position: absolute;
            display: none;
            background: transparent;
            border: 2px solid #667eea;
            outline: none;
            padding: 4px;
            font-family: inherit;
            font-size: inherit;
            color: inherit;
            resize: none;
            overflow: hidden;
            z-index: 100;
            min-width: 50px;
            min-height: 30px;
        }

        .inline-text-editor:focus {
            border-color: #5568d3;
        }

        /* Template Modal */
        .template-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-top: 15px;
        }

        .template-card {
            padding: 20px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .template-card:hover {
            border-color: #667eea;
            background: #f8f9ff;
            transform: translateY(-2px);
        }

        .template-card.active {
            border-color: #667eea;
            background: #e8eaff;
        }

        .template-icon {
            font-size: 32px;
            margin-bottom: 8px;
        }

        .template-name {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 4px;
            color: #333;
        }

        .template-size {
            font-size: 12px;
            color: #666;
        }

        .custom-size-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        /* Template Library */
        .template-filter-btn {
            padding: 8px 16px;
            border: 1px solid #e0e0e0;
            background: white;
            border-radius: 20px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .template-filter-btn:hover {
            background: #f5f5f5;
            border-color: #667eea;
        }

        .template-filter-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .template-library-card {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            height: 240px;
        }

        .template-library-card:hover {
            border-color: #667eea;
            transform: translateY(-4px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
        }

        .template-preview {
            width: 100%;
            height: 150px;
            background: #f5f5f5;
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 48px;
            overflow: hidden;
            position: relative;
        }

        .template-preview img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .template-info {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .template-library-name {
            font-weight: 600;
            font-size: 14px;
            color: #333;
            margin-bottom: 4px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .template-library-desc {
            font-size: 12px;
            color: #666;
            margin-bottom: 8px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .template-meta {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 11px;
            color: #999;
            margin-top: auto;
        }

        .template-category {
            background: #e8eaff;
            color: #667eea;
            padding: 2px 8px;
            border-radius: 10px;
            font-weight: 500;
        }

        /* Keyboard Shortcuts */
        .shortcuts-section {
            padding-bottom: 16px;
            border-bottom: 1px solid #f0f0f0;
        }

        .shortcuts-section:last-child {
            border-bottom: none;
        }

        .shortcuts-title {
            font-size: 16px;
            font-weight: 600;
            color: #333;
            margin-bottom: 12px;
        }

        .shortcuts-list {
            display: grid;
            gap: 10px;
        }

        .shortcut-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            background: #f8f9fa;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .shortcut-item:hover {
            background: #e8eaff;
        }

        .shortcut-keys {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
            color: #667eea;
            font-weight: 500;
        }

        .shortcut-keys kbd {
            background: white;
            border: 1px solid #d0d0d0;
            border-radius: 4px;
            padding: 4px 8px;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Courier New', monospace;
            font-size: 12px;
            box-shadow: 0 2px 0 rgba(0,0,0,0.05);
            color: #333;
            min-width: 28px;
            text-align: center;
        }

        .shortcut-desc {
            font-size: 14px;
            color: #666;
            text-align: right;
        }

        /* Crop Mode */
        .crop-overlay {
            position: absolute;
            border: 2px dashed #667eea;
            background: rgba(102, 126, 234, 0.1);
            cursor: move;
            display: none;
            z-index: 50;
        }

        .crop-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #667eea;
            border: 2px solid white;
            border-radius: 50%;
            cursor: pointer;
        }

        .crop-handle.nw { top: -6px; left: -6px; cursor: nw-resize; }
        .crop-handle.ne { top: -6px; right: -6px; cursor: ne-resize; }
        .crop-handle.sw { bottom: -6px; left: -6px; cursor: sw-resize; }
        .crop-handle.se { bottom: -6px; right: -6px; cursor: se-resize; }

        .crop-actions {
            position: absolute;
            bottom: -45px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            background: white;
            padding: 8px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .crop-actions button {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }

        .crop-actions .apply {
            background: #667eea;
            color: white;
        }

        .crop-actions .cancel {
            background: #e0e0e0;
            color: #333;
        }

        /* P19: Enhanced Crop Controls */
        .crop-controls {
            position: absolute;
            top: -120px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            min-width: 260px;
        }

        .crop-ratio-btns,
        .crop-transform-btns {
            display: flex;
            gap: 6px;
        }

        .crop-ratio-btns button,
        .crop-transform-btns button {
            flex: 1;
            padding: 6px 8px;
            border: 1px solid #e0e0e0;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .crop-ratio-btns button:hover,
        .crop-transform-btns button:hover {
            background: #f5f5f5;
            border-color: #667eea;
        }

        .crop-ratio-btns button.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        /* P24: Page Navigation */
        .page-navigation {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            max-width: calc(100% - 200px);
            z-index: 100;
        }

        .page-nav-btn {
            width: 36px;
            height: 36px;
            border: 2px dashed #667eea;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 20px;
            color: #667eea;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .page-nav-btn:hover {
            background: #667eea;
            color: white;
        }

        .page-thumbnails {
            display: flex;
            gap: 10px;
            overflow-x: auto;
            max-width: 600px;
        }

        .page-thumb {
            position: relative;
            width: 80px;
            height: 60px;
            border: 2px solid #e0e0e0;
            border-radius: 4px;
            cursor: pointer;
            flex-shrink: 0;
            background: white;
            transition: all 0.2s;
        }

        .page-thumb:hover {
            border-color: #667eea;
        }

        .page-thumb.active {
            border-color: #667eea;
            box-shadow: 0 0 0 2px #667eea;
        }

        .page-thumb-canvas {
            width: 100%;
            height: 100%;
            border-radius: 2px;
        }

        .page-thumb-label {
            position: absolute;
            bottom: -20px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 11px;
            color: #666;
        }

        .page-thumb-delete {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 20px;
            height: 20px;
            background: #ff4444;
            color: white;
            border: 2px solid white;
            border-radius: 50%;
            font-size: 12px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .page-thumb:hover .page-thumb-delete {
            display: flex;
        }
    </style>
</head>
<body>
    <div class="canva-layout">
        <!-- Header -->
        <div class="canva-header">
            <div class="header-left">
                <div class="logo">Artify</div>
                <div class="project-name" id="projectName">ÏÉà ÌîÑÎ°úÏ†ùÌä∏</div>
                <!-- P30: Save status indicator -->
                <div id="saveStatus" style="font-size: 12px; color: #999; margin-left: 10px; display: flex; align-items: center; gap: 5px;">
                    <span id="saveStatusText">Ï†ÄÏû•Îê®</span>
                </div>
            </div>
            <div class="header-center">
                <button class="header-btn" onclick="undo()" id="undoBtn" disabled aria-label="Ïã§Ìñâ Ï∑®ÏÜå" title="Ïã§Ìñâ Ï∑®ÏÜå (Ctrl+Z)">
                    ‚Ü∂ Ïã§Ìñâ Ï∑®ÏÜå
                </button>
                <button class="header-btn" onclick="redo()" id="redoBtn" disabled aria-label="Îã§Ïãú Ïã§Ìñâ" title="Îã§Ïãú Ïã§Ìñâ (Ctrl+Y)">
                    ‚Ü∑ Îã§Ïãú Ïã§Ìñâ
                </button>
            </div>
            <div class="header-right">
                <button class="header-btn" onclick="location.href='index.html'" aria-label="ÌîÑÎ°úÏ†ùÌä∏ Î™©Î°ùÏúºÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞">‚Üê Î™©Î°ù</button>
                <button class="header-btn" onclick="showVersionHistoryModal()" aria-label="Î≤ÑÏ†Ñ ÌûàÏä§ÌÜ†Î¶¨">üïê Î≤ÑÏ†Ñ</button>
                <button class="header-btn" onclick="showCollaborateModal()" aria-label="ÌòëÏóÖ">üë• ÌòëÏóÖ</button>
                <button class="header-btn" onclick="showTemplateModal()" aria-label="Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞ Î≥ÄÍ≤Ω">üìê Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞</button>
                <button class="header-btn" onclick="showKeyboardShortcutsModal()" aria-label="ÌÇ§Î≥¥Îìú Îã®Ï∂ïÌÇ§" title="ÌÇ§Î≥¥Îìú Îã®Ï∂ïÌÇ§ (?)">‚å®Ô∏è Îã®Ï∂ïÌÇ§</button>
                <button class="header-btn" onclick="showExportModal()" aria-label="Îã§Ïö¥Î°úÎìú">üì• Îã§Ïö¥Î°úÎìú</button>
                <button class="header-btn primary" onclick="saveProject()" aria-label="ÌîÑÎ°úÏ†ùÌä∏ Ï†ÄÏû•">üíæ Ï†ÄÏû•</button>
                <div id="editor-auth-container" style="display: inline-block; margin-left: 10px;">
                    <button class="btn-login" onclick="AuthUI.showLoginModal()">
                        Î°úÍ∑∏Ïù∏
                    </button>
                </div>
            </div>
        </div>

        <!-- Left Sidebar - Tools -->
        <div class="left-sidebar" role="toolbar" aria-label="ÎèÑÍµ¨ Î™®Ïùå">
            <div class="tool-item active" onclick="setTool('select')" data-tool="select" role="button" aria-label="ÏÑ†ÌÉù ÎèÑÍµ¨" tabindex="0">
                <div>‚¨ú</div>
                <div class="tool-label">ÏÑ†ÌÉù</div>
            </div>
            <div class="tool-item" onclick="setTool('text')" data-tool="text" role="button" aria-label="ÌÖçÏä§Ìä∏ ÎèÑÍµ¨" tabindex="0">
                <div>T</div>
                <div class="tool-label">ÌÖçÏä§Ìä∏</div>
            </div>
            <div class="tool-item" onclick="setTool('rect')" data-tool="rect" role="button" aria-label="ÏÇ¨Í∞ÅÌòï ÎèÑÍµ¨" tabindex="0">
                <div>‚ñ¢</div>
                <div class="tool-label">ÏÇ¨Í∞ÅÌòï</div>
            </div>
            <div class="tool-item" onclick="setTool('circle')" data-tool="circle" role="button" aria-label="Ïõê ÎèÑÍµ¨" tabindex="0">
                <div>‚óã</div>
                <div class="tool-label">Ïõê</div>
            </div>
            <div class="tool-item" onclick="setTool('triangle')" data-tool="triangle" role="button" aria-label="ÏÇºÍ∞ÅÌòï ÎèÑÍµ¨" tabindex="0">
                <div>‚ñ≥</div>
                <div class="tool-label">ÏÇºÍ∞ÅÌòï</div>
            </div>
            <div class="tool-item" onclick="setTool('star')" data-tool="star" role="button" aria-label="Î≥Ñ ÎèÑÍµ¨" tabindex="0">
                <div>‚òÖ</div>
                <div class="tool-label">Î≥Ñ</div>
            </div>
            <div class="tool-item" onclick="setTool('diamond')" data-tool="diamond" role="button" aria-label="Îã§Ïù¥ÏïÑÎ™¨Îìú ÎèÑÍµ¨" tabindex="0">
                <div>‚óÜ</div>
                <div class="tool-label">Îã§Ïù¥ÏïÑÎ™¨Îìú</div>
            </div>
            <div class="tool-item" onclick="setTool('hexagon')" data-tool="hexagon" role="button" aria-label="Ïú°Í∞ÅÌòï ÎèÑÍµ¨" tabindex="0">
                <div>‚¨¢</div>
                <div class="tool-label">Ïú°Í∞ÅÌòï</div>
            </div>
            <div class="tool-item" onclick="setTool('speech-bubble')" data-tool="speech-bubble" role="button" aria-label="ÎßêÌíçÏÑ† ÎèÑÍµ¨" tabindex="0">
                <div>üí¨</div>
                <div class="tool-label">ÎßêÌíçÏÑ†</div>
            </div>
            <div class="tool-item" onclick="setTool('cloud')" data-tool="cloud" role="button" aria-label="Íµ¨Î¶Ñ ÎèÑÍµ¨" tabindex="0">
                <div>‚òÅÔ∏è</div>
                <div class="tool-label">Íµ¨Î¶Ñ</div>
            </div>
            <div class="tool-item" onclick="setTool('line')" data-tool="line" role="button" aria-label="ÏÑ† ÎèÑÍµ¨" tabindex="0">
                <div>‚îÄ</div>
                <div class="tool-label">ÏÑ†</div>
            </div>
            <div class="tool-item" onclick="setTool('arrow')" data-tool="arrow" role="button" aria-label="ÌôîÏÇ¥Ìëú ÎèÑÍµ¨" tabindex="0">
                <div>‚Üí</div>
                <div class="tool-label">ÌôîÏÇ¥Ìëú</div>
            </div>
            <div class="tool-item" onclick="setTool('pencil')" data-tool="pencil" role="button" aria-label="Ìéú ÎèÑÍµ¨" tabindex="0">
                <div>‚úèÔ∏è</div>
                <div class="tool-label">Ìéú</div>
            </div>
            <div class="tool-item" onclick="document.getElementById('imageUpload').click()" role="button" aria-label="Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú" tabindex="0">
                <div>üñºÔ∏è</div>
                <div class="tool-label">Ïù¥ÎØ∏ÏßÄ</div>
            </div>
            <div class="tool-item" onclick="showTemplateLibraryModal()" role="button" aria-label="ÌÖúÌîåÎ¶ø ÎùºÏù¥Î∏åÎü¨Î¶¨" tabindex="0">
                <div>üìã</div>
                <div class="tool-label">ÌÖúÌîåÎ¶ø</div>
            </div>
            <input type="file" id="imageUpload" accept="image/*" style="display:none" onchange="handleImageUpload(event)" aria-label="Ïù¥ÎØ∏ÏßÄ ÌååÏùº ÏÑ†ÌÉù">
        </div>

        <!-- Canvas Area -->
        <div class="canvas-container" id="canvasContainer">
            <div class="canvas-wrapper">
                <canvas id="mainCanvas" width="1200" height="800" role="img" aria-label="ÎîîÏûêÏù∏ Ï∫îÎ≤ÑÏä§"></canvas>
                <textarea id="inlineTextEditor" class="inline-text-editor"></textarea>
                <div id="cropOverlay" class="crop-overlay">
                    <div class="crop-handle nw"></div>
                    <div class="crop-handle ne"></div>
                    <div class="crop-handle sw"></div>
                    <div class="crop-handle se"></div>
                    <!-- P19: Enhanced Crop Controls -->
                    <div class="crop-controls">
                        <div style="margin-bottom: 8px; font-size: 12px; color: #666;">ÎπÑÏú®:</div>
                        <div class="crop-ratio-btns">
                            <button onclick="setCropRatio('free')">ÏûêÏú†</button>
                            <button onclick="setCropRatio('1:1')">1:1</button>
                            <button onclick="setCropRatio('16:9')">16:9</button>
                            <button onclick="setCropRatio('4:3')">4:3</button>
                            <button onclick="setCropRatio('3:2')">3:2</button>
                        </div>
                        <div style="margin-top: 10px; margin-bottom: 8px; font-size: 12px; color: #666;">Î≥ÄÌòï:</div>
                        <div class="crop-transform-btns">
                            <button onclick="rotateImage(-90)" title="ÏôºÏ™Ω 90¬∞ ÌöåÏ†Ñ">‚Ü∂</button>
                            <button onclick="rotateImage(90)" title="Ïò§Î•∏Ï™Ω 90¬∞ ÌöåÏ†Ñ">‚Ü∑</button>
                            <button onclick="flipImage('horizontal')" title="Ï¢åÏö∞ Îí§ÏßëÍ∏∞">‚Üî</button>
                            <button onclick="flipImage('vertical')" title="ÏÉÅÌïò Îí§ÏßëÍ∏∞">‚Üï</button>
                        </div>
                    </div>
                    <div class="crop-actions">
                        <button class="apply" onclick="applyCrop()">‚úì Ï†ÅÏö©</button>
                        <button class="cancel" onclick="cancelCrop()">‚úï Ï∑®ÏÜå</button>
                    </div>
                </div>
            </div>
            <!-- P16: Zoom Controls -->
            <div class="zoom-controls">
                <button class="zoom-btn" onclick="zoomOut()" title="Ï∂ïÏÜå (Ctrl + -)">‚àí</button>
                <div class="zoom-level" id="zoomLevel">100%</div>
                <button class="zoom-btn" onclick="zoomIn()" title="ÌôïÎåÄ (Ctrl + +)">+</button>
                <button class="zoom-btn" onclick="fitToScreen()" title="ÌôîÎ©¥Ïóê ÎßûÏ∂§ (Ctrl + 0)" style="font-size: 14px;">‚ä°</button>
            </div>

            <!-- P24: Page Navigation -->
            <div class="page-navigation">
                <button class="page-nav-btn" onclick="addNewPage()" title="ÏÉà ÌéòÏù¥ÏßÄ">+</button>
                <div class="page-thumbnails" id="pageThumbnails"></div>
            </div>
        </div>

        <!-- Right Properties Panel -->
        <div class="properties-panel">
            <!-- AI Generation -->
            <div class="ai-panel">
                <div class="panel-title" style="color: white; margin-bottom: 10px;">ü§ñ AI Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ±</div>
                <textarea id="aiPrompt" placeholder="ÏõêÌïòÎäî Ïù¥ÎØ∏ÏßÄÎ•º ÏÑ§Î™ÖÌïòÏÑ∏Ïöî..."></textarea>
                <select id="aiSize">
                    <option value="1024x1024">Ï†ïÏÇ¨Í∞ÅÌòï (1024x1024)</option>
                    <option value="1792x1024">Í∞ÄÎ°úÌòï (1792x1024)</option>
                    <option value="1024x1792">ÏÑ∏Î°úÌòï (1024x1792)</option>
                </select>
                <button class="ai-btn" onclick="generateAIImage()" id="aiBtn">Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ±</button>
                <div id="aiMessage"></div>
            </div>

            <!-- Element Properties -->
            <div class="panel-section" id="elementProps" style="display:none;">
                <div class="panel-title">ÏöîÏÜå ÏÜçÏÑ±</div>

                <div class="panel-group">
                    <label class="panel-label">ÏúÑÏπò X</label>
                    <input type="number" class="panel-input" id="propX" oninput="updateElementProp('x', this.value)">
                </div>

                <div class="panel-group">
                    <label class="panel-label">ÏúÑÏπò Y</label>
                    <input type="number" class="panel-input" id="propY" oninput="updateElementProp('y', this.value)">
                </div>

                <div class="panel-group">
                    <label class="panel-label">ÎÑàÎπÑ</label>
                    <input type="number" class="panel-input" id="propWidth" oninput="updateElementProp('width', this.value)">
                </div>

                <div class="panel-group">
                    <label class="panel-label">ÎÜíÏù¥</label>
                    <input type="number" class="panel-input" id="propHeight" oninput="updateElementProp('height', this.value)">
                </div>

                <div class="panel-group">
                    <label class="panel-label">ÌöåÏ†Ñ (ÎèÑ)</label>
                    <div class="slider-group">
                        <input type="range" min="0" max="360" value="0" id="propRotation" oninput="updateElementProp('rotation', this.value)">
                        <span class="slider-value" id="rotationValue">0¬∞</span>
                    </div>
                </div>

                <div class="panel-group">
                    <label class="panel-label">Î∂àÌà¨Î™ÖÎèÑ</label>
                    <div class="slider-group">
                        <input type="range" min="0" max="100" value="100" id="propOpacity" oninput="updateElementProp('opacity', this.value)">
                        <span class="slider-value" id="opacityValue">100%</span>
                    </div>
                </div>

                <!-- P21: Blend Mode -->
                <div class="panel-group">
                    <label class="panel-label">Î∏îÎ†åÎìú Î™®Îìú</label>
                    <select class="panel-input" id="propBlendMode" onchange="updateElementProp('blendMode', this.value)">
                        <option value="source-over">Normal</option>
                        <option value="multiply">Multiply</option>
                        <option value="screen">Screen</option>
                        <option value="overlay">Overlay</option>
                        <option value="darken">Darken</option>
                        <option value="lighten">Lighten</option>
                        <option value="color-dodge">Color Dodge</option>
                        <option value="color-burn">Color Burn</option>
                        <option value="hard-light">Hard Light</option>
                        <option value="soft-light">Soft Light</option>
                        <option value="difference">Difference</option>
                        <option value="exclusion">Exclusion</option>
                        <option value="hue">Hue</option>
                        <option value="saturation">Saturation</option>
                        <option value="color">Color</option>
                        <option value="luminosity">Luminosity</option>
                    </select>
                </div>

                <!-- P23: Style Library -->
                <div class="panel-group" style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #e0e0e0;">
                    <div class="panel-title" style="font-size: 13px; margin-bottom: 10px;">Ïä§ÌÉÄÏùº Í¥ÄÎ¶¨</div>
                    <div class="btn-group">
                        <button class="btn-icon" onclick="saveCurrentStyle()" style="flex: 1; font-size: 12px;">üíæ Ïä§ÌÉÄÏùº Ï†ÄÏû•</button>
                        <button class="btn-icon" onclick="showStylesModal()" style="flex: 1; font-size: 12px;">üé® Ïä§ÌÉÄÏùº Ï†ÅÏö©</button>
                    </div>
                </div>
            </div>

            <!-- Text Properties -->
            <div class="panel-section" id="textProps" style="display:none;">
                <div class="panel-title">ÌÖçÏä§Ìä∏ ÏÜçÏÑ±</div>

                <div class="panel-group">
                    <label class="panel-label">ÎÇ¥Ïö©</label>
                    <input type="text" class="panel-input" id="propText" oninput="updateElementProp('text', this.value)">
                </div>

                <div class="panel-group">
                    <label class="panel-label">Ìè∞Ìä∏</label>
                    <select class="panel-input" id="propFont" onchange="updateElementProp('fontFamily', this.value)">
                        <option value="Arial">Arial</option>
                        <option value="Georgia">Georgia</option>
                        <option value="Times New Roman">Times New Roman</option>
                        <option value="Courier New">Courier New</option>
                        <option value="Verdana">Verdana</option>
                        <option value="Comic Sans MS">Comic Sans MS</option>
                    </select>
                </div>

                <div class="panel-group">
                    <label class="panel-label">ÌÅ¨Í∏∞</label>
                    <div class="slider-group">
                        <input type="range" min="8" max="120" value="24" id="propFontSize" oninput="updateElementProp('fontSize', this.value)">
                        <span class="slider-value" id="fontSizeValue">24px</span>
                    </div>
                </div>

                <div class="panel-group">
                    <label class="panel-label">Ïä§ÌÉÄÏùº</label>
                    <div class="btn-group">
                        <button class="btn-icon" onclick="toggleTextStyle('bold')" id="btnBold">
                            <strong>B</strong>
                        </button>
                        <button class="btn-icon" onclick="toggleTextStyle('italic')" id="btnItalic">
                            <em>I</em>
                        </button>
                        <button class="btn-icon" onclick="toggleTextStyle('underline')" id="btnUnderline">
                            <u>U</u>
                        </button>
                    </div>
                </div>

                <div class="panel-group">
                    <label class="panel-label">Ï†ïÎ†¨</label>
                    <div class="btn-group">
                        <button class="btn-icon" onclick="updateElementProp('textAlign', 'left')">‚¨ÖÔ∏è</button>
                        <button class="btn-icon" onclick="updateElementProp('textAlign', 'center')">‚ÜîÔ∏è</button>
                        <button class="btn-icon" onclick="updateElementProp('textAlign', 'right')">‚û°Ô∏è</button>
                    </div>
                </div>

                <!-- P22: Advanced Text Properties -->
                <div class="panel-group">
                    <label class="panel-label">Ï§ÑÍ∞ÑÍ≤©</label>
                    <div class="slider-group">
                        <input type="range" min="0.5" max="3" step="0.1" value="1.2" id="propLineHeight" oninput="updateElementProp('lineHeight', this.value)">
                        <span class="slider-value" id="lineHeightValue">1.2</span>
                    </div>
                </div>

                <div class="panel-group">
                    <label class="panel-label">ÏûêÍ∞Ñ</label>
                    <div class="slider-group">
                        <input type="range" min="-10" max="20" step="0.5" value="0" id="propLetterSpacing" oninput="updateElementProp('letterSpacing', this.value)">
                        <span class="slider-value" id="letterSpacingValue">0px</span>
                    </div>
                </div>

                <div class="panel-group">
                    <label class="panel-label">
                        <input type="checkbox" id="textShadowEnabled" onchange="toggleTextShadow(this.checked)">
                        ÌÖçÏä§Ìä∏ Í∑∏Î¶ºÏûê
                    </label>
                </div>

                <div id="textShadowControls" style="display:none;">
                    <div class="panel-group">
                        <label class="panel-label">X Ïò§ÌîÑÏÖã</label>
                        <div class="slider-group">
                            <input type="range" min="-20" max="20" value="2" id="shadowOffsetX" oninput="updateTextShadow('offsetX', this.value)">
                            <span class="slider-value" id="shadowXValue">2px</span>
                        </div>
                    </div>

                    <div class="panel-group">
                        <label class="panel-label">Y Ïò§ÌîÑÏÖã</label>
                        <div class="slider-group">
                            <input type="range" min="-20" max="20" value="2" id="shadowOffsetY" oninput="updateTextShadow('offsetY', this.value)">
                            <span class="slider-value" id="shadowYValue">2px</span>
                        </div>
                    </div>

                    <div class="panel-group">
                        <label class="panel-label">Î∏îÎü¨ Î∞òÍ≤Ω</label>
                        <div class="slider-group">
                            <input type="range" min="0" max="20" value="4" id="shadowBlur" oninput="updateTextShadow('blur', this.value)">
                            <span class="slider-value" id="shadowBlurValue">4px</span>
                        </div>
                    </div>

                    <div class="panel-group">
                        <label class="panel-label">Í∑∏Î¶ºÏûê ÏÉâÏÉÅ</label>
                        <input type="color" class="panel-input" id="shadowColor" value="#000000" onchange="updateTextShadow('color', this.value)">
                    </div>
                </div>
            </div>

            <!-- Image Filter Properties -->
            <div class="panel-section" id="imageProps" style="display:none;">
                <div class="panel-title">Ïù¥ÎØ∏ÏßÄ ÌïÑÌÑ∞</div>

                <div class="panel-group">
                    <label class="panel-label">Grayscale</label>
                    <div class="slider-group">
                        <input type="range" min="0" max="100" value="0" id="filterGrayscale" oninput="updateImageFilter('grayscale', this.value)">
                        <span class="slider-value" id="grayscaleValue">0%</span>
                    </div>
                </div>

                <div class="panel-group">
                    <label class="panel-label">Sepia</label>
                    <div class="slider-group">
                        <input type="range" min="0" max="100" value="0" id="filterSepia" oninput="updateImageFilter('sepia', this.value)">
                        <span class="slider-value" id="sepiaValue">0%</span>
                    </div>
                </div>

                <div class="panel-group">
                    <label class="panel-label">Blur</label>
                    <div class="slider-group">
                        <input type="range" min="0" max="10" value="0" id="filterBlur" oninput="updateImageFilter('blur', this.value)">
                        <span class="slider-value" id="blurValue">0px</span>
                    </div>
                </div>

                <div class="panel-group">
                    <label class="panel-label">Brightness</label>
                    <div class="slider-group">
                        <input type="range" min="0" max="200" value="100" id="filterBrightness" oninput="updateImageFilter('brightness', this.value)">
                        <span class="slider-value" id="brightnessValue">100%</span>
                    </div>
                </div>

                <div class="btn-group" style="margin-top: 10px;">
                    <button class="btn-icon" onclick="resetImageFilters()" style="flex: 1;">ÌïÑÌÑ∞ Ï¥àÍ∏∞Ìôî</button>
                    <button class="btn-icon" onclick="startCropMode()" style="flex: 1;" id="cropBtn">‚úÇÔ∏è ÌÅ¨Î°≠</button>
                </div>

                <!-- AI Features (P13) -->
                <div class="panel-title" style="margin-top: 15px;">AI Í∏∞Îä•</div>
                <button class="btn-icon" onclick="removeBackground()" style="width: 100%; margin-bottom: 8px;">üé® Î∞∞Í≤Ω Ï†úÍ±∞</button>
                <button class="btn-icon" onclick="upscaleImage()" style="width: 100%; margin-bottom: 8px;">‚¨ÜÔ∏è Í≥†Ìï¥ÏÉÅÎèÑ Î≥ÄÌôò</button>
                <button class="btn-icon" onclick="showStyleTransferModal()" style="width: 100%;">üñºÔ∏è Ïä§ÌÉÄÏùº Î≥ÄÌôò</button>
            </div>

            <!-- Color Properties -->
            <div class="panel-section">
                <div class="panel-title">ÏÉâÏÉÅ</div>

                <div class="panel-group">
                    <label class="panel-label">Ï±ÑÏö∞Í∏∞</label>
                    <input type="color" class="panel-input" id="propFill" value="#667eea" onchange="updateElementProp('fill', this.value)">
                </div>

                <div class="color-grid">
                    <div class="color-swatch" style="background: #667eea" onclick="setColor('#667eea')"></div>
                    <div class="color-swatch" style="background: #764ba2" onclick="setColor('#764ba2')"></div>
                    <div class="color-swatch" style="background: #f093fb" onclick="setColor('#f093fb')"></div>
                    <div class="color-swatch" style="background: #4facfe" onclick="setColor('#4facfe')"></div>
                    <div class="color-swatch" style="background: #43e97b" onclick="setColor('#43e97b')"></div>
                    <div class="color-swatch" style="background: #fa709a" onclick="setColor('#fa709a')"></div>
                    <div class="color-swatch" style="background: #fee140" onclick="setColor('#fee140')"></div>
                    <div class="color-swatch" style="background: #30cfd0" onclick="setColor('#30cfd0')"></div>
                    <div class="color-swatch" style="background: #ff6b6b" onclick="setColor('#ff6b6b')"></div>
                    <div class="color-swatch" style="background: #4ecdc4" onclick="setColor('#4ecdc4')"></div>
                    <div class="color-swatch" style="background: #45b7d1" onclick="setColor('#45b7d1')"></div>
                    <div class="color-swatch" style="background: #96ceb4" onclick="setColor('#96ceb4')"></div>
                </div>

                <!-- Brand Kit (P14) -->
                <div class="panel-title" style="margin-top: 15px;">Î∏åÎûúÎìú ÌÇ∑</div>
                <div class="btn-group">
                    <button class="btn-icon" onclick="saveBrandColor()" style="flex: 1;">üíæ ÌòÑÏû¨ ÏÉâÏÉÅ Ï†ÄÏû•</button>
                    <button class="btn-icon" onclick="showBrandColors()" style="flex: 1;">üé® Î∏åÎûúÎìú ÏÉâÏÉÅ</button>
                </div>
                <div id="brandColorGrid" class="color-grid" style="display: none; margin-top: 10px;">
                    <!-- Brand colors will be populated here -->
                </div>

                <div class="panel-group" style="margin-top: 15px;">
                    <label class="panel-label">ÌÖåÎëêÎ¶¨ ÏÉâÏÉÅ</label>
                    <input type="color" class="panel-input" id="propStroke" value="#000000" onchange="updateElementProp('stroke', this.value)">
                </div>

                <div class="panel-group">
                    <label class="panel-label">ÌÖåÎëêÎ¶¨ ÎëêÍªò</label>
                    <div class="slider-group">
                        <input type="range" min="0" max="20" value="2" id="propStrokeWidth" oninput="updateElementProp('strokeWidth', this.value)">
                        <span class="slider-value" id="strokeValue">2px</span>
                    </div>
                </div>

                <div class="panel-group" id="gradientSection" style="display:none;">
                    <label class="panel-label">
                        <input type="checkbox" id="gradientEnabled" onchange="toggleGradient(this.checked)">
                        Í∑∏ÎùºÎç∞Ïù¥ÏÖò Ï±ÑÏö∞Í∏∞
                    </label>
                </div>

                <div id="gradientControls" style="display:none;">
                    <!-- P26: Gradient type selector -->
                    <div class="panel-group">
                        <label class="panel-label">Í∑∏ÎùºÎç∞Ïù¥ÏÖò ÌÉÄÏûÖ</label>
                        <select class="panel-input" id="gradientType" onchange="updateGradient('type', this.value)">
                            <option value="linear">ÏÑ†Ìòï (Linear)</option>
                            <option value="radial">ÏõêÌòï (Radial)</option>
                        </select>
                    </div>

                    <div class="panel-group">
                        <label class="panel-label">ÏãúÏûë ÏÉâÏÉÅ</label>
                        <input type="color" class="panel-input" id="gradientColor1" value="#667eea" onchange="updateGradient('color1', this.value)">
                    </div>

                    <div class="panel-group">
                        <label class="panel-label">Ï§ëÍ∞Ñ ÏÉâÏÉÅ (ÏÑ†ÌÉù)</label>
                        <input type="color" class="panel-input" id="gradientColor2" value="#a855f7" onchange="updateGradient('color2', this.value)">
                        <label style="font-size: 11px; margin-top: 4px;">
                            <input type="checkbox" id="gradientMiddleEnabled" onchange="toggleGradientMiddleColor(this.checked)">
                            Ï§ëÍ∞Ñ ÏÉâÏÉÅ ÏÇ¨Ïö©
                        </label>
                    </div>

                    <div class="panel-group">
                        <label class="panel-label">ÎÅù ÏÉâÏÉÅ</label>
                        <input type="color" class="panel-input" id="gradientColor3" value="#764ba2" onchange="updateGradient('color3', this.value)">
                    </div>

                    <!-- Linear gradient controls -->
                    <div class="panel-group" id="gradientAngleGroup">
                        <label class="panel-label">Í∞ÅÎèÑ</label>
                        <div class="slider-group">
                            <input type="range" min="0" max="360" value="0" id="gradientAngle" oninput="updateGradient('angle', this.value)">
                            <span class="slider-value" id="angleValue">0¬∞</span>
                        </div>
                    </div>

                    <!-- Radial gradient controls -->
                    <div id="radialGradientControls" style="display:none;">
                        <div class="panel-group">
                            <label class="panel-label">Î∞òÏßÄÎ¶Ñ</label>
                            <div class="slider-group">
                                <input type="range" min="0.1" max="1.5" step="0.1" value="0.7" id="radialRadius" oninput="updateGradient('radius', this.value)">
                                <span class="slider-value" id="radiusValue">0.7</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- P27: Drop Shadow -->
                <div class="panel-group" id="dropShadowSection" style="display:none; margin-top: 15px;">
                    <label class="panel-label">
                        <input type="checkbox" id="dropShadowEnabled" onchange="toggleDropShadow(this.checked)">
                        ÎìúÎ°≠ Í∑∏Î¶ºÏûê
                    </label>
                </div>

                <div id="dropShadowControls" style="display:none;">
                    <div class="panel-group">
                        <label class="panel-label">Í∞ÄÎ°ú Ïò§ÌîÑÏÖã</label>
                        <div class="slider-group">
                            <input type="range" min="-50" max="50" value="4" id="dropShadowX" oninput="updateDropShadow('offsetX', this.value)">
                            <span class="slider-value" id="dropShadowXValue">4px</span>
                        </div>
                    </div>

                    <div class="panel-group">
                        <label class="panel-label">ÏÑ∏Î°ú Ïò§ÌîÑÏÖã</label>
                        <div class="slider-group">
                            <input type="range" min="-50" max="50" value="4" id="dropShadowY" oninput="updateDropShadow('offsetY', this.value)">
                            <span class="slider-value" id="dropShadowYValue">4px</span>
                        </div>
                    </div>

                    <div class="panel-group">
                        <label class="panel-label">Î∏îÎü¨</label>
                        <div class="slider-group">
                            <input type="range" min="0" max="50" value="8" id="dropShadowBlur" oninput="updateDropShadow('blur', this.value)">
                            <span class="slider-value" id="dropShadowBlurValue">8px</span>
                        </div>
                    </div>

                    <div class="panel-group">
                        <label class="panel-label">Í∑∏Î¶ºÏûê ÏÉâÏÉÅ</label>
                        <input type="color" class="panel-input" id="dropShadowColor" value="#000000" onchange="updateDropShadow('color', this.value)">
                        <label style="font-size: 11px; margin-top: 4px;">
                            <span>Ìà¨Î™ÖÎèÑ</span>
                            <input type="range" min="0" max="100" value="30" id="dropShadowOpacity" oninput="updateDropShadow('opacity', this.value)" style="width: 100%; margin-top: 4px;">
                            <span id="dropShadowOpacityValue">30%</span>
                        </label>
                    </div>
                </div>
            </div>

            <!-- Layers -->
            <div class="panel-section">
                <div class="panel-title">Î†àÏù¥Ïñ¥</div>
                <!-- P17: Search & Filter -->
                <div style="margin-bottom: 10px;">
                    <input type="text" id="layerSearch" class="panel-input" placeholder="Î†àÏù¥Ïñ¥ Í≤ÄÏÉâ..." oninput="filterLayers()" style="margin-bottom: 8px;">
                    <div class="btn-group">
                        <button class="filter-btn" id="filterAll" onclick="setLayerFilter('all')">Ï†ÑÏ≤¥</button>
                        <button class="filter-btn" id="filterText" onclick="setLayerFilter('text')">ÌÖçÏä§Ìä∏</button>
                        <button class="filter-btn" id="filterImage" onclick="setLayerFilter('image')">Ïù¥ÎØ∏ÏßÄ</button>
                        <button class="filter-btn" id="filterShape" onclick="setLayerFilter('shape')">ÎèÑÌòï</button>
                    </div>
                </div>
                <div class="layers-list" id="layersList">
                    <div style="padding: 20px; text-align: center; color: #999;">
                        ÏöîÏÜåÎ•º Ï∂îÍ∞ÄÌïòÏÑ∏Ïöî
                    </div>
                </div>
                <div class="btn-group" style="margin-top: 10px;">
                    <button class="btn-icon" onclick="moveLayer('up')" style="flex:1">‚Üë ÏúÑÎ°ú</button>
                    <button class="btn-icon" onclick="moveLayer('down')" style="flex:1">‚Üì ÏïÑÎûòÎ°ú</button>
                    <button class="btn-icon" onclick="deleteSelected()" style="flex:1">üóëÔ∏è ÏÇ≠Ï†ú</button>
                </div>
            </div>

            <!-- Alignment Tools -->
            <div class="panel-section">
                <div class="panel-title">Ï†ïÎ†¨</div>
                <div class="btn-group">
                    <button class="btn-icon" onclick="alignElements('left')" title="ÏôºÏ™Ω Ï†ïÎ†¨">‚¨ÖÔ∏è</button>
                    <button class="btn-icon" onclick="alignElements('center')" title="Ï§ëÏïô Ï†ïÎ†¨">‚ÜîÔ∏è</button>
                    <button class="btn-icon" onclick="alignElements('right')" title="Ïò§Î•∏Ï™Ω Ï†ïÎ†¨">‚û°Ô∏è</button>
                </div>
                <div class="btn-group" style="margin-top: 8px;">
                    <button class="btn-icon" onclick="alignElements('top')" title="ÏúÑÏ™Ω Ï†ïÎ†¨">‚¨ÜÔ∏è</button>
                    <button class="btn-icon" onclick="alignElements('middle')" title="Ï§ëÍ∞Ñ Ï†ïÎ†¨">‚ÜïÔ∏è</button>
                    <button class="btn-icon" onclick="alignElements('bottom')" title="ÏïÑÎûòÏ™Ω Ï†ïÎ†¨">‚¨áÔ∏è</button>
                </div>
            </div>

            <!-- Animation (P12) -->
            <div class="panel-section" id="animationProps" style="display:none;">
                <div class="panel-title">Ïï†ÎãàÎ©îÏù¥ÏÖò</div>

                <div class="panel-group">
                    <label class="panel-label">Ïï†ÎãàÎ©îÏù¥ÏÖò Ïú†Ìòï</label>
                    <select class="panel-input" id="animationType" onchange="updateAnimation('type', this.value)">
                        <option value="none">ÏóÜÏùå</option>
                        <option value="fadeIn">Fade In</option>
                        <option value="fadeOut">Fade Out</option>
                        <option value="slideLeft">Slide Left</option>
                        <option value="slideRight">Slide Right</option>
                        <option value="slideUp">Slide Up</option>
                        <option value="slideDown">Slide Down</option>
                        <option value="bounce">Bounce</option>
                        <option value="pulse">Pulse</option>
                    </select>
                </div>

                <div class="panel-group">
                    <label class="panel-label">ÏßÄÏÜçÏãúÍ∞Ñ (Ï¥à)</label>
                    <div class="slider-group">
                        <input type="range" min="0.1" max="5" step="0.1" value="1" id="animationDuration" oninput="updateAnimation('duration', this.value)">
                        <span class="slider-value" id="durationValue">1.0s</span>
                    </div>
                </div>

                <div class="panel-group">
                    <label class="panel-label">ÏßÄÏó∞ (Ï¥à)</label>
                    <div class="slider-group">
                        <input type="range" min="0" max="3" step="0.1" value="0" id="animationDelay" oninput="updateAnimation('delay', this.value)">
                        <span class="slider-value" id="delayValue">0.0s</span>
                    </div>
                </div>

                <button class="btn-icon" onclick="previewAnimation()" style="width: 100%;">‚ñ∂Ô∏è ÎØ∏Î¶¨Î≥¥Í∏∞</button>
            </div>

            <div id="saveMessage"></div>
        </div>
    </div>

    <!-- Export Modal -->
    <div class="modal-overlay" id="exportModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">ÌîÑÎ°úÏ†ùÌä∏ ÎÇ¥Î≥¥ÎÇ¥Í∏∞</h2>
                <button class="modal-close" onclick="closeExportModal()">√ó</button>
            </div>

            <div class="export-options">
                <div class="panel-group">
                    <label class="panel-label">ÌååÏùº Ïù¥Î¶Ñ</label>
                    <input type="text" class="panel-input" id="exportFileName" value="artify-design">
                </div>

                <div class="panel-group">
                    <label class="panel-label">Ìè¨Îß∑ ÏÑ†ÌÉù</label>
                    <div class="export-format-group">
                        <button class="export-format-btn active" onclick="selectExportFormat('png')" id="formatPng">
                            PNG
                        </button>
                        <button class="export-format-btn" onclick="selectExportFormat('jpg')" id="formatJpg">
                            JPG
                        </button>
                        <button class="export-format-btn" onclick="selectExportFormat('svg')" id="formatSvg">
                            SVG
                        </button>
                    </div>
                </div>

                <div class="panel-group" id="resolutionGroup">
                    <label class="panel-label">Ìï¥ÏÉÅÎèÑ</label>
                    <div class="export-resolution-group">
                        <button class="export-resolution-btn active" onclick="selectExportResolution(1)" id="res1x">
                            1x<br><small>ÌëúÏ§Ä</small>
                        </button>
                        <button class="export-resolution-btn" onclick="selectExportResolution(2)" id="res2x">
                            2x<br><small>Î†àÌã∞ÎÇò</small>
                        </button>
                        <button class="export-resolution-btn" onclick="selectExportResolution(3)" id="res3x">
                            3x<br><small>Í≥†Ìï¥ÏÉÅÎèÑ</small>
                        </button>
                    </div>
                </div>

                <div class="panel-group" id="qualityGroup" style="display:none;">
                    <label class="panel-label">ÌíàÏßà <span id="qualityValue">90%</span></label>
                    <input type="range" min="10" max="100" value="90" class="export-quality-slider" id="exportQuality" oninput="updateQualityLabel(this.value)">
                </div>

                <button class="export-btn-primary" onclick="executeExport()">
                    Îã§Ïö¥Î°úÎìú
                </button>
            </div>
        </div>
    </div>

    <!-- Template Modal -->
    <div class="modal-overlay" id="templateModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞ ÏÑ†ÌÉù</h2>
                <button class="modal-close" onclick="closeTemplateModal()">√ó</button>
            </div>

            <div class="export-options">
                <div class="template-grid">
                    <div class="template-card" onclick="selectTemplate('instagram-post')">
                        <div class="template-icon">üì∑</div>
                        <div class="template-name">Instagram Ìè¨Ïä§Ìä∏</div>
                        <div class="template-size">1080 √ó 1080</div>
                    </div>

                    <div class="template-card" onclick="selectTemplate('instagram-story')">
                        <div class="template-icon">üì±</div>
                        <div class="template-name">Instagram Ïä§ÌÜ†Î¶¨</div>
                        <div class="template-size">1080 √ó 1920</div>
                    </div>

                    <div class="template-card" onclick="selectTemplate('facebook-post')">
                        <div class="template-icon">üë•</div>
                        <div class="template-name">Facebook Ìè¨Ïä§Ìä∏</div>
                        <div class="template-size">1200 √ó 630</div>
                    </div>

                    <div class="template-card" onclick="selectTemplate('twitter-post')">
                        <div class="template-icon">üê¶</div>
                        <div class="template-name">Twitter Ìè¨Ïä§Ìä∏</div>
                        <div class="template-size">1024 √ó 512</div>
                    </div>

                    <div class="template-card" onclick="selectTemplate('linkedin-post')">
                        <div class="template-icon">üíº</div>
                        <div class="template-name">LinkedIn Ìè¨Ïä§Ìä∏</div>
                        <div class="template-size">1200 √ó 627</div>
                    </div>

                    <div class="template-card" onclick="selectTemplate('youtube-thumbnail')">
                        <div class="template-icon">‚ñ∂Ô∏è</div>
                        <div class="template-name">YouTube Ïç∏ÎÑ§Ïùº</div>
                        <div class="template-size">1280 √ó 720</div>
                    </div>

                    <div class="template-card" onclick="selectTemplate('presentation')">
                        <div class="template-icon">üìä</div>
                        <div class="template-name">ÌîÑÎ†àÏ††ÌÖåÏù¥ÏÖò</div>
                        <div class="template-size">1920 √ó 1080</div>
                    </div>

                    <div class="template-card" onclick="selectTemplate('a4-portrait')">
                        <div class="template-icon">üìÑ</div>
                        <div class="template-name">A4 ÏÑ∏Î°ú</div>
                        <div class="template-size">2480 √ó 3508</div>
                    </div>
                </div>

                <div class="panel-group" style="margin-top: 20px;">
                    <label class="panel-label">Ïª§Ïä§ÌÖÄ ÌÅ¨Í∏∞</label>
                    <div class="custom-size-inputs">
                        <div>
                            <input type="number" class="panel-input" id="customWidth" placeholder="ÎÑàÎπÑ" value="1200">
                        </div>
                        <div>
                            <input type="number" class="panel-input" id="customHeight" placeholder="ÎÜíÏù¥" value="800">
                        </div>
                    </div>
                </div>

                <button class="export-btn-primary" onclick="applyTemplate()">
                    Ï†ÅÏö©
                </button>
            </div>
        </div>
    </div>

    <!-- Collaborate Modal (P11) -->
    <div class="modal-overlay" id="collaborateModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">ÌîÑÎ°úÏ†ùÌä∏ ÌòëÏóÖ</h2>
                <button class="modal-close" onclick="closeCollaborateModal()">√ó</button>
            </div>

            <div class="export-options">
                <div class="panel-group">
                    <label class="panel-label">Í≥µÏú† ÎßÅÌÅ¨</label>
                    <div style="display: flex; gap: 8px;">
                        <input type="text" class="panel-input" id="shareLink" readonly value="ÎßÅÌÅ¨ ÏÉùÏÑ± Ï§ë...">
                        <button class="btn-icon" onclick="copyShareLink()" style="width: auto; padding: 8px 16px;">Î≥µÏÇ¨</button>
                    </div>
                </div>

                <div class="panel-group">
                    <label class="panel-label">ÌòëÏóÖÏûê Í∂åÌïú</label>
                    <select class="panel-input" id="sharePermission">
                        <option value="view">Î≥¥Í∏∞Îßå Í∞ÄÎä•</option>
                        <option value="edit">Ìé∏Ïßë Í∞ÄÎä•</option>
                    </select>
                </div>

                <button class="export-btn-primary" onclick="generateShareLink()">
                    Í≥µÏú† ÎßÅÌÅ¨ ÏÉùÏÑ±
                </button>

                <div style="margin-top: 20px; padding: 12px; background: #f8f9ff; border-radius: 8px; font-size: 13px; color: #666;">
                    üí° ÏÉùÏÑ±Îêú ÎßÅÌÅ¨Î•º ÌòëÏóÖÏûêÏóêÍ≤å Ï†ÑÎã¨ÌïòÏó¨ Ìï®Íªò Ìé∏ÏßëÌï† Ïàò ÏûàÏäµÎãàÎã§.
                </div>
            </div>
        </div>
    </div>

    <!-- P23: Style Library Modal -->
    <div class="modal-overlay" id="stylesModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Ï†ÄÏû•Îêú Ïä§ÌÉÄÏùº</h2>
                <button class="modal-close" onclick="closeStylesModal()">√ó</button>
            </div>

            <div class="export-options">
                <div id="savedStylesList" style="max-height: 400px; overflow-y: auto;"></div>

                <div style="margin-top: 20px; padding: 12px; background: #f8f9ff; border-radius: 8px; font-size: 13px; color: #666;">
                    üí° ÌÅ¥Î¶≠ÌïòÏó¨ Ïä§ÌÉÄÏùº Ï†ÅÏö© | ÎçîÎ∏îÌÅ¥Î¶≠ÌïòÏó¨ ÏÇ≠Ï†ú
                </div>
            </div>
        </div>
    </div>

    <!-- P25: Version History Modal -->
    <div class="modal-overlay" id="versionHistoryModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Î≤ÑÏ†Ñ ÌûàÏä§ÌÜ†Î¶¨</h2>
                <button class="modal-close" onclick="closeVersionHistoryModal()">√ó</button>
            </div>

            <div class="export-options">
                <div id="versionsList" style="max-height: 400px; overflow-y: auto;"></div>

                <div style="margin-top: 20px; padding: 12px; background: #f8f9ff; border-radius: 8px; font-size: 13px; color: #666;">
                    üí° ÌÅ¥Î¶≠ÌïòÏó¨ Î≤ÑÏ†Ñ Î≥µÏõê | ÏûêÎèô Ï†ÄÏû• Ï£ºÍ∏∞: 5Î∂Ñ
                </div>
            </div>
        </div>
    </div>

    <!-- Template Library Modal -->
    <div class="modal-overlay" id="templateLibraryModal">
        <div class="modal-content" style="max-width: 900px; height: 80vh;">
            <div class="modal-header">
                <h2 class="modal-title">üìã ÌÖúÌîåÎ¶ø ÎùºÏù¥Î∏åÎü¨Î¶¨</h2>
                <button class="modal-close" onclick="closeTemplateLibraryModal()">√ó</button>
            </div>

            <div class="export-options" style="height: calc(100% - 60px); overflow: hidden; display: flex; flex-direction: column;">
                <!-- Category Filters -->
                <div style="margin-bottom: 20px; display: flex; gap: 8px; flex-wrap: wrap;">
                    <button class="template-filter-btn active" onclick="filterTemplates('all')">Ï†ÑÏ≤¥</button>
                    <button class="template-filter-btn" onclick="filterTemplates('social')">ÏÜåÏÖú ÎØ∏ÎîîÏñ¥</button>
                    <button class="template-filter-btn" onclick="filterTemplates('banner')">Î∞∞ÎÑà</button>
                    <button class="template-filter-btn" onclick="filterTemplates('poster')">Ìè¨Ïä§ÌÑ∞</button>
                    <button class="template-filter-btn" onclick="filterTemplates('presentation')">ÌîÑÎ†àÏ††ÌÖåÏù¥ÏÖò</button>
                    <button class="template-filter-btn" onclick="filterTemplates('minimal')">ÎØ∏ÎãàÎ©Ä</button>
                    <button class="template-filter-btn" onclick="filterTemplates('bold')">Î≥ºÎìú</button>
                </div>

                <!-- Templates Grid -->
                <div id="templatesGrid" style="flex: 1; overflow-y: auto; display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 16px; padding: 4px;">
                    <!-- Templates will be loaded here dynamically -->
                    <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: #999;">
                        ÌÖúÌîåÎ¶øÏùÑ Î∂àÎü¨Ïò§Îäî Ï§ë...
                    </div>
                </div>

                <!-- Info -->
                <div style="margin-top: 16px; padding: 12px; background: #f8f9ff; border-radius: 8px; font-size: 13px; color: #666;">
                    üí° ÌÖúÌîåÎ¶øÏùÑ ÌÅ¥Î¶≠ÌïòÎ©¥ ÌòÑÏû¨ Ï∫îÎ≤ÑÏä§Ïóê Ï†ÅÏö©Îê©ÎãàÎã§
                </div>
            </div>
        </div>
    </div>

    <!-- Keyboard Shortcuts Modal -->
    <div class="modal-overlay" id="keyboardShortcutsModal">
        <div class="modal-content" style="max-width: 700px; max-height: 85vh; overflow-y: auto;">
            <div class="modal-header">
                <h2 class="modal-title">‚å®Ô∏è ÌÇ§Î≥¥Îìú Îã®Ï∂ïÌÇ§</h2>
                <button class="modal-close" onclick="closeKeyboardShortcutsModal()">√ó</button>
            </div>

            <div class="export-options">
                <div style="display: grid; gap: 24px;">
                    <!-- General Section -->
                    <div class="shortcuts-section">
                        <h3 class="shortcuts-title">ÏùºÎ∞ò</h3>
                        <div class="shortcuts-list">
                            <div class="shortcut-item">
                                <span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>S</kbd></span>
                                <span class="shortcut-desc">ÌîÑÎ°úÏ†ùÌä∏ Ï†ÄÏû•</span>
                            </div>
                            <div class="shortcut-item">
                                <span class="shortcut-keys"><kbd>?</kbd></span>
                                <span class="shortcut-desc">Îã®Ï∂ïÌÇ§ Í∞ÄÏù¥Îìú Ïó¥Í∏∞</span>
                            </div>
                            <div class="shortcut-item">
                                <span class="shortcut-keys"><kbd>/</kbd></span>
                                <span class="shortcut-desc">Î†àÏù¥Ïñ¥ Í≤ÄÏÉâ Ìè¨Ïª§Ïä§</span>
                            </div>
                        </div>
                    </div>

                    <!-- Edit Section -->
                    <div class="shortcuts-section">
                        <h3 class="shortcuts-title">Ìé∏Ïßë</h3>
                        <div class="shortcuts-list">
                            <div class="shortcut-item">
                                <span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>Z</kbd></span>
                                <span class="shortcut-desc">Ïã§Ìñâ Ï∑®ÏÜå</span>
                            </div>
                            <div class="shortcut-item">
                                <span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>Y</kbd></span>
                                <span class="shortcut-desc">Îã§Ïãú Ïã§Ìñâ</span>
                            </div>
                            <div class="shortcut-item">
                                <span class="shortcut-keys"><kbd>Delete</kbd></span>
                                <span class="shortcut-desc">ÏÑ†ÌÉùÌïú ÏöîÏÜå ÏÇ≠Ï†ú</span>
                            </div>
                            <div class="shortcut-item">
                                <span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>C</kbd></span>
                                <span class="shortcut-desc">Î≥µÏÇ¨</span>
                            </div>
                            <div class="shortcut-item">
                                <span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>V</kbd></span>
                                <span class="shortcut-desc">Î∂ôÏó¨ÎÑ£Í∏∞</span>
                            </div>
                            <div class="shortcut-item">
                                <span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>D</kbd></span>
                                <span class="shortcut-desc">Î≥µÏ†ú</span>
                            </div>
                            <div class="shortcut-item">
                                <span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>D</kbd></span>
                                <span class="shortcut-desc">Ï†úÏûêÎ¶¨ Î≥µÏ†ú</span>
                            </div>
                        </div>
                    </div>

                    <!-- Selection Section -->
                    <div class="shortcuts-section">
                        <h3 class="shortcuts-title">ÏÑ†ÌÉù</h3>
                        <div class="shortcuts-list">
                            <div class="shortcut-item">
                                <span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>A</kbd></span>
                                <span class="shortcut-desc">Î™®Îëê ÏÑ†ÌÉù</span>
                            </div>
                            <div class="shortcut-item">
                                <span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>Click</kbd></span>
                                <span class="shortcut-desc">Îã§Ï§ë ÏÑ†ÌÉù</span>
                            </div>
                            <div class="shortcut-item">
                                <span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>G</kbd></span>
                                <span class="shortcut-desc">Í∑∏Î£π ÎßåÎì§Í∏∞</span>
                            </div>
                            <div class="shortcut-item">
                                <span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>G</kbd></span>
                                <span class="shortcut-desc">Í∑∏Î£π Ìï¥Ï†ú</span>
                            </div>
                        </div>
                    </div>

                    <!-- Movement Section -->
                    <div class="shortcuts-section">
                        <h3 class="shortcuts-title">Ïù¥Îèô Î∞è Ï†ïÎ†¨</h3>
                        <div class="shortcuts-list">
                            <div class="shortcut-item">
                                <span class="shortcut-keys"><kbd>‚Üë</kbd> <kbd>‚Üì</kbd> <kbd>‚Üê</kbd> <kbd>‚Üí</kbd></span>
                                <span class="shortcut-desc">ÏÑ†ÌÉùÌïú ÏöîÏÜå Ïù¥Îèô (1px)</span>
                            </div>
                            <div class="shortcut-item">
                                <span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>Arrow</kbd></span>
                                <span class="shortcut-desc">ÏÑ†ÌÉùÌïú ÏöîÏÜå Ïù¥Îèô (10px)</span>
                            </div>
                        </div>
                    </div>

                    <!-- Layers Section -->
                    <div class="shortcuts-section">
                        <h3 class="shortcuts-title">Î†àÏù¥Ïñ¥</h3>
                        <div class="shortcuts-list">
                            <div class="shortcut-item">
                                <span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>]</kbd></span>
                                <span class="shortcut-desc">Î†àÏù¥Ïñ¥ ÏúÑÎ°ú Ïù¥Îèô</span>
                            </div>
                            <div class="shortcut-item">
                                <span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>[</kbd></span>
                                <span class="shortcut-desc">Î†àÏù¥Ïñ¥ ÏïÑÎûòÎ°ú Ïù¥Îèô</span>
                            </div>
                            <div class="shortcut-item">
                                <span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>L</kbd></span>
                                <span class="shortcut-desc">Î†àÏù¥Ïñ¥ Ïû†Í∏à ÌÜ†Í∏Ä</span>
                            </div>
                        </div>
                    </div>

                    <!-- View Section -->
                    <div class="shortcuts-section">
                        <h3 class="shortcuts-title">Î≥¥Í∏∞</h3>
                        <div class="shortcuts-list">
                            <div class="shortcut-item">
                                <span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>+</kbd></span>
                                <span class="shortcut-desc">ÌôïÎåÄ</span>
                            </div>
                            <div class="shortcut-item">
                                <span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>-</kbd></span>
                                <span class="shortcut-desc">Ï∂ïÏÜå</span>
                            </div>
                            <div class="shortcut-item">
                                <span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>0</kbd></span>
                                <span class="shortcut-desc">ÌôîÎ©¥Ïóê ÎßûÏ∂îÍ∏∞</span>
                            </div>
                            <div class="shortcut-item">
                                <span class="shortcut-keys"><kbd>Space</kbd> + <kbd>Drag</kbd></span>
                                <span class="shortcut-desc">Ï∫îÎ≤ÑÏä§ Ïù¥Îèô (Ìå®Îãù)</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Tips -->
                <div style="margin-top: 24px; padding: 16px; background: #f8f9ff; border-radius: 8px; border-left: 4px solid #667eea;">
                    <div style="font-weight: 600; margin-bottom: 8px; color: #667eea;">üí° Tip</div>
                    <ul style="margin: 0; padding-left: 20px; font-size: 13px; color: #666; line-height: 1.8;">
                        <li>ÎåÄÎ∂ÄÎ∂ÑÏùò ÏûëÏóÖÏùÄ ÎßàÏö∞Ïä§ Ïò§Î•∏Ï™Ω ÌÅ¥Î¶≠ÏúºÎ°úÎèÑ ÏàòÌñâÌï† Ïàò ÏûàÏäµÎãàÎã§</li>
                        <li>ÌÖçÏä§Ìä∏ Ìé∏Ïßë Ï§ëÏóêÎäî Îã®Ï∂ïÌÇ§Í∞Ä ÎπÑÌôúÏÑ±ÌôîÎê©ÎãàÎã§</li>
                        <li>ÏÜçÏÑ± Ìå®ÎÑêÏóêÏÑú Ï†ïÎ∞ÄÌïú Í∞í Ï°∞Ï†ïÏù¥ Í∞ÄÎä•Ìï©ÎãàÎã§</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script src="config.js"></script>
    <script>
        // Global State
        let canvas, ctx;
        let elements = [];
        let selectedElement = null;
        let selectedElements = [];
        let currentTool = 'select';
        let isDrawing = false;
        let isDragging = false;
        let isResizing = false;
        let dragStart = {x: 0, y: 0};
        let resizeHandle = null;
        let history = [];
        let historyIndex = -1;
        let currentProjectId = null;
        let gridEnabled = true;
        let snapEnabled = true;
        let nextGroupId = 1;
        let imageCache = new Map();
        let clipboard = null;
        let autoSaveInterval = null;
        let lastSaveTime = null;
        let isDirty = true;
        let renderScheduled = false;
        let exportFormat = 'png';
        let exportResolution = 1;
        let exportQuality = 0.9;
        let isEditingText = false;
        let editingElement = null;
        let selectedTemplate = null;
        let isCropMode = false;
        let cropElement = null;
        let cropRect = { x: 0, y: 0, width: 0, height: 0 };
        let cropDragStart = null;
        let cropResizeHandle = null;
        let cropAspectRatio = null; // P19: 'free', '1:1', '16:9', '4:3', '3:2'

        // P16: Zoom & Pan
        let zoom = 1;
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let spacePressed = false;
        let panStart = { x: 0, y: 0 };
        const MIN_ZOOM = 0.25;
        const MAX_ZOOM = 4;

        // P17: Layer Filter
        let layerFilter = 'all';
        let layerSearchTerm = '';

        // P18: Smart Alignment Guidelines
        let snapGuides = {
            vertical: [],
            horizontal: []
        };
        const SNAP_THRESHOLD = 5;

        // P23: Style Library
        let savedStyles = JSON.parse(localStorage.getItem('savedStyles') || '[]');

        // P24: Multi-page Design
        let pages = [{ id: 1, name: 'Page 1', elements: [] }];
        let currentPageIndex = 0;

        // P25: Version History
        let versions = JSON.parse(localStorage.getItem('projectVersions_' + (new URLSearchParams(window.location.search).get('id') || 'temp')) || '[]');
        let versionInterval = null;

        // P30: Auto-save to server
        let hasUnsavedChanges = false;
        // autoSaveInterval already declared above
        let lastAutoSaveTime = null;

        // P15: Plugin System
        const plugins = [];
        const pluginAPI = {
            registerPlugin: function(plugin) {
                if (!plugin.name || !plugin.init) {
                    console.error('Invalid plugin: must have name and init function');
                    return false;
                }
                plugins.push(plugin);
                console.log(`Plugin registered: ${plugin.name}`);
                return true;
            },
            getContext: function() {
                return {
                    canvas,
                    ctx,
                    elements,
                    selectedElement,
                    addElement: function(element) {
                        elements.push(element);
                        saveHistory();
                        updateLayersList();
                        render();
                    },
                    updateElement: function(element, props) {
                        Object.assign(element, props);
                        saveHistory();
                        render();
                    },
                    deleteElement: function(element) {
                        const index = elements.indexOf(element);
                        if (index > -1) {
                            elements.splice(index, 1);
                            saveHistory();
                            updateLayersList();
                            render();
                        }
                    },
                    render,
                    showMessage: function(msg) {
                        alert(msg);
                    }
                };
            }
        };

        // Make plugin API available globally
        window.ArtifyPluginAPI = pluginAPI;

        // Template presets
        const templates = {
            'instagram-post': { width: 1080, height: 1080 },
            'instagram-story': { width: 1080, height: 1920 },
            'facebook-post': { width: 1200, height: 630 },
            'twitter-post': { width: 1024, height: 512 },
            'linkedin-post': { width: 1200, height: 627 },
            'youtube-thumbnail': { width: 1280, height: 720 },
            'presentation': { width: 1920, height: 1080 },
            'a4-portrait': { width: 2480, height: 3508 }
        };

        // Element class
        class Element {
            constructor(type, x, y, width, height) {
                this.id = Date.now() + Math.random();
                this.type = type;
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.rotation = 0;
                this.fill = '#667eea';
                this.stroke = '#000000';
                this.strokeWidth = 2;
                this.opacity = 1;
                this.visible = true;
                this.locked = false;
                this.groupId = null;
                // P26: Enhanced gradient with multi-stop support
                this.gradient = {
                    enabled: false,
                    type: 'linear', // 'linear' or 'radial'
                    stops: [
                        { position: 0, color: '#667eea' },
                        { position: 1, color: '#764ba2' }
                    ],
                    angle: 0, // For linear gradients
                    radialCenterX: 0.5, // For radial gradients (0-1)
                    radialCenterY: 0.5,
                    radialRadius: 0.7 // Relative to shape size
                };

                // P21: Blend Mode & Masking
                this.blendMode = 'normal';
                this.mask = {
                    enabled: false,
                    elementId: null
                };

                // P27: Drop Shadow (for all shapes)
                this.dropShadow = {
                    enabled: false,
                    offsetX: 4,
                    offsetY: 4,
                    blur: 8,
                    color: 'rgba(0, 0, 0, 0.3)'
                };

                // Animation (P12)
                this.animation = {
                    type: 'none',
                    duration: 1,
                    delay: 0
                };

                // Text specific
                if (type === 'text') {
                    this.text = 'ÌÖçÏä§Ìä∏ ÏûÖÎ†•';
                    this.fontSize = 24;
                    this.fontFamily = 'Arial';
                    this.textAlign = 'left';
                    this.bold = false;
                    this.italic = false;
                    this.underline = false;

                    // P22: Advanced text properties
                    this.lineHeight = 1.2;
                    this.letterSpacing = 0;

                    this.textShadow = {
                        enabled: false,
                        offsetX: 2,
                        offsetY: 2,
                        blur: 4,
                        color: '#000000'
                    };
                }

                // Image specific
                if (type === 'image') {
                    this.imageData = null;
                    this.filters = {
                        grayscale: 0,
                        sepia: 0,
                        blur: 0,
                        brightness: 100
                    };
                }

                // Drawing path specific
                if (type === 'pencil') {
                    this.points = [];
                }
            }

            // P26: Create gradient for element
            createGradient(context) {
                if (!this.gradient || !this.gradient.enabled) {
                    return this.fill;
                }

                let gradient;
                const cx = this.x + this.width / 2;
                const cy = this.y + this.height / 2;

                if (this.gradient.type === 'radial') {
                    // Radial gradient
                    const centerX = this.x + this.width * this.gradient.radialCenterX;
                    const centerY = this.y + this.height * this.gradient.radialCenterY;
                    const radius = Math.max(this.width, this.height) * this.gradient.radialRadius;
                    gradient = context.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
                } else {
                    // Linear gradient
                    const angle = this.gradient.angle * Math.PI / 180;
                    const x0 = cx - Math.cos(angle) * this.width / 2;
                    const y0 = cy - Math.sin(angle) * this.height / 2;
                    const x1 = cx + Math.cos(angle) * this.width / 2;
                    const y1 = cy + Math.sin(angle) * this.height / 2;
                    gradient = context.createLinearGradient(x0, y0, x1, y1);
                }

                // Add color stops
                for (const stop of this.gradient.stops) {
                    gradient.addColorStop(stop.position, stop.color);
                }

                return gradient;
            }

            draw(context) {
                if (!this.visible) return;

                context.save();
                context.globalAlpha = this.opacity;

                // P21: Apply blend mode
                context.globalCompositeOperation = this.blendMode || 'source-over';

                // P27: Apply drop shadow
                if (this.dropShadow && this.dropShadow.enabled) {
                    context.shadowOffsetX = this.dropShadow.offsetX;
                    context.shadowOffsetY = this.dropShadow.offsetY;
                    context.shadowBlur = this.dropShadow.blur;
                    context.shadowColor = this.dropShadow.color;
                }

                context.translate(this.x + this.width / 2, this.y + this.height / 2);
                context.rotate(this.rotation * Math.PI / 180);
                context.translate(-(this.x + this.width / 2), -(this.y + this.height / 2));

                switch (this.type) {
                    case 'rect':
                        // P26: Apply gradient or solid fill
                        context.fillStyle = this.createGradient(context);
                        context.strokeStyle = this.stroke;
                        context.lineWidth = this.strokeWidth;
                        context.fillRect(this.x, this.y, this.width, this.height);
                        if (this.strokeWidth > 0) {
                            context.strokeRect(this.x, this.y, this.width, this.height);
                        }
                        break;

                    case 'circle':
                        // P26: Apply gradient or solid fill
                        context.fillStyle = this.createGradient(context);
                        context.strokeStyle = this.stroke;
                        context.lineWidth = this.strokeWidth;
                        context.beginPath();
                        const radiusX = this.width / 2;
                        const radiusY = this.height / 2;
                        context.ellipse(this.x + radiusX, this.y + radiusY, radiusX, radiusY, 0, 0, 2 * Math.PI);
                        context.fill();
                        if (this.strokeWidth > 0) {
                            context.stroke();
                        }
                        break;

                    case 'triangle':
                        // P26: Apply gradient or solid fill
                        context.fillStyle = this.createGradient(context);
                        context.strokeStyle = this.stroke;
                        context.lineWidth = this.strokeWidth;
                        context.beginPath();
                        context.moveTo(this.x + this.width / 2, this.y);
                        context.lineTo(this.x + this.width, this.y + this.height);
                        context.lineTo(this.x, this.y + this.height);
                        context.closePath();
                        context.fill();
                        if (this.strokeWidth > 0) {
                            context.stroke();
                        }
                        break;

                    case 'star':
                        this.drawStar(context);
                        break;

                    case 'diamond':
                        this.drawDiamond(context);
                        break;

                    case 'hexagon':
                        this.drawHexagon(context);
                        break;

                    case 'speech-bubble':
                        this.drawSpeechBubble(context);
                        break;

                    case 'cloud':
                        this.drawCloud(context);
                        break;

                    case 'line':
                        context.strokeStyle = this.stroke;
                        context.lineWidth = this.strokeWidth;
                        context.beginPath();
                        context.moveTo(this.x, this.y);
                        context.lineTo(this.x + this.width, this.y + this.height);
                        context.stroke();
                        break;

                    case 'arrow':
                        this.drawArrow(context);
                        break;

                    case 'text':
                        context.fillStyle = this.fill;
                        let fontStyle = '';
                        if (this.italic) fontStyle += 'italic ';
                        if (this.bold) fontStyle += 'bold ';
                        context.font = `${fontStyle}${this.fontSize}px ${this.fontFamily}`;
                        context.textAlign = this.textAlign;
                        context.textBaseline = 'top';

                        // Apply text shadow if enabled
                        if (this.textShadow && this.textShadow.enabled) {
                            context.shadowOffsetX = this.textShadow.offsetX;
                            context.shadowOffsetY = this.textShadow.offsetY;
                            context.shadowBlur = this.textShadow.blur;
                            context.shadowColor = this.textShadow.color;
                        }

                        let textX = this.x;
                        if (this.textAlign === 'center') textX += this.width / 2;
                        else if (this.textAlign === 'right') textX += this.width;

                        // P22: Apply letter spacing
                        if (this.letterSpacing && this.letterSpacing !== 0) {
                            // Draw each character separately with spacing
                            let currentX = textX;
                            const chars = this.text.split('');

                            for (let i = 0; i < chars.length; i++) {
                                const char = chars[i];
                                const metrics = context.measureText(char);

                                if (this.textAlign === 'center') {
                                    const totalWidth = this.text.split('').reduce((acc, c) => {
                                        return acc + context.measureText(c).width + (c !== chars[chars.length - 1] ? this.letterSpacing : 0);
                                    }, 0);
                                    currentX = this.x + this.width / 2 - totalWidth / 2 + (i > 0 ? chars.slice(0, i).reduce((acc, c) => acc + context.measureText(c).width + this.letterSpacing, 0) : 0);
                                } else if (this.textAlign === 'right') {
                                    const totalWidth = this.text.split('').reduce((acc, c) => {
                                        return acc + context.measureText(c).width + (c !== chars[chars.length - 1] ? this.letterSpacing : 0);
                                    }, 0);
                                    currentX = this.x + this.width - totalWidth + (i > 0 ? chars.slice(0, i).reduce((acc, c) => acc + context.measureText(c).width + this.letterSpacing, 0) : 0);
                                } else {
                                    currentX = this.x + (i > 0 ? chars.slice(0, i).reduce((acc, c) => acc + context.measureText(c).width + this.letterSpacing, 0) : 0);
                                }

                                context.fillText(char, currentX, this.y);
                            }
                        } else {
                            context.fillText(this.text, textX, this.y);
                        }

                        // Reset shadow
                        context.shadowOffsetX = 0;
                        context.shadowOffsetY = 0;
                        context.shadowBlur = 0;
                        context.shadowColor = 'transparent';

                        // P22: Underline with letter spacing consideration
                        if (this.underline) {
                            let underlineWidth;
                            let underlineX;

                            if (this.letterSpacing && this.letterSpacing !== 0) {
                                // Calculate total width with letter spacing
                                underlineWidth = this.text.split('').reduce((acc, c, i) => {
                                    return acc + context.measureText(c).width + (i < this.text.length - 1 ? this.letterSpacing : 0);
                                }, 0);
                            } else {
                                underlineWidth = context.measureText(this.text).width;
                            }

                            if (this.textAlign === 'center') {
                                underlineX = this.x + this.width / 2 - underlineWidth / 2;
                            } else if (this.textAlign === 'right') {
                                underlineX = this.x + this.width - underlineWidth;
                            } else {
                                underlineX = this.x;
                            }

                            context.beginPath();
                            context.moveTo(underlineX, this.y + this.fontSize + 2);
                            context.lineTo(underlineX + underlineWidth, this.y + this.fontSize + 2);
                            context.strokeStyle = this.fill;
                            context.lineWidth = 1;
                            context.stroke();
                        }
                        break;

                    case 'image':
                        if (this.imageData) {
                            // Apply filters
                            if (this.filters) {
                                const filterParts = [];
                                if (this.filters.grayscale > 0) filterParts.push(`grayscale(${this.filters.grayscale}%)`);
                                if (this.filters.sepia > 0) filterParts.push(`sepia(${this.filters.sepia}%)`);
                                if (this.filters.blur > 0) filterParts.push(`blur(${this.filters.blur}px)`);
                                if (this.filters.brightness !== 100) filterParts.push(`brightness(${this.filters.brightness}%)`);
                                context.filter = filterParts.length > 0 ? filterParts.join(' ') : 'none';
                            }
                            context.drawImage(this.imageData, this.x, this.y, this.width, this.height);
                            context.filter = 'none';
                        }
                        break;

                    case 'pencil':
                        if (this.points.length > 0) {
                            context.strokeStyle = this.stroke;
                            context.lineWidth = this.strokeWidth;
                            context.lineCap = 'round';
                            context.lineJoin = 'round';
                            context.beginPath();
                            context.moveTo(this.points[0].x, this.points[0].y);
                            for (let i = 1; i < this.points.length; i++) {
                                context.lineTo(this.points[i].x, this.points[i].y);
                            }
                            context.stroke();
                        }
                        break;
                }

                context.restore();
            }

            drawStar(context) {
                const cx = this.x + this.width / 2;
                const cy = this.y + this.height / 2;
                const outerRadius = Math.min(this.width, this.height) / 2;
                const innerRadius = outerRadius / 2;
                const points = 5;

                // P26: Apply gradient or solid fill
                context.fillStyle = this.createGradient(context);
                context.strokeStyle = this.stroke;
                context.lineWidth = this.strokeWidth;
                context.beginPath();

                for (let i = 0; i < points * 2; i++) {
                    const radius = i % 2 === 0 ? outerRadius : innerRadius;
                    const angle = (i * Math.PI) / points - Math.PI / 2;
                    const x = cx + radius * Math.cos(angle);
                    const y = cy + radius * Math.sin(angle);
                    if (i === 0) context.moveTo(x, y);
                    else context.lineTo(x, y);
                }

                context.closePath();
                context.fill();
                if (this.strokeWidth > 0) {
                    context.stroke();
                }
            }

            drawArrow(context) {
                const headLength = 20;
                const dx = this.width;
                const dy = this.height;
                const angle = Math.atan2(dy, dx);

                context.strokeStyle = this.stroke;
                context.fillStyle = this.stroke;
                context.lineWidth = this.strokeWidth;

                // Line
                context.beginPath();
                context.moveTo(this.x, this.y);
                context.lineTo(this.x + dx, this.y + dy);
                context.stroke();

                // Arrowhead
                context.beginPath();
                context.moveTo(this.x + dx, this.y + dy);
                context.lineTo(
                    this.x + dx - headLength * Math.cos(angle - Math.PI / 6),
                    this.y + dy - headLength * Math.sin(angle - Math.PI / 6)
                );
                context.lineTo(
                    this.x + dx - headLength * Math.cos(angle + Math.PI / 6),
                    this.y + dy - headLength * Math.sin(angle + Math.PI / 6)
                );
                context.closePath();
                context.fill();
            }

            drawDiamond(context) {
                // P26: Apply gradient or solid fill
                context.fillStyle = this.createGradient(context);
                context.strokeStyle = this.stroke;
                context.lineWidth = this.strokeWidth;
                context.beginPath();

                // Diamond is rotated square
                const cx = this.x + this.width / 2;
                const cy = this.y + this.height / 2;

                context.moveTo(cx, this.y); // Top
                context.lineTo(this.x + this.width, cy); // Right
                context.lineTo(cx, this.y + this.height); // Bottom
                context.lineTo(this.x, cy); // Left

                context.closePath();
                context.fill();
                if (this.strokeWidth > 0) {
                    context.stroke();
                }
            }

            drawHexagon(context) {
                // P26: Apply gradient or solid fill
                context.fillStyle = this.createGradient(context);
                context.strokeStyle = this.stroke;
                context.lineWidth = this.strokeWidth;
                context.beginPath();

                const cx = this.x + this.width / 2;
                const cy = this.y + this.height / 2;
                const angleStep = (Math.PI * 2) / 6;
                const radius = Math.min(this.width, this.height) / 2;

                for (let i = 0; i < 6; i++) {
                    const angle = angleStep * i - Math.PI / 2;
                    const px = cx + radius * Math.cos(angle);
                    const py = cy + radius * Math.sin(angle);
                    if (i === 0) {
                        context.moveTo(px, py);
                    } else {
                        context.lineTo(px, py);
                    }
                }

                context.closePath();
                context.fill();
                if (this.strokeWidth > 0) {
                    context.stroke();
                }
            }

            drawSpeechBubble(context) {
                // P26: Apply gradient or solid fill
                context.fillStyle = this.createGradient(context);
                context.strokeStyle = this.stroke;
                context.lineWidth = this.strokeWidth;

                const bubbleHeight = this.height * 0.75;
                const tailHeight = this.height * 0.25;
                const radius = 10;

                context.beginPath();

                // Main bubble (rounded rectangle)
                context.moveTo(this.x + radius, this.y);
                context.lineTo(this.x + this.width - radius, this.y);
                context.arcTo(this.x + this.width, this.y, this.x + this.width, this.y + radius, radius);
                context.lineTo(this.x + this.width, this.y + bubbleHeight - radius);
                context.arcTo(this.x + this.width, this.y + bubbleHeight, this.x + this.width - radius, this.y + bubbleHeight, radius);

                // Tail (pointing down-left)
                const tailStartX = this.x + this.width * 0.2;
                context.lineTo(tailStartX + 20, this.y + bubbleHeight);
                context.lineTo(tailStartX, this.y + this.height);
                context.lineTo(tailStartX, this.y + bubbleHeight);

                context.lineTo(this.x + radius, this.y + bubbleHeight);
                context.arcTo(this.x, this.y + bubbleHeight, this.x, this.y + bubbleHeight - radius, radius);
                context.lineTo(this.x, this.y + radius);
                context.arcTo(this.x, this.y, this.x + radius, this.y, radius);

                context.closePath();
                context.fill();
                if (this.strokeWidth > 0) {
                    context.stroke();
                }
            }

            drawCloud(context) {
                // P26: Apply gradient or solid fill
                context.fillStyle = this.createGradient(context);
                context.strokeStyle = this.stroke;
                context.lineWidth = this.strokeWidth;

                const cx = this.x + this.width / 2;
                const cy = this.y + this.height / 2;

                context.beginPath();

                // Cloud is made of overlapping circles
                const r1 = this.width * 0.2;
                const r2 = this.width * 0.25;
                const r3 = this.width * 0.2;
                const r4 = this.width * 0.15;
                const r5 = this.width * 0.15;

                // Bottom large circles
                context.arc(this.x + this.width * 0.25, cy + this.height * 0.1, r1, 0, Math.PI * 2);
                context.arc(cx, cy, r2, 0, Math.PI * 2);
                context.arc(this.x + this.width * 0.75, cy + this.height * 0.1, r3, 0, Math.PI * 2);

                // Top smaller circles
                context.arc(this.x + this.width * 0.4, cy - this.height * 0.15, r4, 0, Math.PI * 2);
                context.arc(this.x + this.width * 0.6, cy - this.height * 0.15, r5, 0, Math.PI * 2);

                context.fill();
                if (this.strokeWidth > 0) {
                    context.stroke();
                }
            }

            contains(x, y) {
                if (this.type === 'pencil') {
                    // Check if point is near any line segment
                    for (let i = 0; i < this.points.length - 1; i++) {
                        const dist = this.distanceToSegment(x, y, this.points[i], this.points[i + 1]);
                        if (dist < this.strokeWidth + 5) return true;
                    }
                    return false;
                }

                return x >= this.x && x <= this.x + this.width &&
                       y >= this.y && y <= this.y + this.height;
            }

            distanceToSegment(px, py, p1, p2) {
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const len = Math.sqrt(dx * dx + dy * dy);
                if (len === 0) return Math.sqrt((px - p1.x) ** 2 + (py - p1.y) ** 2);

                const t = Math.max(0, Math.min(1, ((px - p1.x) * dx + (py - p1.y) * dy) / (len * len)));
                const projX = p1.x + t * dx;
                const projY = p1.y + t * dy;
                return Math.sqrt((px - projX) ** 2 + (py - projY) ** 2);
            }

            getResizeHandle(x, y) {
                if (this.type === 'pencil') return null;

                const handles = [
                    {name: 'nw', x: this.x, y: this.y},
                    {name: 'ne', x: this.x + this.width, y: this.y},
                    {name: 'sw', x: this.x, y: this.y + this.height},
                    {name: 'se', x: this.x + this.width, y: this.y + this.height},
                ];

                for (let handle of handles) {
                    if (Math.abs(x - handle.x) < 8 && Math.abs(y - handle.y) < 8) {
                        return handle.name;
                    }
                }
                return null;
            }
        }

        // Initialize
        window.onload = function() {
            if (!checkAuth()) return;

            canvas = document.getElementById('mainCanvas');
            ctx = canvas.getContext('2d');

            const urlParams = new URLSearchParams(window.location.search);
            currentProjectId = urlParams.get('id');

            if (currentProjectId) {
                loadProject(currentProjectId);
                // Enable auto-save every 5 minutes
                autoSaveInterval = setInterval(autoSave, 5 * 60 * 1000);
                // P25: Start version auto-save
                startVersionAutoSave();
                // P30: Start auto-save to server
                startAutoSave();
            } else {
                // Check if there's generated content from generate page
                const from = urlParams.get('from');
                const generatedText = urlParams.get('text');
                const generatedImage = urlParams.get('image');

                if (from === 'generate' && (generatedText || generatedImage)) {
                    // Add generated content to canvas
                    if (generatedText) {
                        addElement({
                            type: 'text',
                            content: decodeURIComponent(generatedText),
                            x: 100,
                            y: 100,
                            fontSize: 24,
                            color: '#000000'
                        });
                    }
                    if (generatedImage) {
                        addElement({
                            type: 'image',
                            src: decodeURIComponent(generatedImage),
                            x: 100,
                            y: 200,
                            width: 200,
                            height: 200
                        });
                    }
                }

                render();
            }

            setupEventListeners();
            setupOnlineStatusListener();

            // P15: Initialize plugins
            initializePlugins();

            // P17: Initialize layer filter
            document.getElementById('filterAll').classList.add('active');

            // P24: Initialize page thumbnails
            updatePageThumbnails();
        };

        function checkAuth() {
            const token = localStorage.getItem('token');
            if (!token) {
                alert('Î°úÍ∑∏Ïù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§.');
                window.location.href = 'login.html';
                return false;
            }
            return true;
        }

        function handleLogout() {
            if (confirm('Î°úÍ∑∏ÏïÑÏõÉ ÌïòÏãúÍ≤†ÏäµÎãàÍπå?')) {
                localStorage.clear();
                window.location.href = 'login.html';
            }
        }

        // P16: Zoom & Pan Functions (moved before setupEventListeners to fix hoisting)
        function handleWheel(e) {
            e.preventDefault();

            const oldZoom = zoom;
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            zoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoom * delta));

            // Zoom toward mouse position
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            panX = mouseX - (mouseX - panX) * (zoom / oldZoom);
            panY = mouseY - (mouseY - panY) * (zoom / oldZoom);

            updateZoomLevel();
            render();
        }

        function handleSpaceKeyDown(e) {
            if (e.code === 'Space' && !isEditingText && !spacePressed) {
                e.preventDefault();
                spacePressed = true;
                document.getElementById('canvasContainer').classList.add('panning');
            }
        }

        function handleSpaceKeyUp(e) {
            if (e.code === 'Space') {
                spacePressed = false;
                isPanning = false;
                document.getElementById('canvasContainer').classList.remove('panning', 'dragging');
            }
        }

        function handlePanStart(e) {
            if (spacePressed) {
                isPanning = true;
                panStart = { x: e.clientX - panX, y: e.clientY - panY };
                document.getElementById('canvasContainer').classList.add('dragging');
            }
        }

        function handlePanMove(e) {
            if (isPanning && spacePressed) {
                panX = e.clientX - panStart.x;
                panY = e.clientY - panStart.y;
                render();
            }
        }

        function handlePanEnd() {
            if (isPanning) {
                isPanning = false;
                document.getElementById('canvasContainer').classList.remove('dragging');
            }
        }

        // Convert screen coordinates to canvas coordinates (accounting for zoom/pan)
        function screenToCanvas(screenX, screenY) {
            const rect = canvas.getBoundingClientRect();
            const x = (screenX - rect.left - panX) / zoom;
            const y = (screenY - rect.top - panY) / zoom;
            return { x, y };
        }

        function setupEventListeners() {
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('dblclick', handleDoubleClick);

            document.addEventListener('keydown', handleKeyDown);

            // P16: Zoom & Pan event listeners
            canvas.addEventListener('wheel', handleWheel, { passive: false });
            document.addEventListener('keydown', handleSpaceKeyDown);
            document.addEventListener('keyup', handleSpaceKeyUp);
            canvas.addEventListener('mousedown', handlePanStart);
            canvas.addEventListener('mousemove', handlePanMove);
            canvas.addEventListener('mouseup', handlePanEnd);
        }

        function setupOnlineStatusListener() {
            window.addEventListener('online', () => {
                console.log('Ïò®ÎùºÏù∏ ÏÉÅÌÉúÎ°ú Î≥ÄÍ≤ΩÎêòÏóàÏäµÎãàÎã§.');
                if (currentProjectId && elements.length > 0) {
                    autoSave();
                }
            });

            window.addEventListener('offline', () => {
                console.log('Ïò§ÌîÑÎùºÏù∏ ÏÉÅÌÉúÏûÖÎãàÎã§. Î≥ÄÍ≤ΩÏÇ¨Ìï≠Ïù¥ Ï†ÄÏû•ÎêòÏßÄ ÏïäÏùÑ Ïàò ÏûàÏäµÎãàÎã§.');
            });
        }

        async function fetchWithRetry(url, options, maxRetries = 3) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (response.ok || response.status === 404) {
                        return response;
                    }
                    if (i === maxRetries - 1) throw new Error('Max retries reached');
                } catch (error) {
                    if (i === maxRetries - 1) throw error;
                    await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
                }
            }
        }

        async function autoSave() {
            if (!currentProjectId || elements.length === 0) return;

            try {
                const token = localStorage.getItem('token');
                const canvasData = canvas.toDataURL('image/jpeg', 0.8);

                const projectData = {
                    image: canvasData,
                    elements: elements.map(el => ({
                        ...el,
                        imageData: el.imageData ? el.imageData.src : null
                    })),
                    prompt: document.getElementById('aiPrompt').value,
                    lastModified: new Date().toISOString()
                };

                const response = await fetchWithRetry(`${API_URL}/projects/${currentProjectId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + token
                    },
                    body: JSON.stringify({
                        data: JSON.stringify(projectData)
                    })
                });

                if (response.ok) {
                    lastSaveTime = new Date();
                    console.log('ÏûêÎèô Ï†ÄÏû• ÏôÑÎ£å:', lastSaveTime.toLocaleTimeString());
                }
            } catch (error) {
                console.error('ÏûêÎèô Ï†ÄÏû• Ïã§Ìå®:', error);
            }
        }

        function handleMouseDown(e) {
            // P16: Don't handle if panning
            if (isPanning || spacePressed) return;

            // P16: Convert screen coordinates to canvas coordinates
            const coords = screenToCanvas(e.clientX, e.clientY);
            const x = coords.x;
            const y = coords.y;

            if (currentTool === 'select') {
                // Check for resize handle
                if (selectedElement) {
                    resizeHandle = selectedElement.getResizeHandle(x, y);
                    if (resizeHandle) {
                        isResizing = true;
                        dragStart = {x, y};
                        return;
                    }
                }

                // Check for element selection
                for (let i = elements.length - 1; i >= 0; i--) {
                    if (elements[i].contains(x, y) && !elements[i].locked) {
                        const clickedElement = elements[i];

                        // If element is part of a group, select all group members
                        if (clickedElement.groupId) {
                            selectedElements = elements.filter(el => el.groupId === clickedElement.groupId);
                            selectedElement = clickedElement;
                        } else if (e.ctrlKey || e.metaKey) {
                            // Ctrl+Click for multi-select
                            if (selectedElements.includes(clickedElement)) {
                                selectedElements = selectedElements.filter(el => el !== clickedElement);
                                selectedElement = selectedElements[0] || null;
                            } else {
                                selectedElements.push(clickedElement);
                                selectedElement = clickedElement;
                            }
                        } else {
                            // Single select
                            selectedElement = clickedElement;
                            selectedElements = [clickedElement];
                        }

                        isDragging = true;
                        dragStart = {x: x - selectedElement.x, y: y - selectedElement.y};
                        updatePropertiesPanel();
                        updateLayersList();
                        render();
                        return;
                    }
                }

                // Deselect
                selectedElement = null;
                selectedElements = [];
                updatePropertiesPanel();
                updateLayersList();
                render();
            } else if (currentTool === 'pencil') {
                isDrawing = true;
                const pencil = new Element('pencil', x, y, 0, 0);
                pencil.points.push({x, y});
                pencil.stroke = document.getElementById('propStroke').value;
                pencil.strokeWidth = parseInt(document.getElementById('propStrokeWidth').value);
                elements.push(pencil);
                selectedElement = pencil;
            } else {
                // Start drawing shape
                isDrawing = true;
                dragStart = {x, y};
            }
        }

        function handleMouseMove(e) {
            // P16: Handle panning separately
            if (isPanning && spacePressed) {
                handlePanMove(e);
                return;
            }

            // P16: Convert screen coordinates to canvas coordinates
            const coords = screenToCanvas(e.clientX, e.clientY);
            const x = coords.x;
            const y = coords.y;

            if (isDragging && selectedElement && !selectedElement.locked) {
                let newX = x - dragStart.x;
                let newY = y - dragStart.y;

                // P18: Calculate smart alignment guides
                if (snapEnabled) {
                    const snapResult = calculateSnapGuides(newX, newY, selectedElement);
                    newX = snapResult.x;
                    newY = snapResult.y;
                    snapGuides = snapResult.guides;
                } else {
                    snapGuides = { vertical: [], horizontal: [] };
                    // Grid snap only
                    newX = Math.round(newX / 10) * 10;
                    newY = Math.round(newY / 10) * 10;
                }

                const deltaX = newX - selectedElement.x;
                const deltaY = newY - selectedElement.y;

                // Move selected element
                selectedElement.x = newX;
                selectedElement.y = newY;

                // Move other selected elements
                if (selectedElements.length > 1) {
                    selectedElements.forEach(el => {
                        if (el !== selectedElement && !el.locked) {
                            el.x += deltaX;
                            el.y += deltaY;
                        }
                    });
                }

                updatePropertiesPanel();
                render();
            } else if (isResizing && selectedElement) {
                const dx = x - dragStart.x;
                const dy = y - dragStart.y;

                switch (resizeHandle) {
                    case 'se':
                        selectedElement.width = Math.max(10, selectedElement.width + dx);
                        selectedElement.height = Math.max(10, selectedElement.height + dy);
                        break;
                    case 'sw':
                        selectedElement.width = Math.max(10, selectedElement.width - dx);
                        selectedElement.height = Math.max(10, selectedElement.height + dy);
                        selectedElement.x += dx;
                        break;
                    case 'ne':
                        selectedElement.width = Math.max(10, selectedElement.width + dx);
                        selectedElement.height = Math.max(10, selectedElement.height - dy);
                        selectedElement.y += dy;
                        break;
                    case 'nw':
                        selectedElement.width = Math.max(10, selectedElement.width - dx);
                        selectedElement.height = Math.max(10, selectedElement.height - dy);
                        selectedElement.x += dx;
                        selectedElement.y += dy;
                        break;
                }

                dragStart = {x, y};
                updatePropertiesPanel();
                render();
            } else if (isDrawing && currentTool === 'pencil' && selectedElement) {
                selectedElement.points.push({x, y});
                render();
            }
        }

        function handleMouseUp(e) {
            if (isDrawing && currentTool !== 'select' && currentTool !== 'pencil') {
                // P16: Convert screen coordinates to canvas coordinates
                const coords = screenToCanvas(e.clientX, e.clientY);
                const x = coords.x;
                const y = coords.y;

                const width = x - dragStart.x;
                const height = y - dragStart.y;

                if (Math.abs(width) > 10 && Math.abs(height) > 10) {
                    const element = new Element(
                        currentTool,
                        Math.min(dragStart.x, x),
                        Math.min(dragStart.y, y),
                        Math.abs(width),
                        Math.abs(height)
                    );
                    element.fill = document.getElementById('propFill').value;
                    element.stroke = document.getElementById('propStroke').value;
                    element.strokeWidth = parseInt(document.getElementById('propStrokeWidth').value);

                    elements.push(element);
                    selectedElement = element;
                    saveHistory();
                    updatePropertiesPanel();
                    updateLayersList();
                    render();
                }
            } else if (currentTool === 'pencil' && selectedElement) {
                // Calculate bounding box for pencil
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                for (let point of selectedElement.points) {
                    minX = Math.min(minX, point.x);
                    minY = Math.min(minY, point.y);
                    maxX = Math.max(maxX, point.x);
                    maxY = Math.max(maxY, point.y);
                }
                selectedElement.x = minX;
                selectedElement.y = minY;
                selectedElement.width = maxX - minX;
                selectedElement.height = maxY - minY;

                saveHistory();
                updateLayersList();
            }

            isDragging = false;
            isDrawing = false;
            isResizing = false;
            resizeHandle = null;

            // P18: Clear snap guides
            snapGuides = { vertical: [], horizontal: [] };
            render();
        }

        function handleDoubleClick(e) {
            if (currentTool === 'text' || (selectedElement && selectedElement.type === 'text')) {
                // P16: Convert screen coordinates to canvas coordinates
                const coords = screenToCanvas(e.clientX, e.clientY);
                const x = coords.x;
                const y = coords.y;

                if (!selectedElement || selectedElement.type !== 'text') {
                    const text = new Element('text', x, y, 200, 40);
                    text.fill = document.getElementById('propFill').value;
                    elements.push(text);
                    selectedElement = text;
                    selectedElements = [text];
                    saveHistory();
                }

                // Show inline text editor
                showInlineTextEditor(selectedElement);
            }
        }

        function showInlineTextEditor(textElement) {
            if (!textElement || textElement.type !== 'text') return;

            isEditingText = true;
            editingElement = textElement;

            const editor = document.getElementById('inlineTextEditor');
            const rect = canvas.getBoundingClientRect();
            const canvasContainer = document.querySelector('.canvas-wrapper');

            // Position the editor
            editor.style.left = (textElement.x) + 'px';
            editor.style.top = (textElement.y) + 'px';
            editor.style.width = Math.max(textElement.width, 100) + 'px';
            editor.style.minHeight = textElement.height + 'px';

            // Style the editor to match the text element
            editor.style.fontFamily = textElement.fontFamily;
            editor.style.fontSize = textElement.fontSize + 'px';
            editor.style.color = textElement.fill;
            editor.style.fontWeight = textElement.bold ? 'bold' : 'normal';
            editor.style.fontStyle = textElement.italic ? 'italic' : 'normal';
            editor.style.textDecoration = textElement.underline ? 'underline' : 'none';
            editor.style.textAlign = textElement.textAlign;

            // Set the content
            editor.value = textElement.text;
            editor.style.display = 'block';
            editor.focus();
            editor.select();

            // Auto-resize as user types
            editor.oninput = function() {
                this.style.height = 'auto';
                this.style.height = this.scrollHeight + 'px';
            };

            // Handle when user finishes editing
            editor.onblur = function() {
                finishTextEditing();
            };

            editor.onkeydown = function(e) {
                if (e.key === 'Escape') {
                    finishTextEditing();
                } else if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
                    finishTextEditing();
                }
                e.stopPropagation();
            };
        }

        function finishTextEditing() {
            if (!isEditingText || !editingElement) return;

            const editor = document.getElementById('inlineTextEditor');
            const newText = editor.value.trim();

            if (newText) {
                editingElement.text = newText;

                // Measure text width
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                let fontStyle = '';
                if (editingElement.italic) fontStyle += 'italic ';
                if (editingElement.bold) fontStyle += 'bold ';
                tempCtx.font = `${fontStyle}${editingElement.fontSize}px ${editingElement.fontFamily}`;
                const metrics = tempCtx.measureText(newText);
                editingElement.width = Math.max(metrics.width + 10, 100);
                editingElement.height = Math.max(editingElement.fontSize + 10, 40);

                saveHistory();
            } else if (elements.includes(editingElement)) {
                // Remove empty text elements
                const index = elements.indexOf(editingElement);
                elements.splice(index, 1);
                selectedElement = null;
                selectedElements = [];
            }

            editor.style.display = 'none';
            editor.value = '';
            editor.onblur = null;
            editor.onkeydown = null;
            editor.oninput = null;

            isEditingText = false;
            editingElement = null;

            updatePropertiesPanel();
            updateLayersList();
            render();
        }

        function handleKeyDown(e) {
            // Ignore keyboard shortcuts during text editing
            if (isEditingText) return;

            // P30: Ctrl+S to save
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                saveProject();
                return;
            }

            if (e.key === 'Delete' && selectedElement) {
                deleteSelected();
            } else if (e.ctrlKey && e.key === 'z') {
                e.preventDefault();
                undo();
            } else if (e.ctrlKey && e.key === 'y') {
                e.preventDefault();
                redo();
            } else if (e.ctrlKey && e.shiftKey && e.key === 'G') {
                e.preventDefault();
                ungroupElements();
            } else if (e.ctrlKey && e.key === 'g') {
                e.preventDefault();
                groupElements();
            } else if (e.ctrlKey && e.key === 'a') {
                e.preventDefault();
                selectAll();
            } else if (e.ctrlKey && e.key === 'c') {
                e.preventDefault();
                copySelected();
            } else if (e.ctrlKey && e.key === 'v') {
                e.preventDefault();
                pasteClipboard();
            } else if (e.ctrlKey && e.key === 'd') {
                e.preventDefault();
                duplicateSelected();
            } else if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
                moveSelectedByArrow(e.key, e.ctrlKey);
            } else if (e.ctrlKey && (e.key === '+' || e.key === '=')) {
                // P16: Zoom in
                e.preventDefault();
                zoomIn();
            } else if (e.ctrlKey && (e.key === '-' || e.key === '_')) {
                // P16: Zoom out
                e.preventDefault();
                zoomOut();
            } else if (e.ctrlKey && e.key === '0') {
                // P16: Fit to screen
                e.preventDefault();
                fitToScreen();
            } else if (e.ctrlKey && e.key === '[') {
                // P20: Move layer down
                e.preventDefault();
                moveLayer('down');
            } else if (e.ctrlKey && e.key === ']') {
                // P20: Move layer up
                e.preventDefault();
                moveLayer('up');
            } else if (e.ctrlKey && e.key === 'l') {
                // P20: Toggle lock
                e.preventDefault();
                toggleSelectedLock();
            } else if (e.ctrlKey && e.shiftKey && e.key === 'D') {
                // P20: Duplicate in place
                e.preventDefault();
                duplicateInPlace();
            } else if (e.key === '/' && !isEditingText) {
                // P20: Quick search focus
                e.preventDefault();
                const searchInput = document.getElementById('layerSearch');
                if (searchInput) {
                    searchInput.focus();
                    searchInput.select();
                }
            } else if (e.key === '?' && !isEditingText) {
                // Show keyboard shortcuts guide
                e.preventDefault();
                showKeyboardShortcutsModal();
            }
        }

        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-item').forEach(item => {
                item.classList.remove('active');
            });
            document.querySelector(`[data-tool="${tool}"]`).classList.add('active');

            if (tool !== 'select') {
                selectedElement = null;
                updatePropertiesPanel();
                render();
            }
        }

        function render() {
            if (!isDirty && !renderScheduled) return;

            if (!renderScheduled) {
                renderScheduled = true;
                requestAnimationFrame(() => {
                    renderScheduled = false;
                    isDirty = false;
                    actualRender();
                });
            }
        }

        function actualRender() {
            // Clear canvas
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // P16: Apply zoom and pan transform
            ctx.save();
            ctx.translate(panX, panY);
            ctx.scale(zoom, zoom);

            // Draw grid
            if (gridEnabled) {
                ctx.strokeStyle = '#f0f0f0';
                ctx.lineWidth = 1 / zoom; // Adjust line width for zoom
                for (let i = 0; i < canvas.width / zoom; i += 50) {
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i, canvas.height / zoom);
                    ctx.stroke();
                }
                for (let i = 0; i < canvas.height / zoom; i += 50) {
                    ctx.beginPath();
                    ctx.moveTo(0, i);
                    ctx.lineTo(canvas.width / zoom, i);
                    ctx.stroke();
                }
            }

            // Draw elements
            for (let element of elements) {
                element.draw(ctx);
            }

            // Draw selection
            if (currentTool === 'select') {
                // Draw all selected elements
                if (selectedElements.length > 1) {
                    ctx.strokeStyle = '#667eea';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    selectedElements.forEach(el => {
                        ctx.strokeRect(el.x - 2, el.y - 2, el.width + 4, el.height + 4);
                    });
                    ctx.setLineDash([]);
                } else if (selectedElement) {
                    ctx.strokeStyle = '#667eea';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(selectedElement.x - 2, selectedElement.y - 2,
                                  selectedElement.width + 4, selectedElement.height + 4);
                    ctx.setLineDash([]);

                    // Draw resize handles
                    if (selectedElement.type !== 'pencil') {
                        ctx.fillStyle = '#667eea';
                        const handles = [
                            {x: selectedElement.x, y: selectedElement.y},
                            {x: selectedElement.x + selectedElement.width, y: selectedElement.y},
                            {x: selectedElement.x, y: selectedElement.y + selectedElement.height},
                            {x: selectedElement.x + selectedElement.width, y: selectedElement.y + selectedElement.height},
                        ];
                        for (let handle of handles) {
                            ctx.fillRect(handle.x - 4, handle.y - 4, 8, 8);
                        }
                    }
                }
            }

            // P18: Draw smart alignment guidelines
            if (isDragging && selectedElement && (snapGuides.vertical.length > 0 || snapGuides.horizontal.length > 0)) {
                ctx.strokeStyle = '#FF6B6B';
                ctx.lineWidth = 1 / zoom;
                ctx.setLineDash([5, 5]);

                // Draw vertical guides
                snapGuides.vertical.forEach(x => {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height / zoom);
                    ctx.stroke();
                });

                // Draw horizontal guides
                snapGuides.horizontal.forEach(y => {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width / zoom, y);
                    ctx.stroke();
                });

                ctx.setLineDash([]);
            }

            // P16: Restore transform
            ctx.restore();
        }

        function markDirty() {
            isDirty = true;
        }

        function updatePropertiesPanel() {
            const elementProps = document.getElementById('elementProps');
            const textProps = document.getElementById('textProps');
            const imageProps = document.getElementById('imageProps');
            const gradientSection = document.getElementById('gradientSection');

            if (selectedElement) {
                elementProps.style.display = 'block';
                document.getElementById('propX').value = Math.round(selectedElement.x);
                document.getElementById('propY').value = Math.round(selectedElement.y);
                document.getElementById('propWidth').value = Math.round(selectedElement.width);
                document.getElementById('propHeight').value = Math.round(selectedElement.height);
                document.getElementById('propRotation').value = selectedElement.rotation;
                document.getElementById('rotationValue').textContent = selectedElement.rotation + '¬∞';
                document.getElementById('propOpacity').value = selectedElement.opacity * 100;
                document.getElementById('opacityValue').textContent = Math.round(selectedElement.opacity * 100) + '%';
                document.getElementById('propFill').value = selectedElement.fill;
                document.getElementById('propStroke').value = selectedElement.stroke;
                document.getElementById('propStrokeWidth').value = selectedElement.strokeWidth;
                document.getElementById('strokeValue').textContent = selectedElement.strokeWidth + 'px';

                // P21: Update blend mode
                document.getElementById('propBlendMode').value = selectedElement.blendMode || 'source-over';

                // P26: Show gradient section for shapes (including new shape types)
                if (['rect', 'circle', 'triangle', 'star', 'diamond', 'hexagon', 'speech-bubble', 'cloud'].includes(selectedElement.type)) {
                    gradientSection.style.display = 'block';
                    if (selectedElement.gradient) {
                        document.getElementById('gradientEnabled').checked = selectedElement.gradient.enabled;
                        document.getElementById('gradientControls').style.display = selectedElement.gradient.enabled ? 'block' : 'none';

                        // P26: Update gradient controls with new stops-based system
                        document.getElementById('gradientType').value = selectedElement.gradient.type;
                        const isRadial = selectedElement.gradient.type === 'radial';
                        document.getElementById('gradientAngleGroup').style.display = isRadial ? 'none' : 'block';
                        document.getElementById('radialGradientControls').style.display = isRadial ? 'block' : 'none';

                        // Color stops
                        const stops = selectedElement.gradient.stops;
                        document.getElementById('gradientColor1').value = stops[0].color;
                        const hasMiddle = stops.length === 3;
                        document.getElementById('gradientMiddleEnabled').checked = hasMiddle;
                        if (hasMiddle) {
                            document.getElementById('gradientColor2').value = stops[1].color;
                            document.getElementById('gradientColor3').value = stops[2].color;
                        } else {
                            document.getElementById('gradientColor3').value = stops[1].color;
                        }

                        // Angle and radius
                        document.getElementById('gradientAngle').value = selectedElement.gradient.angle;
                        document.getElementById('angleValue').textContent = selectedElement.gradient.angle + '¬∞';
                        document.getElementById('radialRadius').value = selectedElement.gradient.radialRadius;
                        document.getElementById('radiusValue').textContent = selectedElement.gradient.radialRadius;
                    }
                } else {
                    gradientSection.style.display = 'none';
                }

                // P27: Show drop shadow section for shapes (not text, text has its own shadow)
                const dropShadowSection = document.getElementById('dropShadowSection');
                if (['rect', 'circle', 'triangle', 'star', 'diamond', 'hexagon', 'speech-bubble', 'cloud', 'line', 'arrow'].includes(selectedElement.type)) {
                    dropShadowSection.style.display = 'block';
                    if (selectedElement.dropShadow) {
                        document.getElementById('dropShadowEnabled').checked = selectedElement.dropShadow.enabled;
                        document.getElementById('dropShadowControls').style.display = selectedElement.dropShadow.enabled ? 'block' : 'none';

                        // Update drop shadow controls
                        document.getElementById('dropShadowX').value = selectedElement.dropShadow.offsetX;
                        document.getElementById('dropShadowXValue').textContent = selectedElement.dropShadow.offsetX + 'px';
                        document.getElementById('dropShadowY').value = selectedElement.dropShadow.offsetY;
                        document.getElementById('dropShadowYValue').textContent = selectedElement.dropShadow.offsetY + 'px';
                        document.getElementById('dropShadowBlur').value = selectedElement.dropShadow.blur;
                        document.getElementById('dropShadowBlurValue').textContent = selectedElement.dropShadow.blur + 'px';

                        // Parse rgba color to hex and opacity
                        const rgbaMatch = selectedElement.dropShadow.color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
                        if (rgbaMatch) {
                            const r = parseInt(rgbaMatch[1]).toString(16).padStart(2, '0');
                            const g = parseInt(rgbaMatch[2]).toString(16).padStart(2, '0');
                            const b = parseInt(rgbaMatch[3]).toString(16).padStart(2, '0');
                            const alpha = rgbaMatch[4] ? parseFloat(rgbaMatch[4]) : 1;
                            document.getElementById('dropShadowColor').value = '#' + r + g + b;
                            document.getElementById('dropShadowOpacity').value = Math.round(alpha * 100);
                            document.getElementById('dropShadowOpacityValue').textContent = Math.round(alpha * 100) + '%';
                        }
                    }
                } else {
                    dropShadowSection.style.display = 'none';
                }

                if (selectedElement.type === 'text') {
                    textProps.style.display = 'block';
                    imageProps.style.display = 'none';
                    document.getElementById('propText').value = selectedElement.text;
                    document.getElementById('propFont').value = selectedElement.fontFamily;
                    document.getElementById('propFontSize').value = selectedElement.fontSize;
                    document.getElementById('fontSizeValue').textContent = selectedElement.fontSize + 'px';

                    // P22: Update advanced text properties
                    if (selectedElement.lineHeight !== undefined) {
                        document.getElementById('propLineHeight').value = selectedElement.lineHeight;
                        document.getElementById('lineHeightValue').textContent = selectedElement.lineHeight.toFixed(1);
                    }
                    if (selectedElement.letterSpacing !== undefined) {
                        document.getElementById('propLetterSpacing').value = selectedElement.letterSpacing;
                        document.getElementById('letterSpacingValue').textContent = selectedElement.letterSpacing + 'px';
                    }

                    // Update text shadow controls
                    if (selectedElement.textShadow) {
                        document.getElementById('textShadowEnabled').checked = selectedElement.textShadow.enabled;
                        document.getElementById('textShadowControls').style.display = selectedElement.textShadow.enabled ? 'block' : 'none';
                        document.getElementById('shadowOffsetX').value = selectedElement.textShadow.offsetX;
                        document.getElementById('shadowXValue').textContent = selectedElement.textShadow.offsetX + 'px';
                        document.getElementById('shadowOffsetY').value = selectedElement.textShadow.offsetY;
                        document.getElementById('shadowYValue').textContent = selectedElement.textShadow.offsetY + 'px';
                        document.getElementById('shadowBlur').value = selectedElement.textShadow.blur;
                        document.getElementById('shadowBlurValue').textContent = selectedElement.textShadow.blur + 'px';
                        document.getElementById('shadowColor').value = selectedElement.textShadow.color;
                    }
                } else if (selectedElement.type === 'image') {
                    textProps.style.display = 'none';
                    imageProps.style.display = 'block';

                    // Update image filter controls
                    if (selectedElement.filters) {
                        document.getElementById('filterGrayscale').value = selectedElement.filters.grayscale;
                        document.getElementById('grayscaleValue').textContent = selectedElement.filters.grayscale + '%';
                        document.getElementById('filterSepia').value = selectedElement.filters.sepia;
                        document.getElementById('sepiaValue').textContent = selectedElement.filters.sepia + '%';
                        document.getElementById('filterBlur').value = selectedElement.filters.blur;
                        document.getElementById('blurValue').textContent = selectedElement.filters.blur + 'px';
                        document.getElementById('filterBrightness').value = selectedElement.filters.brightness;
                        document.getElementById('brightnessValue').textContent = selectedElement.filters.brightness + '%';
                    }
                } else {
                    textProps.style.display = 'none';
                    imageProps.style.display = 'none';
                }

                // Show animation section (P12)
                const animationProps = document.getElementById('animationProps');
                animationProps.style.display = 'block';
                if (selectedElement.animation) {
                    document.getElementById('animationType').value = selectedElement.animation.type;
                    document.getElementById('animationDuration').value = selectedElement.animation.duration;
                    document.getElementById('durationValue').textContent = selectedElement.animation.duration.toFixed(1) + 's';
                    document.getElementById('animationDelay').value = selectedElement.animation.delay;
                    document.getElementById('delayValue').textContent = selectedElement.animation.delay.toFixed(1) + 's';
                }
            } else {
                elementProps.style.display = 'none';
                textProps.style.display = 'none';
                imageProps.style.display = 'none';
                document.getElementById('animationProps').style.display = 'none';
            }
        }

        function updateElementProp(prop, value) {
            if (!selectedElement) return;

            switch (prop) {
                case 'x':
                case 'y':
                case 'width':
                case 'height':
                case 'fontSize':
                    selectedElement[prop] = parseFloat(value);
                    break;
                case 'rotation':
                    selectedElement[prop] = parseFloat(value);
                    document.getElementById('rotationValue').textContent = value + '¬∞';
                    break;
                case 'opacity':
                    selectedElement[prop] = parseFloat(value) / 100;
                    document.getElementById('opacityValue').textContent = value + '%';
                    break;
                case 'strokeWidth':
                    selectedElement[prop] = parseFloat(value);
                    document.getElementById('strokeValue').textContent = value + 'px';
                    break;
                default:
                    selectedElement[prop] = value;
            }

            render();
        }

        function toggleTextStyle(style) {
            if (!selectedElement || selectedElement.type !== 'text') return;

            selectedElement[style] = !selectedElement[style];
            render();
        }

        function toggleTextShadow(enabled) {
            if (!selectedElement || selectedElement.type !== 'text') return;

            if (!selectedElement.textShadow) {
                selectedElement.textShadow = {
                    enabled: false,
                    offsetX: 2,
                    offsetY: 2,
                    blur: 4,
                    color: '#000000'
                };
            }

            selectedElement.textShadow.enabled = enabled;
            document.getElementById('textShadowControls').style.display = enabled ? 'block' : 'none';
            render();
        }

        function updateTextShadow(prop, value) {
            if (!selectedElement || selectedElement.type !== 'text' || !selectedElement.textShadow) return;

            switch (prop) {
                case 'offsetX':
                    selectedElement.textShadow.offsetX = parseFloat(value);
                    document.getElementById('shadowXValue').textContent = value + 'px';
                    break;
                case 'offsetY':
                    selectedElement.textShadow.offsetY = parseFloat(value);
                    document.getElementById('shadowYValue').textContent = value + 'px';
                    break;
                case 'blur':
                    selectedElement.textShadow.blur = parseFloat(value);
                    document.getElementById('shadowBlurValue').textContent = value + 'px';
                    break;
                case 'color':
                    selectedElement.textShadow.color = value;
                    break;
            }

            render();
        }

        function setColor(color) {
            document.getElementById('propFill').value = color;
            if (selectedElement) {
                selectedElement.fill = color;
                render();
            }
        }

        function updateImageFilter(filterType, value) {
            if (!selectedElement || selectedElement.type !== 'image' || !selectedElement.filters) return;

            selectedElement.filters[filterType] = parseFloat(value);

            switch (filterType) {
                case 'grayscale':
                    document.getElementById('grayscaleValue').textContent = value + '%';
                    break;
                case 'sepia':
                    document.getElementById('sepiaValue').textContent = value + '%';
                    break;
                case 'blur':
                    document.getElementById('blurValue').textContent = value + 'px';
                    break;
                case 'brightness':
                    document.getElementById('brightnessValue').textContent = value + '%';
                    break;
            }

            render();
        }

        function resetImageFilters() {
            if (!selectedElement || selectedElement.type !== 'image') return;

            selectedElement.filters = {
                grayscale: 0,
                sepia: 0,
                blur: 0,
                brightness: 100
            };

            updatePropertiesPanel();
            render();
        }

        function toggleGradient(enabled) {
            if (!selectedElement || !selectedElement.gradient) return;

            selectedElement.gradient.enabled = enabled;
            document.getElementById('gradientControls').style.display = enabled ? 'block' : 'none';
            render();
        }

        // P26: Enhanced gradient update function
        function updateGradient(prop, value) {
            if (!selectedElement || !selectedElement.gradient) return;

            if (prop === 'type') {
                selectedElement.gradient.type = value;
                // Show/hide appropriate controls
                const isRadial = value === 'radial';
                document.getElementById('gradientAngleGroup').style.display = isRadial ? 'none' : 'block';
                document.getElementById('radialGradientControls').style.display = isRadial ? 'block' : 'none';
            } else if (prop === 'color1') {
                selectedElement.gradient.stops[0].color = value;
            } else if (prop === 'color2') {
                // Middle color
                const middleEnabled = document.getElementById('gradientMiddleEnabled').checked;
                if (middleEnabled) {
                    if (selectedElement.gradient.stops.length === 2) {
                        // Insert middle color
                        selectedElement.gradient.stops = [
                            selectedElement.gradient.stops[0],
                            { position: 0.5, color: value },
                            selectedElement.gradient.stops[1]
                        ];
                    } else {
                        selectedElement.gradient.stops[1].color = value;
                    }
                }
            } else if (prop === 'color3') {
                // End color
                const lastIndex = selectedElement.gradient.stops.length - 1;
                selectedElement.gradient.stops[lastIndex].color = value;
            } else if (prop === 'angle') {
                selectedElement.gradient.angle = parseFloat(value);
                document.getElementById('angleValue').textContent = value + '¬∞';
            } else if (prop === 'radius') {
                selectedElement.gradient.radialRadius = parseFloat(value);
                document.getElementById('radiusValue').textContent = value;
            }

            render();
        }

        // P26: Toggle middle color in gradient
        function toggleGradientMiddleColor(enabled) {
            if (!selectedElement || !selectedElement.gradient) return;

            if (enabled) {
                // Add middle color stop
                if (selectedElement.gradient.stops.length === 2) {
                    const color2 = document.getElementById('gradientColor2').value;
                    selectedElement.gradient.stops = [
                        selectedElement.gradient.stops[0],
                        { position: 0.5, color: color2 },
                        selectedElement.gradient.stops[1]
                    ];
                }
            } else {
                // Remove middle color stop
                if (selectedElement.gradient.stops.length === 3) {
                    selectedElement.gradient.stops = [
                        selectedElement.gradient.stops[0],
                        selectedElement.gradient.stops[2]
                    ];
                }
            }

            render();
        }

        // P27: Toggle drop shadow
        function toggleDropShadow(enabled) {
            if (!selectedElement || !selectedElement.dropShadow) return;

            selectedElement.dropShadow.enabled = enabled;
            document.getElementById('dropShadowControls').style.display = enabled ? 'block' : 'none';
            render();
        }

        // P27: Update drop shadow properties
        function updateDropShadow(prop, value) {
            if (!selectedElement || !selectedElement.dropShadow) return;

            if (prop === 'offsetX') {
                selectedElement.dropShadow.offsetX = parseFloat(value);
                document.getElementById('dropShadowXValue').textContent = value + 'px';
            } else if (prop === 'offsetY') {
                selectedElement.dropShadow.offsetY = parseFloat(value);
                document.getElementById('dropShadowYValue').textContent = value + 'px';
            } else if (prop === 'blur') {
                selectedElement.dropShadow.blur = parseFloat(value);
                document.getElementById('dropShadowBlurValue').textContent = value + 'px';
            } else if (prop === 'color') {
                // Parse existing color to get alpha
                const currentColor = selectedElement.dropShadow.color;
                const alpha = currentColor.includes('rgba') ?
                    parseFloat(currentColor.split(',')[3]) : 0.3;

                // Convert hex to rgba
                const r = parseInt(value.substr(1, 2), 16);
                const g = parseInt(value.substr(3, 2), 16);
                const b = parseInt(value.substr(5, 2), 16);
                selectedElement.dropShadow.color = `rgba(${r}, ${g}, ${b}, ${alpha})`;
            } else if (prop === 'opacity') {
                const opacity = parseFloat(value) / 100;
                document.getElementById('dropShadowOpacityValue').textContent = value + '%';

                // Update color with new opacity
                const colorInput = document.getElementById('dropShadowColor').value;
                const r = parseInt(colorInput.substr(1, 2), 16);
                const g = parseInt(colorInput.substr(3, 2), 16);
                const b = parseInt(colorInput.substr(5, 2), 16);
                selectedElement.dropShadow.color = `rgba(${r}, ${g}, ${b}, ${opacity})`;
            }

            render();
        }

        function updateLayersList() {
            const layersList = document.getElementById('layersList');

            if (elements.length === 0) {
                layersList.innerHTML = '<div style="padding: 20px; text-align: center; color: #999;">ÏöîÏÜåÎ•º Ï∂îÍ∞ÄÌïòÏÑ∏Ïöî</div>';
                return;
            }

            // P17: Filter elements based on search and type filter
            let filteredElements = elements.filter(element => {
                // Type filter
                let typeMatch = true;
                if (layerFilter === 'text') {
                    typeMatch = element.type === 'text';
                } else if (layerFilter === 'image') {
                    typeMatch = element.type === 'image';
                } else if (layerFilter === 'shape') {
                    typeMatch = ['rect', 'circle', 'triangle', 'star', 'diamond', 'hexagon',
                                 'speech-bubble', 'cloud', 'line', 'arrow', 'pencil'].includes(element.type);
                }

                // Search filter
                let searchMatch = true;
                if (layerSearchTerm) {
                    const searchLower = layerSearchTerm.toLowerCase();
                    if (element.type === 'text') {
                        searchMatch = element.text.toLowerCase().includes(searchLower);
                    } else {
                        searchMatch = element.type.toLowerCase().includes(searchLower);
                    }
                }

                return typeMatch && searchMatch;
            });

            if (filteredElements.length === 0) {
                layersList.innerHTML = '<div style="padding: 20px; text-align: center; color: #999;">Í≤ÄÏÉâ Í≤∞Í≥ºÍ∞Ä ÏóÜÏäµÎãàÎã§</div>';
                return;
            }

            layersList.innerHTML = '';
            for (let i = elements.length - 1; i >= 0; i--) {
                const element = elements[i];

                // P17: Skip if element doesn't match filter
                if (!filteredElements.includes(element)) continue;
                const layer = document.createElement('div');
                layer.className = 'layer-item' + (element === selectedElement ? ' active' : '');
                layer.onclick = () => {
                    selectedElement = element;
                    updatePropertiesPanel();
                    updateLayersList();
                    render();
                };

                let icon = '';
                switch (element.type) {
                    case 'rect': icon = '‚ñ¢'; break;
                    case 'circle': icon = '‚óã'; break;
                    case 'triangle': icon = '‚ñ≥'; break;
                    case 'star': icon = '‚òÖ'; break;
                    case 'diamond': icon = '‚óÜ'; break;
                    case 'hexagon': icon = '‚¨¢'; break;
                    case 'speech-bubble': icon = 'üí¨'; break;
                    case 'cloud': icon = '‚òÅÔ∏è'; break;
                    case 'line': icon = '‚îÄ'; break;
                    case 'arrow': icon = '‚Üí'; break;
                    case 'text': icon = 'T'; break;
                    case 'image': icon = 'üñºÔ∏è'; break;
                    case 'pencil': icon = '‚úèÔ∏è'; break;
                }

                layer.innerHTML = `
                    <div><span class="layer-icon">${icon}</span>${element.type === 'text' ? element.text.substring(0, 15) : element.type}</div>
                    <div class="layer-actions">
                        <button class="layer-btn" onclick="event.stopPropagation(); toggleLayerVisibility(${i})">${element.visible ? 'üëÅÔ∏è' : 'üö´'}</button>
                        <button class="layer-btn" onclick="event.stopPropagation(); toggleLayerLock(${i})">${element.locked ? 'üîí' : 'üîì'}</button>
                    </div>
                `;
                layersList.appendChild(layer);
            }
        }

        function toggleLayerVisibility(index) {
            const actualIndex = elements.length - 1 - index;
            elements[actualIndex].visible = !elements[actualIndex].visible;
            updateLayersList();
            render();
        }

        function toggleLayerLock(index) {
            const actualIndex = elements.length - 1 - index;
            elements[actualIndex].locked = !elements[actualIndex].locked;
            updateLayersList();
        }

        // P18: Smart Alignment Guide Calculation
        function calculateSnapGuides(targetX, targetY, targetElement) {
            const guides = { vertical: [], horizontal: [] };
            let snappedX = targetX;
            let snappedY = targetY;

            // Key points of target element
            const targetPoints = {
                left: targetX,
                centerX: targetX + targetElement.width / 2,
                right: targetX + targetElement.width,
                top: targetY,
                centerY: targetY + targetElement.height / 2,
                bottom: targetY + targetElement.height
            };

            let minDistX = Infinity;
            let minDistY = Infinity;

            // Compare with other elements
            elements.forEach(element => {
                if (element === targetElement || !element.visible || element.locked) return;

                const elementPoints = {
                    left: element.x,
                    centerX: element.x + element.width / 2,
                    right: element.x + element.width,
                    top: element.y,
                    centerY: element.y + element.height / 2,
                    bottom: element.y + element.height
                };

                // Check vertical alignment
                ['left', 'centerX', 'right'].forEach(targetKey => {
                    ['left', 'centerX', 'right'].forEach(elementKey => {
                        const dist = Math.abs(targetPoints[targetKey] - elementPoints[elementKey]);
                        if (dist < SNAP_THRESHOLD && dist < minDistX) {
                            minDistX = dist;
                            const offset = elementPoints[elementKey] - targetPoints[targetKey];
                            snappedX = targetX + offset;
                            guides.vertical = [elementPoints[elementKey]];
                        }
                    });
                });

                // Check horizontal alignment
                ['top', 'centerY', 'bottom'].forEach(targetKey => {
                    ['top', 'centerY', 'bottom'].forEach(elementKey => {
                        const dist = Math.abs(targetPoints[targetKey] - elementPoints[elementKey]);
                        if (dist < SNAP_THRESHOLD && dist < minDistY) {
                            minDistY = dist;
                            const offset = elementPoints[elementKey] - targetPoints[targetKey];
                            snappedY = targetY + offset;
                            guides.horizontal = [elementPoints[elementKey]];
                        }
                    });
                });
            });

            // If no snap, apply grid snap
            if (minDistX === Infinity) {
                snappedX = Math.round(targetX / 10) * 10;
            }
            if (minDistY === Infinity) {
                snappedY = Math.round(targetY / 10) * 10;
            }

            return { x: snappedX, y: snappedY, guides };
        }

        // P17: Layer Search & Filter Functions
        function filterLayers() {
            layerSearchTerm = document.getElementById('layerSearch').value;
            updateLayersList();
        }

        function setLayerFilter(filter) {
            layerFilter = filter;

            // Update button states
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });

            // Capitalize first letter for ID (filterAll, filterText, etc.)
            const filterId = 'filter' + filter.charAt(0).toUpperCase() + filter.slice(1);
            const filterBtn = document.getElementById(filterId);
            if (filterBtn) {
                filterBtn.classList.add('active');
            }

            updateLayersList();
        }

        function moveLayer(direction) {
            if (!selectedElement) return;

            const index = elements.indexOf(selectedElement);
            if (direction === 'up' && index < elements.length - 1) {
                [elements[index], elements[index + 1]] = [elements[index + 1], elements[index]];
            } else if (direction === 'down' && index > 0) {
                [elements[index], elements[index - 1]] = [elements[index - 1], elements[index]];
            }

            updateLayersList();
            render();
        }

        function deleteSelected() {
            if (!selectedElement) return;

            const index = elements.indexOf(selectedElement);
            if (index > -1) {
                elements.splice(index, 1);
                selectedElement = null;
                saveHistory();
                updatePropertiesPanel();
                updateLayersList();
                render();
            }
        }

        function groupElements() {
            if (selectedElements.length < 2) {
                alert('Í∑∏Î£πÌôîÌïòÎ†§Î©¥ 2Í∞ú Ïù¥ÏÉÅÏùò ÏöîÏÜåÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.');
                return;
            }

            const groupId = nextGroupId++;
            selectedElements.forEach(el => {
                el.groupId = groupId;
            });

            saveHistory();
            alert(`${selectedElements.length}Í∞úÏùò ÏöîÏÜåÍ∞Ä Í∑∏Î£πÌôîÎêòÏóàÏäµÎãàÎã§.`);
        }

        function ungroupElements() {
            if (!selectedElement || !selectedElement.groupId) {
                alert('Í∑∏Î£πÌôîÎêú ÏöîÏÜåÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.');
                return;
            }

            const groupId = selectedElement.groupId;
            elements.forEach(el => {
                if (el.groupId === groupId) {
                    el.groupId = null;
                }
            });

            saveHistory();
            alert('Í∑∏Î£πÏù¥ Ìï¥Ï†úÎêòÏóàÏäµÎãàÎã§.');
        }

        function selectAll() {
            selectedElements = elements.filter(el => el.visible && !el.locked);
            if (selectedElements.length > 0) {
                selectedElement = selectedElements[0];
                updatePropertiesPanel();
                updateLayersList();
                render();
            }
        }

        function copySelected() {
            if (!selectedElement) return;

            clipboard = JSON.parse(JSON.stringify({
                ...selectedElement,
                imageData: null,
                imageDataId: selectedElement.type === 'image' ? selectedElement.id : null
            }));
        }

        function pasteClipboard() {
            if (!clipboard) return;

            const el = new Element(clipboard.type, clipboard.x + 20, clipboard.y + 20, clipboard.width, clipboard.height);
            Object.assign(el, clipboard);
            el.id = Date.now() + Math.random();

            // Restore image data from cache
            if (clipboard.type === 'image' && clipboard.imageDataId) {
                const cachedImage = imageCache.get(clipboard.imageDataId);
                if (cachedImage) {
                    el.imageData = cachedImage;
                    imageCache.set(el.id, cachedImage);
                }
            }

            elements.push(el);
            selectedElement = el;
            selectedElements = [el];
            saveHistory();
            updatePropertiesPanel();
            updateLayersList();
            render();
        }

        function duplicateSelected() {
            if (!selectedElement) return;

            copySelected();
            pasteClipboard();
        }

        // P20: Enhanced Keyboard Shortcuts
        function toggleSelectedLock() {
            if (!selectedElement) return;

            selectedElement.locked = !selectedElement.locked;
            updateLayersList();
            render();
        }

        function duplicateInPlace() {
            if (!selectedElement) return;

            clipboard = JSON.parse(JSON.stringify({
                ...selectedElement,
                imageData: null,
                imageDataId: selectedElement.type === 'image' ? selectedElement.id : null
            }));

            const el = new Element(clipboard.type, clipboard.x, clipboard.y, clipboard.width, clipboard.height);
            Object.assign(el, clipboard);
            el.id = Date.now() + Math.random();

            // Restore image data from cache
            if (clipboard.type === 'image' && clipboard.imageDataId) {
                const cachedImage = imageCache.get(clipboard.imageDataId);
                if (cachedImage) {
                    el.imageData = cachedImage;
                    imageCache.set(el.id, cachedImage);
                }
            }

            elements.push(el);
            selectedElement = el;
            selectedElements = [el];
            saveHistory();
            updatePropertiesPanel();
            updateLayersList();
            render();
        }

        function moveSelectedByArrow(key, ctrlKey) {
            if (!selectedElement) return;

            const step = ctrlKey ? 10 : 1;
            const elementsToMove = selectedElements.length > 1 ? selectedElements : [selectedElement];

            elementsToMove.forEach(el => {
                if (el.locked) return;

                switch (key) {
                    case 'ArrowUp':
                        el.y -= step;
                        break;
                    case 'ArrowDown':
                        el.y += step;
                        break;
                    case 'ArrowLeft':
                        el.x -= step;
                        break;
                    case 'ArrowRight':
                        el.x += step;
                        break;
                }
            });

            updatePropertiesPanel();
            render();
        }

        function alignElements(alignment) {
            if (!selectedElement) return;

            switch (alignment) {
                case 'left':
                    selectedElement.x = 0;
                    break;
                case 'center':
                    selectedElement.x = (canvas.width - selectedElement.width) / 2;
                    break;
                case 'right':
                    selectedElement.x = canvas.width - selectedElement.width;
                    break;
                case 'top':
                    selectedElement.y = 0;
                    break;
                case 'middle':
                    selectedElement.y = (canvas.height - selectedElement.height) / 2;
                    break;
                case 'bottom':
                    selectedElement.y = canvas.height - selectedElement.height;
                    break;
            }

            updatePropertiesPanel();
            render();
        }

        function saveHistory() {
            history = history.slice(0, historyIndex + 1);

            // Serialize elements without image data
            const serialized = elements.map(el => {
                const copy = {...el};
                if (el.type === 'image' && el.imageData) {
                    // Cache the image and store only the ID
                    const imageId = el.id;
                    imageCache.set(imageId, el.imageData);
                    copy.imageDataId = imageId;
                    delete copy.imageData;
                }
                return copy;
            });

            history.push(JSON.stringify(serialized));
            historyIndex++;

            document.getElementById('undoBtn').disabled = historyIndex <= 0;
            document.getElementById('redoBtn').disabled = true;

            // Limit history to 50 entries to prevent memory issues
            if (history.length > 50) {
                history.shift();
                historyIndex--;
            }

            // P30: Mark as having unsaved changes
            markAsUnsaved();
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                restoreFromHistory();

                document.getElementById('undoBtn').disabled = historyIndex <= 0;
                document.getElementById('redoBtn').disabled = false;
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                restoreFromHistory();

                document.getElementById('undoBtn').disabled = false;
                document.getElementById('redoBtn').disabled = historyIndex >= history.length - 1;
            }
        }

        function restoreFromHistory() {
            const serialized = JSON.parse(history[historyIndex]);
            elements = serialized.map(data => {
                const el = new Element(data.type, data.x, data.y, data.width, data.height);
                Object.assign(el, data);

                // Restore image data from cache
                if (data.type === 'image' && data.imageDataId) {
                    el.imageData = imageCache.get(data.imageDataId) || null;
                }

                return el;
            });

            selectedElement = null;
            selectedElements = [];
            updatePropertiesPanel();
            updateLayersList();
            render();
        }

        async function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    const element = new Element('image', 100, 100, img.width, img.height);
                    element.imageData = img;
                    elements.push(element);
                    selectedElement = element;
                    saveHistory();
                    updatePropertiesPanel();
                    updateLayersList();
                    render();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        async function generateAIImage() {
            const prompt = document.getElementById('aiPrompt').value.trim();
            if (!prompt) {
                alert('ÌîÑÎ°¨ÌîÑÌä∏Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
                return;
            }

            const aiBtn = document.getElementById('aiBtn');
            const aiMessage = document.getElementById('aiMessage');

            aiBtn.disabled = true;
            aiBtn.textContent = 'ÏÉùÏÑ± Ï§ë...';
            aiMessage.innerHTML = '<div class="message loading">AIÍ∞Ä Ïù¥ÎØ∏ÏßÄÎ•º ÏÉùÏÑ±ÌïòÍ≥† ÏûàÏäµÎãàÎã§...</div>';

            try {
                const size = document.getElementById('aiSize').value;
                const response = await fetchWithRetry(`${PYTHON_API_URL}/generate-image`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt, size, quality: 'standard' })
                });

                const data = await response.json();
                if (response.ok && data.success) {
                    const img = new Image();
                    img.onload = function() {
                        const element = new Element('image', 50, 50, 400, 400);
                        element.imageData = img;
                        elements.push(element);
                        selectedElement = element;
                        saveHistory();
                        updatePropertiesPanel();
                        updateLayersList();
                        render();

                        aiMessage.innerHTML = '<div class="message success">Ïù¥ÎØ∏ÏßÄÍ∞Ä ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§!</div>';
                        setTimeout(() => aiMessage.innerHTML = '', 3000);
                    };
                    img.src = data.imageData;
                } else {
                    throw new Error('Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ± Ïã§Ìå®');
                }
            } catch (error) {
                aiMessage.innerHTML = '<div class="message error">Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ± Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.</div>';
            } finally {
                aiBtn.disabled = false;
                aiBtn.textContent = 'Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ±';
            }
        }

        // P30: Update save status indicator
        function updateSaveStatus(status) {
            const statusEl = document.getElementById('saveStatusText');
            const saveStatusDiv = document.getElementById('saveStatus');

            if (status === 'saving') {
                statusEl.textContent = 'Ï†ÄÏû• Ï§ë...';
                saveStatusDiv.style.color = '#ffa500';
            } else if (status === 'saved') {
                statusEl.textContent = 'Ï†ÄÏû•Îê®';
                saveStatusDiv.style.color = '#10b981';
                hasUnsavedChanges = false;
            } else if (status === 'unsaved') {
                statusEl.textContent = 'Ï†ÄÏû•ÎêòÏßÄ ÏïäÏùå';
                saveStatusDiv.style.color = '#999';
                hasUnsavedChanges = true;
            } else if (status === 'error') {
                statusEl.textContent = 'Ï†ÄÏû• Ïã§Ìå®';
                saveStatusDiv.style.color = '#ef4444';
            }
        }

        // P30: Mark as having unsaved changes
        function markAsUnsaved() {
            if (!hasUnsavedChanges) {
                updateSaveStatus('unsaved');
            }
        }

        // P30: Start auto-save to server
        function startAutoSave() {
            // Auto-save every 30 seconds if there are unsaved changes
            autoSaveInterval = setInterval(() => {
                if (hasUnsavedChanges && currentProjectId) {
                    saveProject();
                }
            }, 30 * 1000); // 30 seconds
        }

        async function saveProject() {
            if (!currentProjectId) {
                alert('ÌîÑÎ°úÏ†ùÌä∏ IDÍ∞Ä ÏóÜÏäµÎãàÎã§.');
                return;
            }

            const saveMessage = document.getElementById('saveMessage');
            saveMessage.innerHTML = '<div class="message loading">Ï†ÄÏû• Ï§ë...</div>';
            updateSaveStatus('saving'); // P30: Update status indicator

            try {
                const token = localStorage.getItem('token');

                // Save canvas as image
                const canvasData = canvas.toDataURL('image/jpeg', 0.8);

                const projectData = {
                    image: canvasData,
                    elements: elements.map(el => ({
                        ...el,
                        imageData: el.imageData ? el.imageData.src : null
                    })),
                    prompt: document.getElementById('aiPrompt').value,
                    lastModified: new Date().toISOString()
                };

                const response = await fetchWithRetry(`${API_URL}/projects/${currentProjectId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + token
                    },
                    body: JSON.stringify({
                        data: JSON.stringify(projectData)
                    })
                });

                if (response.ok) {
                    lastSaveTime = new Date();
                    lastAutoSaveTime = new Date(); // P30: Track auto-save time
                    saveMessage.innerHTML = '<div class="message success">ÌîÑÎ°úÏ†ùÌä∏Í∞Ä Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§!</div>';
                    setTimeout(() => saveMessage.innerHTML = '', 3000);
                    updateSaveStatus('saved'); // P30: Update status indicator
                } else {
                    throw new Error('Ï†ÄÏû• Ïã§Ìå®');
                }
            } catch (error) {
                saveMessage.innerHTML = '<div class="message error">Ï†ÄÏû• Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. Ïû¨ÏãúÎèÑÌï©ÎãàÎã§...</div>';
                console.error('Save error:', error);
                updateSaveStatus('error'); // P30: Update status indicator
            }
        }

        async function loadProject(projectId) {
            try {
                const token = localStorage.getItem('token');
                const response = await fetch(`${API_URL}/projects/${projectId}`, {
                    headers: { 'Authorization': 'Bearer ' + token }
                });

                if (response.ok) {
                    const project = await response.json();
                    document.getElementById('projectName').textContent = project.name;

                    if (project.data) {
                        try {
                            const data = JSON.parse(project.data);
                            if (data.prompt) {
                                document.getElementById('aiPrompt').value = data.prompt;
                            }
                            if (data.elements) {
                                // Restore elements
                                elements = [];
                                for (let elData of data.elements) {
                                    const el = new Element(elData.type, elData.x, elData.y, elData.width, elData.height);
                                    Object.assign(el, elData);

                                    if (elData.imageData) {
                                        const img = new Image();
                                        img.onload = () => render();
                                        img.src = elData.imageData;
                                        el.imageData = img;
                                    }

                                    elements.push(el);
                                }
                                saveHistory();
                                updateLayersList();
                                render();
                            } else if (data.image) {
                                // Load legacy image
                                const img = new Image();
                                img.onload = function() {
                                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                                };
                                img.src = data.image;
                            }
                        } catch (e) {
                            console.log('No saved data');
                            render();
                        }
                    } else {
                        render();
                    }
                }
            } catch (error) {
                console.error('Load error:', error);
                render();
            }
        }

        // Export Functions
        function showExportModal() {
            document.getElementById('exportModal').classList.add('active');

            // Set default filename from project name
            const projectName = document.getElementById('projectName').textContent || 'artify-design';
            document.getElementById('exportFileName').value = projectName.replace(/\s+/g, '-');
        }

        function closeExportModal() {
            document.getElementById('exportModal').classList.remove('active');
        }

        function selectExportFormat(format) {
            exportFormat = format;

            // Update button states
            document.querySelectorAll('.export-format-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById('format' + format.charAt(0).toUpperCase() + format.slice(1)).classList.add('active');

            // Show/hide resolution options for SVG
            const resolutionGroup = document.getElementById('resolutionGroup');
            const qualityGroup = document.getElementById('qualityGroup');

            if (format === 'svg') {
                resolutionGroup.style.display = 'none';
                qualityGroup.style.display = 'none';
            } else {
                resolutionGroup.style.display = 'block';
                qualityGroup.style.display = format === 'jpg' ? 'block' : 'none';
            }
        }

        function selectExportResolution(resolution) {
            exportResolution = resolution;

            // Update button states
            document.querySelectorAll('.export-resolution-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById('res' + resolution + 'x').classList.add('active');
        }

        function updateQualityLabel(value) {
            document.getElementById('qualityValue').textContent = value + '%';
            exportQuality = value / 100;
        }

        async function executeExport() {
            const fileName = document.getElementById('exportFileName').value || 'artify-design';

            try {
                if (exportFormat === 'svg') {
                    exportAsSVG(fileName);
                } else if (exportFormat === 'png') {
                    exportAsPNG(fileName, exportResolution);
                } else if (exportFormat === 'jpg') {
                    exportAsJPG(fileName, exportResolution, exportQuality);
                }

                closeExportModal();
            } catch (error) {
                console.error('Export error:', error);
                alert('ÎÇ¥Î≥¥ÎÇ¥Í∏∞ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
            }
        }

        function exportAsPNG(fileName, scale) {
            // Create a temporary canvas with scaled dimensions
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width * scale;
            tempCanvas.height = canvas.height * scale;
            const tempCtx = tempCanvas.getContext('2d');

            // Scale the context
            tempCtx.scale(scale, scale);

            // Fill white background
            tempCtx.fillStyle = '#ffffff';
            tempCtx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw all elements
            for (let element of elements) {
                element.draw(tempCtx);
            }

            // Convert to blob and download
            tempCanvas.toBlob((blob) => {
                downloadBlob(blob, fileName + '.png');
            }, 'image/png');
        }

        function exportAsJPG(fileName, scale, quality) {
            // Create a temporary canvas with scaled dimensions
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width * scale;
            tempCanvas.height = canvas.height * scale;
            const tempCtx = tempCanvas.getContext('2d');

            // Scale the context
            tempCtx.scale(scale, scale);

            // Fill white background (JPEG doesn't support transparency)
            tempCtx.fillStyle = '#ffffff';
            tempCtx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw all elements
            for (let element of elements) {
                element.draw(tempCtx);
            }

            // Convert to blob and download
            tempCanvas.toBlob((blob) => {
                downloadBlob(blob, fileName + '.jpg');
            }, 'image/jpeg', quality);
        }

        function exportAsSVG(fileName) {
            // Create SVG with all elements
            let svgContent = `<svg xmlns="http://www.w3.org/2000/svg" width="${canvas.width}" height="${canvas.height}" viewBox="0 0 ${canvas.width} ${canvas.height}">`;

            // White background
            svgContent += `<rect x="0" y="0" width="${canvas.width}" height="${canvas.height}" fill="#ffffff"/>`;

            // Convert each element to SVG
            for (let element of elements) {
                if (!element.visible) continue;

                const transform = `translate(${element.x + element.width / 2}, ${element.y + element.height / 2}) rotate(${element.rotation}) translate(-${element.x + element.width / 2}, -${element.y + element.height / 2})`;

                switch (element.type) {
                    case 'rect':
                        if (element.gradient && element.gradient.enabled) {
                            const gradId = 'grad-' + element.id;
                            const angle = element.gradient.angle * Math.PI / 180;
                            const x1 = 50 - Math.cos(angle) * 50;
                            const y1 = 50 - Math.sin(angle) * 50;
                            const x2 = 50 + Math.cos(angle) * 50;
                            const y2 = 50 + Math.sin(angle) * 50;

                            svgContent += `<defs><linearGradient id="${gradId}" x1="${x1}%" y1="${y1}%" x2="${x2}%" y2="${y2}%">`;
                            svgContent += `<stop offset="0%" stop-color="${element.gradient.color1}"/>`;
                            svgContent += `<stop offset="100%" stop-color="${element.gradient.color2}"/>`;
                            svgContent += `</linearGradient></defs>`;
                            svgContent += `<rect x="${element.x}" y="${element.y}" width="${element.width}" height="${element.height}" fill="url(#${gradId})" stroke="${element.stroke}" stroke-width="${element.strokeWidth}" opacity="${element.opacity}" transform="${transform}"/>`;
                        } else {
                            svgContent += `<rect x="${element.x}" y="${element.y}" width="${element.width}" height="${element.height}" fill="${element.fill}" stroke="${element.stroke}" stroke-width="${element.strokeWidth}" opacity="${element.opacity}" transform="${transform}"/>`;
                        }
                        break;

                    case 'circle':
                        const cx = element.x + element.width / 2;
                        const cy = element.y + element.height / 2;
                        const rx = element.width / 2;
                        const ry = element.height / 2;
                        svgContent += `<ellipse cx="${cx}" cy="${cy}" rx="${rx}" ry="${ry}" fill="${element.fill}" stroke="${element.stroke}" stroke-width="${element.strokeWidth}" opacity="${element.opacity}" transform="${transform}"/>`;
                        break;

                    case 'triangle':
                        const x1 = element.x + element.width / 2;
                        const y1 = element.y;
                        const x2 = element.x + element.width;
                        const y2 = element.y + element.height;
                        const x3 = element.x;
                        const y3 = element.y + element.height;
                        svgContent += `<polygon points="${x1},${y1} ${x2},${y2} ${x3},${y3}" fill="${element.fill}" stroke="${element.stroke}" stroke-width="${element.strokeWidth}" opacity="${element.opacity}" transform="${transform}"/>`;
                        break;

                    case 'line':
                        svgContent += `<line x1="${element.x}" y1="${element.y}" x2="${element.x + element.width}" y2="${element.y + element.height}" stroke="${element.stroke}" stroke-width="${element.strokeWidth}" opacity="${element.opacity}" transform="${transform}"/>`;
                        break;

                    case 'text':
                        let fontWeight = element.bold ? 'bold' : 'normal';
                        let fontStyle = element.italic ? 'italic' : 'normal';
                        let textDecoration = element.underline ? 'underline' : 'none';
                        let textAnchor = element.textAlign === 'center' ? 'middle' : element.textAlign === 'right' ? 'end' : 'start';
                        let textX = element.x;
                        if (element.textAlign === 'center') textX += element.width / 2;
                        else if (element.textAlign === 'right') textX += element.width;

                        // Add text shadow if enabled
                        let textFilter = '';
                        if (element.textShadow && element.textShadow.enabled) {
                            const filterId = 'shadow-' + element.id;
                            svgContent += `<defs><filter id="${filterId}">`;
                            svgContent += `<feDropShadow dx="${element.textShadow.offsetX}" dy="${element.textShadow.offsetY}" stdDeviation="${element.textShadow.blur / 2}" flood-color="${element.textShadow.color}"/>`;
                            svgContent += `</filter></defs>`;
                            textFilter = ` filter="url(#${filterId})"`;
                        }

                        svgContent += `<text x="${textX}" y="${element.y}" font-family="${element.fontFamily}" font-size="${element.fontSize}" font-weight="${fontWeight}" font-style="${fontStyle}" text-decoration="${textDecoration}" text-anchor="${textAnchor}" fill="${element.fill}" opacity="${element.opacity}" transform="${transform}"${textFilter}>${escapeXml(element.text)}</text>`;
                        break;

                    case 'pencil':
                        if (element.points.length > 0) {
                            let pathData = `M ${element.points[0].x} ${element.points[0].y}`;
                            for (let i = 1; i < element.points.length; i++) {
                                pathData += ` L ${element.points[i].x} ${element.points[i].y}`;
                            }
                            svgContent += `<path d="${pathData}" stroke="${element.stroke}" stroke-width="${element.strokeWidth}" fill="none" stroke-linecap="round" stroke-linejoin="round" opacity="${element.opacity}"/>`;
                        }
                        break;
                }
            }

            svgContent += '</svg>';

            // Download SVG
            const blob = new Blob([svgContent], { type: 'image/svg+xml' });
            downloadBlob(blob, fileName + '.svg');
        }

        function escapeXml(text) {
            return text.replace(/&/g, '&amp;')
                       .replace(/</g, '&lt;')
                       .replace(/>/g, '&gt;')
                       .replace(/"/g, '&quot;')
                       .replace(/'/g, '&apos;');
        }

        function downloadBlob(blob, fileName) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Close modal when clicking outside
        document.addEventListener('click', function(e) {
            const exportModal = document.getElementById('exportModal');
            const templateModal = document.getElementById('templateModal');
            const templateLibraryModal = document.getElementById('templateLibraryModal');
            const keyboardShortcutsModal = document.getElementById('keyboardShortcutsModal');

            if (e.target === exportModal) {
                closeExportModal();
            }
            if (e.target === templateModal) {
                closeTemplateModal();
            }
            if (e.target === templateLibraryModal) {
                closeTemplateLibraryModal();
            }
            if (e.target === keyboardShortcutsModal) {
                closeKeyboardShortcutsModal();
            }
        });

        // Template Functions
        function showTemplateModal() {
            document.getElementById('templateModal').classList.add('active');

            // Set current canvas size in custom inputs
            document.getElementById('customWidth').value = canvas.width;
            document.getElementById('customHeight').value = canvas.height;
        }

        function closeTemplateModal() {
            document.getElementById('templateModal').classList.remove('active');

            // Clear active state from all cards
            document.querySelectorAll('.template-card').forEach(card => {
                card.classList.remove('active');
            });
            selectedTemplate = null;
        }

        function selectTemplate(templateId) {
            selectedTemplate = templateId;

            // Update active state
            document.querySelectorAll('.template-card').forEach(card => {
                card.classList.remove('active');
            });
            event.target.closest('.template-card').classList.add('active');

            // Update custom inputs with template size
            const template = templates[templateId];
            if (template) {
                document.getElementById('customWidth').value = template.width;
                document.getElementById('customHeight').value = template.height;
            }
        }

        function applyTemplate() {
            const newWidth = parseInt(document.getElementById('customWidth').value);
            const newHeight = parseInt(document.getElementById('customHeight').value);

            if (!newWidth || !newHeight || newWidth < 100 || newHeight < 100) {
                alert('Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞Îäî ÏµúÏÜå 100x100 Ïù¥ÏÉÅÏù¥Ïñ¥Ïïº Ìï©ÎãàÎã§.');
                return;
            }

            if (newWidth > 5000 || newHeight > 5000) {
                alert('Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞Îäî ÏµúÎåÄ 5000x5000ÍπåÏßÄ Í∞ÄÎä•Ìï©ÎãàÎã§.');
                return;
            }

            // Confirm if there are elements on the canvas
            if (elements.length > 0) {
                const confirmed = confirm('Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞Î•º Î≥ÄÍ≤ΩÌïòÎ©¥ ÏùºÎ∂Ä ÏöîÏÜåÍ∞Ä Î≥¥Ïù¥ÏßÄ ÏïäÏùÑ Ïàò ÏûàÏäµÎãàÎã§. Í≥ÑÏÜçÌïòÏãúÍ≤†ÏäµÎãàÍπå?');
                if (!confirmed) return;
            }

            // Resize canvas
            canvas.width = newWidth;
            canvas.height = newHeight;

            // Re-render
            isDirty = true;
            render();

            closeTemplateModal();

            // Show success message
            alert(`Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞Í∞Ä ${newWidth}x${newHeight}ÏúºÎ°ú Î≥ÄÍ≤ΩÎêòÏóàÏäµÎãàÎã§.`);
        }

        // Template Library Functions
        let templatesCache = [];
        let currentTemplateFilter = 'all';

        async function showTemplateLibraryModal() {
            document.getElementById('templateLibraryModal').classList.add('active');

            // Load templates if not already loaded
            if (templatesCache.length === 0) {
                await loadTemplates();
            } else {
                renderTemplates();
            }
        }

        function closeTemplateLibraryModal() {
            document.getElementById('templateLibraryModal').classList.remove('active');
        }

        async function loadTemplates() {
            const grid = document.getElementById('templatesGrid');
            grid.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: #999;">ÌÖúÌîåÎ¶øÏùÑ Î∂àÎü¨Ïò§Îäî Ï§ë...</div>';

            try {
                const response = await fetch(`${API_BASE_URL}/templates/creatives?limit=50`);

                if (!response.ok) {
                    throw new Error('Failed to load templates');
                }

                const templates = await response.json();
                templatesCache = templates;

                if (templates.length === 0) {
                    grid.innerHTML = `
                        <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: #999;">
                            <div style="font-size: 48px; margin-bottom: 16px;">üìã</div>
                            <div>ÏïÑÏßÅ Îì±Î°ùÎêú ÌÖúÌîåÎ¶øÏù¥ ÏóÜÏäµÎãàÎã§.</div>
                            <div style="font-size: 14px; margin-top: 8px;">ÌÖúÌîåÎ¶øÏùÑ ÏÉùÏÑ±ÌïòÏó¨ ÏãúÏûëÌïòÏÑ∏Ïöî!</div>
                        </div>
                    `;
                } else {
                    renderTemplates();
                }
            } catch (error) {
                console.error('Template loading error:', error);
                grid.innerHTML = `
                    <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: #ff6b6b;">
                        <div style="font-size: 48px; margin-bottom: 16px;">‚ö†Ô∏è</div>
                        <div>ÌÖúÌîåÎ¶øÏùÑ Î∂àÎü¨Ïò§ÎäîÎç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§.</div>
                        <div style="font-size: 14px; margin-top: 8px;">${error.message}</div>
                        <button onclick="loadTemplates()" style="margin-top: 16px; padding: 8px 16px; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer;">Îã§Ïãú ÏãúÎèÑ</button>
                    </div>
                `;
            }
        }

        function filterTemplates(category) {
            currentTemplateFilter = category;

            // Update filter button states
            document.querySelectorAll('.template-filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            renderTemplates();
        }

        function renderTemplates() {
            const grid = document.getElementById('templatesGrid');

            // Filter templates
            let filtered = templatesCache;
            if (currentTemplateFilter !== 'all') {
                filtered = templatesCache.filter(t =>
                    t.category === currentTemplateFilter ||
                    t.channel === currentTemplateFilter
                );
            }

            if (filtered.length === 0) {
                grid.innerHTML = `
                    <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: #999;">
                        <div style="font-size: 48px; margin-bottom: 16px;">üîç</div>
                        <div>Ìï¥Îãπ Ïπ¥ÌÖåÍ≥†Î¶¨Ïóê ÌÖúÌîåÎ¶øÏù¥ ÏóÜÏäµÎãàÎã§.</div>
                    </div>
                `;
                return;
            }

            // Render template cards
            grid.innerHTML = filtered.map(template => `
                <div class="template-library-card" onclick="applyTemplateToCanvas(${template.id})">
                    <div class="template-preview">
                        ${template.preview_url ? `<img src="${template.preview_url}" alt="${template.name}">` : getCategoryIcon(template.category)}
                    </div>
                    <div class="template-info">
                        <div class="template-library-name" title="${template.name}">${template.name}</div>
                        <div class="template-library-desc" title="${template.description || ''}">${template.description || 'ÌÖúÌîåÎ¶ø ÏÑ§Î™Ö ÏóÜÏùå'}</div>
                        <div class="template-meta">
                            <span class="template-category">${template.category || 'general'}</span>
                            <span>üëÅ ${template.usage_count || 0}</span>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        function getCategoryIcon(category) {
            const icons = {
                'social': 'üì±',
                'banner': 'üé®',
                'poster': 'üñºÔ∏è',
                'presentation': 'üíº',
                'minimal': '‚ö™',
                'bold': 'üî•',
                'elegant': '‚ú®'
            };
            return `<div style="font-size: 64px;">${icons[category] || 'üìÑ'}</div>`;
        }

        async function applyTemplateToCanvas(templateId) {
            try {
                // Fetch template details
                const response = await fetch(`${API_BASE_URL}/templates/creatives/${templateId}`);
                if (!response.ok) {
                    throw new Error('Failed to load template details');
                }

                const template = await response.json();

                // Confirm if canvas has content
                if (elements.length > 0) {
                    const confirmed = confirm('ÌÖúÌîåÎ¶øÏùÑ Ï†ÅÏö©ÌïòÎ©¥ ÌòÑÏû¨ Ï∫îÎ≤ÑÏä§ ÎÇ¥Ïö©Ïù¥ ÎåÄÏ≤¥Îê©ÎãàÎã§. Í≥ÑÏÜçÌïòÏãúÍ≤†ÏäµÎãàÍπå?');
                    if (!confirmed) return;
                }

                // Clear current elements
                elements = [];
                selectedElement = null;
                selectedElements = [];

                // Apply template dimensions if specified
                if (template.layout_config && template.layout_config.dimensions) {
                    const { width, height } = template.layout_config.dimensions;
                    if (width && height) {
                        canvas.width = width;
                        canvas.height = height;
                    }
                }

                // Apply template elements from layout_config
                if (template.layout_config) {
                    applyTemplateLayout(template);
                }

                // Increment usage count
                try {
                    await fetch(`${API_BASE_URL}/templates/creatives/${templateId}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ usage_count: (template.usage_count || 0) + 1 })
                    });
                } catch (e) {
                    console.warn('Failed to increment usage count:', e);
                }

                // Re-render
                isDirty = true;
                render();

                closeTemplateLibraryModal();

                // Show success message
                showToast(`ÌÖúÌîåÎ¶ø "${template.name}"Ïù¥ Ï†ÅÏö©ÎêòÏóàÏäµÎãàÎã§!`, 'success');

            } catch (error) {
                console.error('Template application error:', error);
                alert('ÌÖúÌîåÎ¶øÏùÑ Ï†ÅÏö©ÌïòÎäîÎç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§: ' + error.message);
            }
        }

        function applyTemplateLayout(template) {
            // Apply text slots
            if (template.layout_config.text_slots) {
                template.layout_config.text_slots.forEach(slot => {
                    const textElement = {
                        id: Date.now() + Math.random(),
                        type: 'text',
                        x: slot.x || 50,
                        y: slot.y || 50,
                        width: slot.width || 200,
                        height: slot.height || 50,
                        text: slot.text || slot.id || 'Text',
                        fontSize: template.font_sizes?.[slot.id] || 24,
                        fontFamily: template.font_family || 'Arial',
                        fill: template.color_palette?.primary || '#000000',
                        textAlign: slot.align || 'left',
                        bold: false,
                        italic: false,
                        underline: false,
                        opacity: 1,
                        rotation: 0,
                        zIndex: elements.length
                    };
                    textElement.draw = function(context) { drawText(context, this); };
                    elements.push(textElement);
                });
            }

            // Apply image slots
            if (template.layout_config.image_slots) {
                template.layout_config.image_slots.forEach(slot => {
                    const rectElement = {
                        id: Date.now() + Math.random(),
                        type: 'rect',
                        x: slot.x || 50,
                        y: slot.y || 50,
                        width: slot.width || 200,
                        height: slot.height || 200,
                        fill: template.color_palette?.secondary || '#f0f0f0',
                        stroke: template.color_palette?.primary || '#000000',
                        strokeWidth: 2,
                        opacity: 1,
                        rotation: 0,
                        zIndex: elements.length
                    };
                    rectElement.draw = function(context) { drawRect(context, this); };
                    elements.push(rectElement);
                });
            }

            // Apply background if specified
            if (template.layout_config.background) {
                const bgElement = {
                    id: Date.now() + Math.random(),
                    type: 'rect',
                    x: 0,
                    y: 0,
                    width: canvas.width,
                    height: canvas.height,
                    fill: template.layout_config.background || template.color_palette?.background || '#ffffff',
                    stroke: 'transparent',
                    strokeWidth: 0,
                    opacity: 1,
                    rotation: 0,
                    zIndex: -1
                };
                bgElement.draw = function(context) { drawRect(context, this); };
                elements.unshift(bgElement); // Add as first element (background)
            }
        }

        function showToast(message, type = 'info') {
            // Simple toast notification
            const toast = document.createElement('div');
            toast.textContent = message;
            toast.style.cssText = `
                position: fixed;
                bottom: 20px;
                right: 20px;
                padding: 12px 20px;
                background: ${type === 'success' ? '#4caf50' : '#667eea'};
                color: white;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                z-index: 10000;
                animation: slideIn 0.3s ease-out;
            `;
            document.body.appendChild(toast);

            setTimeout(() => {
                toast.style.animation = 'slideOut 0.3s ease-out';
                setTimeout(() => document.body.removeChild(toast), 300);
            }, 3000);
        }

        // Keyboard Shortcuts Modal Functions
        function showKeyboardShortcutsModal() {
            document.getElementById('keyboardShortcutsModal').classList.add('active');
        }

        function closeKeyboardShortcutsModal() {
            document.getElementById('keyboardShortcutsModal').classList.remove('active');
        }

        // Crop Functions
        function startCropMode() {
            if (!selectedElement || selectedElement.type !== 'image') {
                alert('Ïù¥ÎØ∏ÏßÄÎ•º ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.');
                return;
            }

            isCropMode = true;
            cropElement = selectedElement;

            // Initialize crop rect to full image size
            cropRect = {
                x: selectedElement.x,
                y: selectedElement.y,
                width: selectedElement.width,
                height: selectedElement.height
            };

            showCropOverlay();
            setupCropHandlers();
        }

        function showCropOverlay() {
            const overlay = document.getElementById('cropOverlay');
            overlay.style.display = 'block';
            overlay.style.left = cropRect.x + 'px';
            overlay.style.top = cropRect.y + 'px';
            overlay.style.width = cropRect.width + 'px';
            overlay.style.height = cropRect.height + 'px';
        }

        function setupCropHandlers() {
            const overlay = document.getElementById('cropOverlay');
            const handles = overlay.querySelectorAll('.crop-handle');

            // Drag overlay to move crop area
            overlay.addEventListener('mousedown', function(e) {
                if (e.target.classList.contains('crop-handle')) {
                    cropResizeHandle = e.target.classList[1]; // nw, ne, sw, se
                } else if (e.target === overlay) {
                    cropDragStart = { x: e.clientX, y: e.clientY };
                }
                e.stopPropagation();
            });

            document.addEventListener('mousemove', function(e) {
                if (cropDragStart) {
                    // Move crop area
                    const dx = e.clientX - cropDragStart.x;
                    const dy = e.clientY - cropDragStart.y;

                    cropRect.x = Math.max(cropElement.x, Math.min(cropElement.x + cropElement.width - cropRect.width, cropRect.x + dx));
                    cropRect.y = Math.max(cropElement.y, Math.min(cropElement.y + cropElement.height - cropRect.height, cropRect.y + dy));

                    cropDragStart = { x: e.clientX, y: e.clientY };
                    showCropOverlay();
                } else if (cropResizeHandle) {
                    // Resize crop area
                    const dx = e.clientX - (cropRect.x + cropRect.width);
                    const dy = e.clientY - (cropRect.y + cropRect.height);

                    switch (cropResizeHandle) {
                        case 'se':
                            cropRect.width = Math.min(cropElement.x + cropElement.width - cropRect.x, Math.max(50, cropRect.width + dx));
                            cropRect.height = Math.min(cropElement.y + cropElement.height - cropRect.y, Math.max(50, cropRect.height + dy));
                            break;
                        case 'sw':
                            const newX = Math.max(cropElement.x, cropRect.x + dx);
                            const newWidth = cropRect.width - (newX - cropRect.x);
                            if (newWidth >= 50) {
                                cropRect.x = newX;
                                cropRect.width = newWidth;
                            }
                            cropRect.height = Math.min(cropElement.y + cropElement.height - cropRect.y, Math.max(50, cropRect.height + dy));
                            break;
                        case 'ne':
                            cropRect.width = Math.min(cropElement.x + cropElement.width - cropRect.x, Math.max(50, cropRect.width + dx));
                            const newY = Math.max(cropElement.y, cropRect.y + dy);
                            const newHeight = cropRect.height - (newY - cropRect.y);
                            if (newHeight >= 50) {
                                cropRect.y = newY;
                                cropRect.height = newHeight;
                            }
                            break;
                        case 'nw':
                            const newX2 = Math.max(cropElement.x, cropRect.x + dx);
                            const newWidth2 = cropRect.width - (newX2 - cropRect.x);
                            if (newWidth2 >= 50) {
                                cropRect.x = newX2;
                                cropRect.width = newWidth2;
                            }
                            const newY2 = Math.max(cropElement.y, cropRect.y + dy);
                            const newHeight2 = cropRect.height - (newY2 - cropRect.y);
                            if (newHeight2 >= 50) {
                                cropRect.y = newY2;
                                cropRect.height = newHeight2;
                            }
                            break;
                    }
                    showCropOverlay();
                }
            });

            document.addEventListener('mouseup', function() {
                cropDragStart = null;
                cropResizeHandle = null;
            });
        }

        function applyCrop() {
            if (!cropElement || !isCropMode) return;

            // Calculate crop area relative to image
            const cropX = (cropRect.x - cropElement.x) / cropElement.width;
            const cropY = (cropRect.y - cropElement.y) / cropElement.height;
            const cropW = cropRect.width / cropElement.width;
            const cropH = cropRect.height / cropElement.height;

            // Create new canvas to crop the image
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');

            const sourceWidth = cropElement.imageData.width * cropW;
            const sourceHeight = cropElement.imageData.height * cropH;

            tempCanvas.width = sourceWidth;
            tempCanvas.height = sourceHeight;

            // Draw cropped image
            tempCtx.drawImage(
                cropElement.imageData,
                cropElement.imageData.width * cropX,
                cropElement.imageData.height * cropY,
                sourceWidth,
                sourceHeight,
                0, 0,
                sourceWidth,
                sourceHeight
            );

            // Create new image from cropped canvas
            const croppedImg = new Image();
            croppedImg.onload = function() {
                cropElement.imageData = croppedImg;
                cropElement.x = cropRect.x;
                cropElement.y = cropRect.y;
                cropElement.width = cropRect.width;
                cropElement.height = cropRect.height;

                saveHistory();
                cancelCrop();
                render();
            };
            croppedImg.src = tempCanvas.toDataURL();
        }

        function cancelCrop() {
            isCropMode = false;
            cropElement = null;
            cropAspectRatio = null;

            const overlay = document.getElementById('cropOverlay');
            overlay.style.display = 'none';

            // Remove event listeners
            const newOverlay = overlay.cloneNode(true);
            overlay.parentNode.replaceChild(newOverlay, overlay);
        }

        // P19: Enhanced Crop Functions
        function setCropRatio(ratio) {
            cropAspectRatio = ratio;

            // Update button states
            document.querySelectorAll('.crop-ratio-btns button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            // Apply aspect ratio to current crop
            if (ratio !== 'free' && cropRect) {
                const ratios = {
                    '1:1': 1/1,
                    '16:9': 16/9,
                    '4:3': 4/3,
                    '3:2': 3/2
                };

                const targetRatio = ratios[ratio];
                const currentRatio = cropRect.width / cropRect.height;

                if (currentRatio > targetRatio) {
                    // Too wide, adjust width
                    const newWidth = cropRect.height * targetRatio;
                    cropRect.x += (cropRect.width - newWidth) / 2;
                    cropRect.width = newWidth;
                } else {
                    // Too tall, adjust height
                    const newHeight = cropRect.width / targetRatio;
                    cropRect.y += (cropRect.height - newHeight) / 2;
                    cropRect.height = newHeight;
                }

                showCropOverlay();
            }
        }

        function rotateImage(degrees) {
            if (!cropElement || !cropElement.imageData) return;

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = cropElement.imageData;

            // Swap dimensions for 90 or -90 degree rotation
            if (Math.abs(degrees) === 90) {
                canvas.width = img.height;
                canvas.height = img.width;
            } else {
                canvas.width = img.width;
                canvas.height = img.height;
            }

            // Rotate
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.rotate(degrees * Math.PI / 180);
            ctx.drawImage(img, -img.width / 2, -img.height / 2);

            // Create new image
            const newImg = new Image();
            newImg.onload = function() {
                cropElement.imageData = newImg;
                imageCache.set(cropElement.id, newImg);

                // Update element dimensions
                if (Math.abs(degrees) === 90) {
                    const temp = cropElement.width;
                    cropElement.width = cropElement.height;
                    cropElement.height = temp;
                }

                // Reset crop rect
                cropRect = {
                    x: cropElement.x,
                    y: cropElement.y,
                    width: cropElement.width,
                    height: cropElement.height
                };

                showCropOverlay();
                render();
            };
            newImg.src = canvas.toDataURL();
        }

        function flipImage(direction) {
            if (!cropElement || !cropElement.imageData) return;

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = cropElement.imageData;

            canvas.width = img.width;
            canvas.height = img.height;

            ctx.save();

            if (direction === 'horizontal') {
                ctx.scale(-1, 1);
                ctx.drawImage(img, -img.width, 0);
            } else {
                ctx.scale(1, -1);
                ctx.drawImage(img, 0, -img.height);
            }

            ctx.restore();

            // Create new image
            const newImg = new Image();
            newImg.onload = function() {
                cropElement.imageData = newImg;
                imageCache.set(cropElement.id, newImg);
                render();
            };
            newImg.src = canvas.toDataURL();
        }

        // P23: Style Library Functions
        function saveCurrentStyle() {
            if (!selectedElement) {
                alert('Ïä§ÌÉÄÏùºÏùÑ Ï†ÄÏû•Ìï† ÏöîÏÜåÎ•º ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.');
                return;
            }

            const styleName = prompt('Ïä§ÌÉÄÏùº Ïù¥Î¶ÑÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî:', `Style ${savedStyles.length + 1}`);
            if (!styleName) return;

            const style = {
                id: Date.now(),
                name: styleName,
                type: selectedElement.type,
                fill: selectedElement.fill,
                stroke: selectedElement.stroke,
                strokeWidth: selectedElement.strokeWidth,
                opacity: selectedElement.opacity,
                blendMode: selectedElement.blendMode
            };

            // Add type-specific properties
            if (selectedElement.type === 'text') {
                style.fontSize = selectedElement.fontSize;
                style.fontFamily = selectedElement.fontFamily;
                style.bold = selectedElement.bold;
                style.italic = selectedElement.italic;
                style.underline = selectedElement.underline;
                style.textAlign = selectedElement.textAlign;
                style.lineHeight = selectedElement.lineHeight;
                style.letterSpacing = selectedElement.letterSpacing;
                if (selectedElement.textShadow) {
                    style.textShadow = {...selectedElement.textShadow};
                }
            }

            if (selectedElement.gradient && selectedElement.gradient.enabled) {
                style.gradient = {...selectedElement.gradient};
            }

            savedStyles.push(style);
            localStorage.setItem('savedStyles', JSON.stringify(savedStyles));
            alert(`Ïä§ÌÉÄÏùº "${styleName}"Ïù¥ Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§!`);
        }

        function showStylesModal() {
            if (!selectedElement) {
                alert('Ïä§ÌÉÄÏùºÏùÑ Ï†ÅÏö©Ìï† ÏöîÏÜåÎ•º ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.');
                return;
            }

            const modal = document.getElementById('stylesModal');
            const list = document.getElementById('savedStylesList');

            if (savedStyles.length === 0) {
                list.innerHTML = '<p style="text-align: center; color: #999; padding: 40px;">Ï†ÄÏû•Îêú Ïä§ÌÉÄÏùºÏù¥ ÏóÜÏäµÎãàÎã§.</p>';
            } else {
                list.innerHTML = '';
                savedStyles.forEach((style, index) => {
                    const card = document.createElement('div');
                    card.className = 'style-card';
                    card.style.cssText = `
                        padding: 15px;
                        margin-bottom: 10px;
                        border: 2px solid #e0e0e0;
                        border-radius: 8px;
                        cursor: pointer;
                        transition: all 0.2s;
                    `;

                    card.innerHTML = `
                        <div style="font-weight: 600; margin-bottom: 8px;">${style.name}</div>
                        <div style="font-size: 12px; color: #666; margin-bottom: 8px;">Type: ${style.type}</div>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            ${style.fill ? `<div style="width: 24px; height: 24px; background: ${style.fill}; border: 1px solid #ccc; border-radius: 4px;"></div>` : ''}
                            ${style.fontSize ? `<span style="font-size: 12px;">Font: ${style.fontSize}px ${style.fontFamily}</span>` : ''}
                            ${style.blendMode && style.blendMode !== 'source-over' ? `<span style="font-size: 11px; background: #f0f0f0; padding: 2px 6px; border-radius: 3px;">${style.blendMode}</span>` : ''}
                        </div>
                    `;

                    card.onclick = () => applyStyle(style);
                    card.ondblclick = (e) => {
                        e.stopPropagation();
                        deleteStyle(index);
                    };

                    card.onmouseenter = () => {
                        card.style.borderColor = '#667eea';
                        card.style.background = '#f8f9ff';
                    };

                    card.onmouseleave = () => {
                        card.style.borderColor = '#e0e0e0';
                        card.style.background = 'white';
                    };

                    list.appendChild(card);
                });
            }

            modal.classList.add('active');
        }

        function closeStylesModal() {
            document.getElementById('stylesModal').classList.remove('active');
        }

        function applyStyle(style) {
            if (!selectedElement) return;

            // Apply common properties
            selectedElement.fill = style.fill;
            selectedElement.stroke = style.stroke;
            selectedElement.strokeWidth = style.strokeWidth;
            selectedElement.opacity = style.opacity;
            if (style.blendMode) {
                selectedElement.blendMode = style.blendMode;
            }

            // Apply type-specific properties
            if (style.type === 'text' && selectedElement.type === 'text') {
                if (style.fontSize) selectedElement.fontSize = style.fontSize;
                if (style.fontFamily) selectedElement.fontFamily = style.fontFamily;
                if (style.bold !== undefined) selectedElement.bold = style.bold;
                if (style.italic !== undefined) selectedElement.italic = style.italic;
                if (style.underline !== undefined) selectedElement.underline = style.underline;
                if (style.textAlign) selectedElement.textAlign = style.textAlign;
                if (style.lineHeight) selectedElement.lineHeight = style.lineHeight;
                if (style.letterSpacing !== undefined) selectedElement.letterSpacing = style.letterSpacing;
                if (style.textShadow) {
                    selectedElement.textShadow = {...style.textShadow};
                }
            }

            if (style.gradient) {
                selectedElement.gradient = {...style.gradient};
            }

            updatePropertiesPanel();
            saveHistory();
            render();
            closeStylesModal();
        }

        function deleteStyle(index) {
            const confirmed = confirm('Ïù¥ Ïä§ÌÉÄÏùºÏùÑ ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?');
            if (!confirmed) return;

            savedStyles.splice(index, 1);
            localStorage.setItem('savedStyles', JSON.stringify(savedStyles));
            showStylesModal(); // Refresh the list
        }

        // P24: Multi-page Design Functions
        function saveCurrentPage() {
            // Save current elements to current page
            pages[currentPageIndex].elements = JSON.parse(JSON.stringify(elements));
        }

        function loadPage(index) {
            if (index < 0 || index >= pages.length) return;

            // Save current page before switching
            saveCurrentPage();

            // Load new page
            currentPageIndex = index;
            elements = JSON.parse(JSON.stringify(pages[index].elements));
            selectedElement = null;
            selectedElements = [];

            // Restore image cache for loaded elements
            elements.forEach(el => {
                if (el.type === 'image' && el.imageData) {
                    const img = new Image();
                    img.onload = () => {
                        el.imageData = img;
                        imageCache.set(el.id, img);
                        render();
                    };
                    img.src = el.imageData;
                }
            });

            updatePropertiesPanel();
            updateLayersList();
            updatePageThumbnails();
            render();
        }

        function addNewPage() {
            saveCurrentPage();

            const newPage = {
                id: Date.now(),
                name: `Page ${pages.length + 1}`,
                elements: []
            };

            pages.push(newPage);
            loadPage(pages.length - 1);
        }

        function deletePage(index) {
            if (pages.length === 1) {
                alert('ÎßàÏßÄÎßâ ÌéòÏù¥ÏßÄÎäî ÏÇ≠Ï†úÌï† Ïàò ÏóÜÏäµÎãàÎã§.');
                return;
            }

            const confirmed = confirm(`"${pages[index].name}"ÏùÑ(Î•º) ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?`);
            if (!confirmed) return;

            pages.splice(index, 1);

            // Adjust current page index if needed
            if (currentPageIndex >= pages.length) {
                currentPageIndex = pages.length - 1;
            }

            loadPage(currentPageIndex);
        }

        function updatePageThumbnails() {
            const container = document.getElementById('pageThumbnails');
            container.innerHTML = '';

            pages.forEach((page, index) => {
                const thumb = document.createElement('div');
                thumb.className = 'page-thumb' + (index === currentPageIndex ? ' active' : '');

                // Create mini canvas for thumbnail
                const miniCanvas = document.createElement('canvas');
                miniCanvas.className = 'page-thumb-canvas';
                miniCanvas.width = 80;
                miniCanvas.height = 60;
                const miniCtx = miniCanvas.getContext('2d');

                // Draw page contents
                miniCtx.fillStyle = 'white';
                miniCtx.fillRect(0, 0, 80, 60);

                const scale = Math.min(80 / canvas.width, 60 / canvas.height);
                miniCtx.save();
                miniCtx.scale(scale, scale);

                page.elements.forEach(el => {
                    if (el.visible && el.type !== 'image') {
                        miniCtx.fillStyle = el.fill;
                        miniCtx.globalAlpha = el.opacity || 1;
                        if (el.type === 'rect') {
                            miniCtx.fillRect(el.x, el.y, el.width, el.height);
                        } else if (el.type === 'circle') {
                            miniCtx.beginPath();
                            miniCtx.arc(el.x + el.width / 2, el.y + el.height / 2, el.width / 2, 0, Math.PI * 2);
                            miniCtx.fill();
                        }
                    }
                });

                miniCtx.restore();

                thumb.appendChild(miniCanvas);

                // Delete button
                const deleteBtn = document.createElement('div');
                deleteBtn.className = 'page-thumb-delete';
                deleteBtn.textContent = '√ó';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    deletePage(index);
                };
                thumb.appendChild(deleteBtn);

                thumb.onclick = () => loadPage(index);
                container.appendChild(thumb);
            });
        }

        // P25: Version History Functions
        function saveVersion() {
            if (!currentProjectId) return;

            saveCurrentPage(); // Save current page first

            const version = {
                id: Date.now(),
                timestamp: new Date().toISOString(),
                pages: JSON.parse(JSON.stringify(pages)),
                currentPageIndex: currentPageIndex
            };

            versions.push(version);

            // Keep only last 20 versions
            if (versions.length > 20) {
                versions = versions.slice(-20);
            }

            localStorage.setItem('projectVersions_' + currentProjectId, JSON.stringify(versions));
        }

        function showVersionHistoryModal() {
            const modal = document.getElementById('versionHistoryModal');
            const list = document.getElementById('versionsList');

            if (versions.length === 0) {
                list.innerHTML = '<p style="text-align: center; color: #999; padding: 40px;">Ï†ÄÏû•Îêú Î≤ÑÏ†ÑÏù¥ ÏóÜÏäµÎãàÎã§.</p>';
            } else {
                list.innerHTML = '';
                // Show newest first
                [...versions].reverse().forEach((version, index) => {
                    const actualIndex = versions.length - 1 - index;
                    const date = new Date(version.timestamp);
                    const timeStr = date.toLocaleString('ko-KR');

                    const card = document.createElement('div');
                    card.style.cssText = `
                        padding: 15px;
                        margin-bottom: 10px;
                        border: 2px solid #e0e0e0;
                        border-radius: 8px;
                        cursor: pointer;
                        transition: all 0.2s;
                    `;

                    card.innerHTML = `
                        <div style="font-weight: 600; margin-bottom: 8px;">Î≤ÑÏ†Ñ ${actualIndex + 1}</div>
                        <div style="font-size: 12px; color: #666; margin-bottom: 8px;">
                            ${timeStr}
                        </div>
                        <div style="font-size: 12px; color: #999;">
                            ${version.pages.length}Í∞ú ÌéòÏù¥ÏßÄ
                        </div>
                    `;

                    card.onclick = () => restoreVersion(actualIndex);

                    card.onmouseenter = () => {
                        card.style.borderColor = '#667eea';
                        card.style.background = '#f8f9ff';
                    };

                    card.onmouseleave = () => {
                        card.style.borderColor = '#e0e0e0';
                        card.style.background = 'white';
                    };

                    list.appendChild(card);
                });
            }

            modal.classList.add('active');
        }

        function closeVersionHistoryModal() {
            document.getElementById('versionHistoryModal').classList.remove('active');
        }

        function restoreVersion(index) {
            const confirmed = confirm('Ïù¥ Î≤ÑÏ†ÑÏúºÎ°ú Î≥µÏõêÌïòÏãúÍ≤†ÏäµÎãàÍπå? ÌòÑÏû¨ ÏûëÏóÖ ÎÇ¥Ïö©ÏùÄ Ï†ÄÏû•ÎêòÏßÄ ÏïäÏäµÎãàÎã§.');
            if (!confirmed) return;

            const version = versions[index];
            pages = JSON.parse(JSON.stringify(version.pages));
            currentPageIndex = version.currentPageIndex || 0;

            loadPage(currentPageIndex);
            closeVersionHistoryModal();
            alert('Î≤ÑÏ†ÑÏù¥ Î≥µÏõêÎêòÏóàÏäµÎãàÎã§!');
        }

        function startVersionAutoSave() {
            // Save version every 5 minutes
            versionInterval = setInterval(() => {
                saveVersion();
            }, 5 * 60 * 1000);

            // Save initial version
            saveVersion();
        }

        // P11: Collaboration Functions
        function showCollaborateModal() {
            document.getElementById('collaborateModal').classList.add('active');
            // Auto-generate link on open
            if (currentProjectId) {
                const baseUrl = window.location.origin;
                document.getElementById('shareLink').value = `${baseUrl}/editor-canva.html?id=${currentProjectId}&share=true`;
            }
        }

        function closeCollaborateModal() {
            document.getElementById('collaborateModal').classList.remove('active');
        }

        function generateShareLink() {
            if (!currentProjectId) {
                alert('ÌîÑÎ°úÏ†ùÌä∏Î•º Î®ºÏ†Ä Ï†ÄÏû•Ìï¥Ï£ºÏÑ∏Ïöî.');
                return;
            }

            const permission = document.getElementById('sharePermission').value;
            const baseUrl = window.location.origin;
            const shareUrl = `${baseUrl}/editor-canva.html?id=${currentProjectId}&share=true&permission=${permission}`;

            document.getElementById('shareLink').value = shareUrl;
            alert('Í≥µÏú† ÎßÅÌÅ¨Í∞Ä ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§!');
        }

        function copyShareLink() {
            const shareLink = document.getElementById('shareLink');
            shareLink.select();
            document.execCommand('copy');
            alert('ÎßÅÌÅ¨Í∞Ä Î≥µÏÇ¨ÎêòÏóàÏäµÎãàÎã§!');
        }

        // P12: Animation Functions
        function updateAnimation(prop, value) {
            if (!selectedElement || !selectedElement.animation) return;

            selectedElement.animation[prop] = prop === 'type' ? value : parseFloat(value);

            if (prop === 'duration') {
                document.getElementById('durationValue').textContent = parseFloat(value).toFixed(1) + 's';
            } else if (prop === 'delay') {
                document.getElementById('delayValue').textContent = parseFloat(value).toFixed(1) + 's';
            }
        }

        function previewAnimation() {
            if (!selectedElement || !selectedElement.animation || selectedElement.animation.type === 'none') {
                alert('Ïï†ÎãàÎ©îÏù¥ÏÖò Ïú†ÌòïÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.');
                return;
            }

            // Simple preview using canvas state changes
            const originalX = selectedElement.x;
            const originalY = selectedElement.y;
            const originalOpacity = selectedElement.opacity;

            const animType = selectedElement.animation.type;
            const duration = selectedElement.animation.duration * 1000;
            const delay = selectedElement.animation.delay * 1000;

            setTimeout(() => {
                const startTime = Date.now();
                const animateFrame = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    switch (animType) {
                        case 'fadeIn':
                            selectedElement.opacity = progress * originalOpacity;
                            break;
                        case 'fadeOut':
                            selectedElement.opacity = (1 - progress) * originalOpacity;
                            break;
                        case 'slideLeft':
                            selectedElement.x = originalX + (1 - progress) * 100;
                            break;
                        case 'slideRight':
                            selectedElement.x = originalX - (1 - progress) * 100;
                            break;
                        case 'slideUp':
                            selectedElement.y = originalY + (1 - progress) * 100;
                            break;
                        case 'slideDown':
                            selectedElement.y = originalY - (1 - progress) * 100;
                            break;
                        case 'bounce':
                            const bounce = Math.abs(Math.sin(progress * Math.PI * 3)) * (1 - progress);
                            selectedElement.y = originalY - bounce * 50;
                            break;
                        case 'pulse':
                            const scale = 1 + Math.sin(progress * Math.PI * 4) * 0.1;
                            // Simple pulse effect (would need more complex scaling)
                            break;
                    }

                    isDirty = true;
                    render();

                    if (progress < 1) {
                        requestAnimationFrame(animateFrame);
                    } else {
                        // Reset to original state
                        selectedElement.x = originalX;
                        selectedElement.y = originalY;
                        selectedElement.opacity = originalOpacity;
                        isDirty = true;
                        render();
                    }
                };
                animateFrame();
            }, delay);
        }

        // P13: AI Functions
        async function removeBackground() {
            if (!selectedElement || selectedElement.type !== 'image') {
                alert('Ïù¥ÎØ∏ÏßÄÎ•º ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.');
                return;
            }

            const confirmed = confirm('AI Î∞∞Í≤Ω Ï†úÍ±∞Î•º Ïã§ÌñâÌïòÏãúÍ≤†ÏäµÎãàÍπå? (AI ÏÑúÎπÑÏä§ Ïó∞Îèô ÌïÑÏöî)');
            if (!confirmed) return;

            try {
                // Prepare image data
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = selectedElement.imageData.width;
                tempCanvas.height = selectedElement.imageData.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(selectedElement.imageData, 0, 0);
                const imageDataUrl = tempCanvas.toDataURL('image/png');

                // Call AI service
                const response = await fetchWithRetry(API_URL + '/api/ai/remove-background', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + localStorage.getItem('token')
                    },
                    body: JSON.stringify({ image: imageDataUrl })
                });

                if (response.ok) {
                    const result = await response.json();
                    // Load result image
                    const img = new Image();
                    img.onload = function() {
                        selectedElement.imageData = img;
                        saveHistory();
                        isDirty = true;
                        render();
                        alert('Î∞∞Í≤ΩÏù¥ Ï†úÍ±∞ÎêòÏóàÏäµÎãàÎã§!');
                    };
                    img.src = result.processedImage;
                } else {
                    throw new Error('AI ÏÑúÎπÑÏä§ ÏùëÎãµ Ïã§Ìå®');
                }
            } catch (error) {
                console.error('Background removal error:', error);
                alert('Î∞∞Í≤Ω Ï†úÍ±∞ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. AI ÏÑúÎπÑÏä§Í∞Ä Ïó∞ÎèôÎêòÏñ¥ ÏûàÎäîÏßÄ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.');
            }
        }

        async function upscaleImage() {
            if (!selectedElement || selectedElement.type !== 'image') {
                alert('Ïù¥ÎØ∏ÏßÄÎ•º ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.');
                return;
            }

            const confirmed = confirm('AI Í≥†Ìï¥ÏÉÅÎèÑ Î≥ÄÌôòÏùÑ Ïã§ÌñâÌïòÏãúÍ≤†ÏäµÎãàÍπå? (Ï≤òÎ¶¨ ÏãúÍ∞ÑÏù¥ ÏÜåÏöîÎê† Ïàò ÏûàÏäµÎãàÎã§)');
            if (!confirmed) return;

            try {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = selectedElement.imageData.width;
                tempCanvas.height = selectedElement.imageData.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(selectedElement.imageData, 0, 0);
                const imageDataUrl = tempCanvas.toDataURL('image/png');

                const response = await fetchWithRetry(API_URL + '/api/ai/upscale', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + localStorage.getItem('token')
                    },
                    body: JSON.stringify({ image: imageDataUrl, scale: 2 })
                });

                if (response.ok) {
                    const result = await response.json();
                    const img = new Image();
                    img.onload = function() {
                        selectedElement.imageData = img;
                        selectedElement.width *= 2;
                        selectedElement.height *= 2;
                        saveHistory();
                        isDirty = true;
                        render();
                        alert('Ïù¥ÎØ∏ÏßÄÍ∞Ä Í≥†Ìï¥ÏÉÅÎèÑÎ°ú Î≥ÄÌôòÎêòÏóàÏäµÎãàÎã§!');
                    };
                    img.src = result.upscaledImage;
                } else {
                    throw new Error('AI ÏÑúÎπÑÏä§ ÏùëÎãµ Ïã§Ìå®');
                }
            } catch (error) {
                console.error('Upscale error:', error);
                alert('ÏóÖÏä§ÏºÄÏùºÎßÅ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. AI ÏÑúÎπÑÏä§Í∞Ä Ïó∞ÎèôÎêòÏñ¥ ÏûàÎäîÏßÄ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.');
            }
        }

        function showStyleTransferModal() {
            if (!selectedElement || selectedElement.type !== 'image') {
                alert('Ïù¥ÎØ∏ÏßÄÎ•º ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.');
                return;
            }

            const styles = ['Î∞ò Í≥†Ìùê', 'ÌîºÏπ¥ÏÜå', 'Î™®ÎÑ§', 'ÏàòÏ±ÑÌôî', 'Ïú†Ìôî', 'Ïó∞ÌïÑ Ïä§ÏºÄÏπò'];
            const style = prompt('Ïä§ÌÉÄÏùºÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî:\n' + styles.map((s, i) => `${i+1}. ${s}`).join('\n'));

            if (!style) return;

            const styleIndex = parseInt(style) - 1;
            if (styleIndex >= 0 && styleIndex < styles.length) {
                applyStyleTransfer(styles[styleIndex]);
            } else {
                alert('Ïò¨Î∞îÎ•∏ Î≤àÌò∏Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
            }
        }

        async function applyStyleTransfer(styleName) {
            try {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = selectedElement.imageData.width;
                tempCanvas.height = selectedElement.imageData.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(selectedElement.imageData, 0, 0);
                const imageDataUrl = tempCanvas.toDataURL('image/png');

                const response = await fetchWithRetry(API_URL + '/api/ai/style-transfer', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + localStorage.getItem('token')
                    },
                    body: JSON.stringify({ image: imageDataUrl, style: styleName })
                });

                if (response.ok) {
                    const result = await response.json();
                    const img = new Image();
                    img.onload = function() {
                        selectedElement.imageData = img;
                        saveHistory();
                        isDirty = true;
                        render();
                        alert(`${styleName} Ïä§ÌÉÄÏùºÏù¥ Ï†ÅÏö©ÎêòÏóàÏäµÎãàÎã§!`);
                    };
                    img.src = result.styledImage;
                } else {
                    throw new Error('AI ÏÑúÎπÑÏä§ ÏùëÎãµ Ïã§Ìå®');
                }
            } catch (error) {
                console.error('Style transfer error:', error);
                alert('Ïä§ÌÉÄÏùº Î≥ÄÌôò Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. AI ÏÑúÎπÑÏä§Í∞Ä Ïó∞ÎèôÎêòÏñ¥ ÏûàÎäîÏßÄ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.');
            }
        }

        // P14: Brand Kit Functions
        function saveBrandColor() {
            if (!selectedElement) {
                alert('ÏöîÏÜåÎ•º ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.');
                return;
            }

            const color = selectedElement.fill;
            let brandColors = JSON.parse(localStorage.getItem('brandColors') || '[]');

            if (brandColors.includes(color)) {
                alert('Ïù¥ÎØ∏ Ï†ÄÏû•Îêú ÏÉâÏÉÅÏûÖÎãàÎã§.');
                return;
            }

            if (brandColors.length >= 12) {
                alert('ÏµúÎåÄ 12Í∞úÏùò Î∏åÎûúÎìú ÏÉâÏÉÅÏùÑ Ï†ÄÏû•Ìï† Ïàò ÏûàÏäµÎãàÎã§.');
                return;
            }

            brandColors.push(color);
            localStorage.setItem('brandColors', JSON.stringify(brandColors));
            alert('Î∏åÎûúÎìú ÏÉâÏÉÅÏù¥ Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§!');

            // Refresh brand colors display
            if (document.getElementById('brandColorGrid').style.display !== 'none') {
                showBrandColors();
            }
        }

        function showBrandColors() {
            const brandColorGrid = document.getElementById('brandColorGrid');
            const brandColors = JSON.parse(localStorage.getItem('brandColors') || '[]');

            if (brandColors.length === 0) {
                alert('Ï†ÄÏû•Îêú Î∏åÎûúÎìú ÏÉâÏÉÅÏù¥ ÏóÜÏäµÎãàÎã§. ÌòÑÏû¨ ÏÉâÏÉÅÏùÑ Ï†ÄÏû•Ìï¥Î≥¥ÏÑ∏Ïöî!');
                return;
            }

            // Toggle visibility
            if (brandColorGrid.style.display === 'none') {
                brandColorGrid.style.display = 'grid';

                // Populate brand colors
                brandColorGrid.innerHTML = '';
                brandColors.forEach((color, index) => {
                    const swatch = document.createElement('div');
                    swatch.className = 'color-swatch';
                    swatch.style.background = color;
                    swatch.style.position = 'relative';
                    swatch.onclick = () => setColor(color);

                    // Add remove button
                    swatch.ondblclick = (e) => {
                        e.stopPropagation();
                        removeBrandColor(index);
                    };
                    swatch.title = `ÌÅ¥Î¶≠: ÏÉâÏÉÅ Ï†ÅÏö© | ÎçîÎ∏îÌÅ¥Î¶≠: ÏÇ≠Ï†ú`;

                    brandColorGrid.appendChild(swatch);
                });
            } else {
                brandColorGrid.style.display = 'none';
            }
        }

        function removeBrandColor(index) {
            const confirmed = confirm('Ïù¥ Î∏åÎûúÎìú ÏÉâÏÉÅÏùÑ ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?');
            if (!confirmed) return;

            let brandColors = JSON.parse(localStorage.getItem('brandColors') || '[]');
            brandColors.splice(index, 1);
            localStorage.setItem('brandColors', JSON.stringify(brandColors));
            showBrandColors();
            showBrandColors(); // Toggle twice to refresh
        }

        // P15: Plugin System Functions
        function initializePlugins() {
            console.log('Initializing Artify Plugin System...');

            // Initialize all registered plugins
            plugins.forEach(plugin => {
                try {
                    plugin.init(pluginAPI.getContext());
                    console.log(`Plugin "${plugin.name}" initialized successfully`);
                } catch (error) {
                    console.error(`Failed to initialize plugin "${plugin.name}":`, error);
                }
            });

            console.log(`${plugins.length} plugin(s) loaded`);

            // Example: Register a demo plugin
            registerDemoPlugin();
        }

        function registerDemoPlugin() {
            // Example plugin that adds a rainbow effect
            const rainbowPlugin = {
                name: 'Rainbow Effect Plugin',
                version: '1.0.0',
                description: 'Adds rainbow color effect to selected elements',
                init: function(context) {
                    // Plugin initialization
                    console.log('Rainbow plugin loaded!');

                    // Add custom function to window for external access
                    window.applyRainbowEffect = function() {
                        if (!context.selectedElement) {
                            context.showMessage('ÏöîÏÜåÎ•º ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.');
                            return;
                        }

                        const colors = ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3'];
                        let colorIndex = 0;

                        const interval = setInterval(() => {
                            if (context.selectedElement) {
                                context.updateElement(context.selectedElement, {
                                    fill: colors[colorIndex % colors.length]
                                });
                                colorIndex++;

                                if (colorIndex >= colors.length * 3) {
                                    clearInterval(interval);
                                }
                            } else {
                                clearInterval(interval);
                            }
                        }, 200);
                    };
                }
            };

            pluginAPI.registerPlugin(rainbowPlugin);
        }

        // Example of how external plugins can register
        // External developers can use:
        // <script>
        //   window.ArtifyPluginAPI.registerPlugin({
        //     name: 'My Custom Plugin',
        //     version: '1.0.0',
        //     init: function(context) {
        //       // Custom plugin code
        //     }
        //   });
        // </script>

        // P16: Zoom & Pan Functions
        function updateZoomLevel() {
            document.getElementById('zoomLevel').textContent = Math.round(zoom * 100) + '%';
        }

        function zoomIn() {
            const oldZoom = zoom;
            zoom = Math.min(zoom * 1.2, MAX_ZOOM);

            // Zoom toward center
            const canvasRect = canvas.getBoundingClientRect();
            const centerX = canvasRect.width / 2;
            const centerY = canvasRect.height / 2;

            panX = centerX - (centerX - panX) * (zoom / oldZoom);
            panY = centerY - (centerY - panY) * (zoom / oldZoom);

            updateZoomLevel();
            render();
        }

        function zoomOut() {
            const oldZoom = zoom;
            zoom = Math.max(zoom / 1.2, MIN_ZOOM);

            // Zoom toward center
            const canvasRect = canvas.getBoundingClientRect();
            const centerX = canvasRect.width / 2;
            const centerY = canvasRect.height / 2;

            panX = centerX - (centerX - panX) * (zoom / oldZoom);
            panY = centerY - (centerY - panY) * (zoom / oldZoom);

            updateZoomLevel();
            render();
        }

        function fitToScreen() {
            // Reset zoom and pan
            zoom = 1;
            panX = 0;
            panY = 0;
            updateZoomLevel();
            render();
        }

        // Duplicate functions removed - already defined above

        // Close modals when clicking outside
        document.addEventListener('click', function(e) {
            const exportModal = document.getElementById('exportModal');
            const templateModal = document.getElementById('templateModal');
            const collaborateModal = document.getElementById('collaborateModal');
            const stylesModal = document.getElementById('stylesModal'); // P23
            const versionHistoryModal = document.getElementById('versionHistoryModal'); // P25

            if (e.target === exportModal) {
                closeExportModal();
            }
            if (e.target === templateModal) {
                closeTemplateModal();
            }
            if (e.target === collaborateModal) {
                closeCollaborateModal();
            }
            if (e.target === stylesModal) { // P23
                closeStylesModal();
            }
            if (e.target === versionHistoryModal) { // P25
                closeVersionHistoryModal();
            }
        });
    </script>

    <!-- Fabric.js CDN for Canvas Editor -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>

    <!-- jsPDF for PDF Export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <!-- Editor JavaScript -->
    <!-- editor.html is self-contained and doesn't need external editor scripts -->

    <!-- Authentication Scripts -->
    <script src="js/ui-kit.js"></script>
    <script src="js/auth.js"></script>
    <script src="js/editor-auth-init.js"></script>

</body>
</html>
